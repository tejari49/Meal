<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TimeRoster</title>
    
    <!-- PWA Meta -->
    <meta name="theme-color" content="#2563eb">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TimeRoster">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="TimeRoster">
    <meta name="msapplication-TileColor" content="#2563eb">
    
        <!-- PWA (GitHub Pages friendly) -->
    
    <meta name="description" content="TimeRoster ‚Äì Kalender, Schichten, Aufgaben, Chat.">
    <link rel="manifest" href="./manifest.webmanifest">
    <link rel="icon" href="./icons/icon-192.png">
    <link rel="apple-touch-icon" href="./icons/icon-192.png">
    <script>
        // Service Worker for offline + installability (works on GitHub Pages)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js', { scope: './' })
                    .catch(err => console.warn('Service Worker registration failed:', err));
            });
        }
    </script>
<!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts Sammlung -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600&display=swap" rel="stylesheet">

    <!-- Babel f√ºr JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.294.0",
            "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
            "firebase/auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js",
            "firebase/firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js",
            "firebase/analytics": "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js",
            "firebase/messaging": "https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging.js"
        }
    }
    </script>

    <style>
        body {
            overscroll-behavior-y: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            background-color: #000000;
            margin: 0;
            padding: 0;
            color: white; /* Fallback Farbe erzwingen */
        }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .font-inter { font-family: 'Inter', sans-serif; }
        .font-cinzel { font-family: 'Cinzel', serif; }
        .font-playfair { font-family: 'Great Vibes', cursive; }
        .font-merriweather { font-family: 'Atkinson Hyperlegible', sans-serif; }
        .font-oswald { font-family: 'Bebas Neue', sans-serif; }
        .font-msn { font-family: Verdana, Geneva, Tahoma, sans-serif; }
        ::-webkit-scrollbar { width: 0px; background: transparent; }

        .msn-window {
            background: rgba(248, 250, 252, 0.95);
            border: 1px solid rgba(226, 232, 240, 0.5);
            box-shadow: 0 40px 100px rgba(15, 23, 42, 0.25), 0 0 0 1px rgba(255,255,255,0.1) inset;
            color: #0f172a;
            backdrop-filter: blur(24px) saturate(1.8);
            -webkit-backdrop-filter: blur(24px) saturate(1.8);
        }
        .msn-header {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            text-shadow: none;
        }
        .msn-toolbar {
            background: rgba(248, 250, 252, 0.85);
            border-bottom: 1px solid rgba(226, 232, 240, 0.6);
            color: #0f172a;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
        .msn-surface {
            background: rgba(248, 250, 252, 0.92);
            color: #0f172a;
        }
        .chat-shell {
            border: 1px solid rgba(226, 232, 240, 0.6);
            border-radius: 24px;
            background: rgba(255, 255, 255, 0.88);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7), 0 2px 12px rgba(0,0,0,0.04);
        }
        .chat-message {
            border-radius: 20px;
            padding: 10px 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .chat-message:hover { transform: translateY(-1px); box-shadow: 0 3px 8px rgba(0,0,0,0.08); }
        .chat-shell-light {
            background: linear-gradient(180deg, #f0f7ff 0%, #e8f1fd 100%);
            border: 1px solid rgba(199,220,255,0.5);
        }
        .chat-shell-dark {
            background: linear-gradient(180deg, #0a0a0a 0%, #111111 100%);
            border: 1px solid rgba(255,255,255,0.06);
        }
        .chat-message-own-light {
            background: linear-gradient(135deg, #60a5fa 0%, #818cf8 100%);
            color: #ffffff;
        }
        .chat-message-other-light {
            background: rgba(255,255,255,0.95);
            color: #0f172a;
            border: 1px solid rgba(226,232,240,0.5);
        }
        .chat-message-own-dark {
            background: linear-gradient(135deg, #3b82f6 0%, #6366f1 100%);
            color: #ffffff;
        }
        .chat-message-other-dark {
            background: rgba(255,255,255,0.08);
            color: #e2e8f0;
            border: 1px solid rgba(255,255,255,0.06);
        }

        /* Modern messenger animations */
        @keyframes msg-slide-in {
            from { opacity: 0; transform: translateY(12px) scale(0.97); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes msg-slide-in-left {
            from { opacity: 0; transform: translateX(-12px) scale(0.97); }
            to { opacity: 1; transform: translateX(0) scale(1); }
        }
        @keyframes msg-slide-in-right {
            from { opacity: 0; transform: translateX(12px) scale(0.97); }
            to { opacity: 1; transform: translateX(0) scale(1); }
        }
        .msg-animate { animation: msg-slide-in 0.3s cubic-bezier(0.22, 1, 0.36, 1) forwards; }
        .msg-animate-left { animation: msg-slide-in-left 0.3s cubic-bezier(0.22, 1, 0.36, 1) forwards; }
        .msg-animate-right { animation: msg-slide-in-right 0.3s cubic-bezier(0.22, 1, 0.36, 1) forwards; }

        /* Camera UI styles */
        @keyframes cam-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.6); }
            50% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); }
        }
        .cam-capture-btn {
            width: 72px; height: 72px;
            border-radius: 50%;
            background: white;
            border: 4px solid rgba(255,255,255,0.3);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            position: relative;
        }
        .cam-capture-btn::before {
            content: '';
            position: absolute;
            inset: 4px;
            border-radius: 50%;
            background: white;
            transition: transform 0.15s ease;
        }
        .cam-capture-btn:active { transform: scale(0.9); }
        .cam-capture-btn:active::before { transform: scale(0.85); }
        .cam-recording { animation: cam-pulse 1.5s ease-in-out infinite; }
        .cam-recording::before { background: #ef4444; }

        .cam-control-btn {
            width: 44px; height: 44px;
            border-radius: 50%;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: background 0.2s ease, transform 0.15s ease;
            border: 1px solid rgba(255,255,255,0.15);
        }
        .cam-control-btn:hover { background: rgba(0,0,0,0.6); }
        .cam-control-btn:active { transform: scale(0.9); }
        .cam-control-btn.active { background: rgba(255,255,100,0.3); border-color: rgba(255,255,100,0.5); }

        @keyframes cam-flash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        .cam-flash-overlay {
            animation: cam-flash 0.3s ease-out forwards;
            background: white;
            position: absolute;
            inset: 0;
            z-index: 10;
            pointer-events: none;
        }

        @keyframes cam-focus-ring {
            0% { transform: scale(1.4); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        /* Viewfinder grid */
        .cam-viewfinder {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }
        .cam-viewfinder::before,
        .cam-viewfinder::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.15);
        }
        .cam-viewfinder::before {
            top: 33.33%; bottom: 33.33%;
            left: 0; right: 0;
            border-top: 1px solid rgba(255,255,255,0.15);
            border-bottom: 1px solid rgba(255,255,255,0.15);
            background: transparent;
        }
        .cam-viewfinder::after {
            left: 33.33%; right: 33.33%;
            top: 0; bottom: 0;
            border-left: 1px solid rgba(255,255,255,0.15);
            border-right: 1px solid rgba(255,255,255,0.15);
            background: transparent;
        }

        /* Modern contact card hover */
        .contact-card {
            transition: all 0.2s cubic-bezier(0.22, 1, 0.36, 1);
            border: 1px solid transparent;
        }
        .contact-card:hover {
            background: rgba(59, 130, 246, 0.04);
            border-color: rgba(59, 130, 246, 0.1);
            transform: translateX(2px);
        }

        /* Photo preview overlay */
        @keyframes preview-fade-in {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .photo-preview { animation: preview-fade-in 0.3s ease forwards; }
        .custom-theme {
            background-color: var(--custom-bg);
            color: var(--custom-text);
        }
        .custom-card {
            background-color: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--custom-text);
        }
        .custom-input {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.25);
            color: var(--custom-text);
        }
        .custom-button {
            background-color: var(--custom-accent);
            color: var(--custom-text);
        }
        .custom-header {
            background-color: var(--custom-accent);
            color: var(--custom-text);
        }
        .msn-status-online { background: radial-gradient(circle at 30% 30%, #a4ffa4, #008000); }
        .msn-status-offline { background: radial-gradient(circle at 30% 30%, #ffaaaa, #800000); }
        .tomorrow {
            box-shadow: inset 0 0 0 2px rgba(251, 191, 36, 0.6);
            background-color: rgba(251, 191, 36, 0.08);
        }
        .overmorrow {
            box-shadow: inset 0 0 0 2px rgba(34, 197, 94, 0.45);
            background-color: rgba(34, 197, 94, 0.08);
        }

        @keyframes pulse-soft {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.95); }
        }
        .animate-pulse-soft { animation: pulse-soft 1s infinite; }
        
        @keyframes blink-red {
            0%, 100% { color: #ef4444; opacity: 1; }
            50% { color: #dc2626; opacity: 0.7; }
        }
        .blink-red-notification {
            animation: blink-red 1.5s ease-in-out infinite;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-slate-950 text-white h-screen w-screen overflow-hidden">

    <div id="root" class="h-full w-full overflow-y-auto"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useMemo, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Calendar, List, Settings, Plus, X, ChevronLeft, ChevronRight, 
            MapPin, Bell, Repeat, Save, LogOut, Moon, Sun, Briefcase, Coffee, 
            CheckCircle, Play, Square, Award, Home, User, DollarSign, Plane, 
            Edit3, BarChart2, Mail, Lock, Trash2, Globe, Palette, Clock, Layout,
            FileText, MoreHorizontal, Type, ZoomIn, Users, Share2, Check, Eye, Eraser, Pencil,
            MessageCircle, Send, ArrowLeft, Camera, Image as ImageIcon, UserPlus, AlertCircle, Search,
            Download, Upload, Link2, Copy, UserCheck, Shield, Edit, FolderPlus, Paperclip,
            ListChecks, Pause, Timer, PieChart, TrendingUp, Activity, Zap
        } from 'lucide-react';

        import { initializeApp } from 'firebase/app';
        import { getAnalytics } from "firebase/analytics";
        import { 
            getAuth, signInAnonymously, onAuthStateChanged, signOut, 
            createUserWithEmailAndPassword, signInWithEmailAndPassword
        } from 'firebase/auth';
        import { 
            getFirestore, collection, doc, setDoc, addDoc, updateDoc, getDoc, getDocs,
            deleteDoc, onSnapshot, query, orderBy, where, serverTimestamp, writeBatch, limit, deleteField 
        } from 'firebase/firestore';
        import { getMessaging, getToken, onMessage } from 'firebase/messaging';

        // --- KONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyCLqi-PxHdeyt51u9i50tY0NhOAUbutW9g",
            authDomain: "calender-rai.firebaseapp.com",
            projectId: "calender-rai",
            storageBucket: "calender-rai.firebasestorage.app",
            messagingSenderId: "989981793002",
            appId: "1:989981793002:web:d23ba8bf2c30d6b8649593",
            measurementId: "G-CZLXPHK9GK"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Firebase Messaging (FCM) ---
        let messaging = null;
        try {
            messaging = getMessaging(app);
        } catch (e) {
            console.warn('FCM not available in this environment:', e?.message || e);
        }
        const APP_URL = "https://tejari49.github.io/Meal/";
        const DEFAULT_VAPID_KEY = ""; // Set your Web Push certificate key (VAPID public key) in Settings to enable push.
        const getVapidKey = () => (localStorage.getItem('timeroster_fcm_vapid_key') || DEFAULT_VAPID_KEY || '').trim();


        const appId = "timeroster-app";
        const getHostedBaseUrl = () => {
            const normalizeUrl = (value) => {
                if (!value) return null;
                if (value.startsWith('http://') || value.startsWith('https://')) return value;
                return `https://${value}`;
            };
            const authDomain = firebaseConfig?.authDomain;
            const projectId = firebaseConfig?.projectId;
            const fallbackDomain = projectId ? `${projectId}.web.app` : null;
            return normalizeUrl(authDomain || fallbackDomain) || window.location.origin;
        };
        const getHostedAppPath = () => {
            const path = window.location.pathname || '/';
            if (!path || path === '/') return '/';
            const lastSegment = path.split('/').pop() || '';
            // When the app is served from a file path (e.g. TimeRoster.html), keep the file name only.
            return lastSegment.includes('.') ? `/${lastSegment}` : path;
        };

        let CURRENT_LANG = 'de';
        const LOCALE_MAP = { de: 'de-DE', en: 'en-US', it: 'it-IT' };
        const GEO_LANG_MAP = { de: 'de', en: 'en', it: 'it' };
        const getLocaleForLang = (lang) => LOCALE_MAP[lang] || 'de-DE';
        const getCurrentLocale = () => getLocaleForLang(CURRENT_LANG);
        
        // --- NOTIFICATION CONSTANTS ---
        const NOTIFICATION_INDICATOR_CATEGORY_KEY = "fact";

        // --- HELPER FUNCTIONS ---
        const formatDate = (date) => date.toISOString().split('T')[0];
        const getDaysInMonth = (year, month) => new Date(year, month + 1, 0).getDate();
        const getFirstDayOfMonth = (year, month) => new Date(year, month, 1).getDay(); 
        /**
         * Calculate ISO 8601 week number for a given date (Monday-based weeks).
         * @param {Date} date - Target date to convert into ISO week number.
         * @returns {number} ISO week number.
         */
        const getISOWeekNumber = (date) => {
            const temp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            temp.setUTCDate(temp.getUTCDate() + 4 - (temp.getUTCDay() || 7));
            const yearStart = new Date(Date.UTC(temp.getUTCFullYear(), 0, 1));
            return Math.ceil((((temp - yearStart) / 86400000) + 1) / 7);
        };

        const generateCode = () => {
            const digits = '0123456789';
            let result = 'rai';
            for (let i = 0; i < 6; i++) result += digits.charAt(Math.floor(Math.random() * digits.length));
            return result;
        };

        const getUserName = (user, overrideName) => (overrideName || user?.displayName || user?.email?.split('@')[0] || t('userFallback'));

        const canUseStorage = (() => {
            let available;
            return () => {
                if (available !== undefined) return available;
                try {
                    const testKey = '__timeroster_storage_test__';
                    localStorage.setItem(testKey, testKey);
                    localStorage.removeItem(testKey);
                    available = true;
                } catch {
                    available = false;
                }
                return available;
            };
        })();

        const safeStorageGet = (key) => {
            if (!canUseStorage()) return null;
            try {
                return localStorage.getItem(key);
            } catch {
                return null;
            }
        };

        const safeStorageSet = (key, value) => {
            if (!canUseStorage()) return false;
            try {
                localStorage.setItem(key, value);
                return true;
            } catch {
                return false;
            }
        };

        const MAX_IMAGE_BYTES = 2 * 1024 * 1024;
        const MAX_IMAGE_SIZE_LABEL = '2 MB';
        const FILE_PICKER_FALLBACK_DELAY = 150;

        const compressImage = (file) => {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const MAX_WIDTH = 600;
                        const scaleSize = MAX_WIDTH / img.width;
                        canvas.width = MAX_WIDTH;
                        canvas.height = img.height * scaleSize;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        resolve(canvas.toDataURL('image/jpeg', 0.7));
                    }
                }
            });
        };

        // --- WEATHER (Open-Meteo) ---
        // Uses Open-Meteo Weather Forecast API (no API key). Current weather variables via `current=`.
        // Docs: https://open-meteo.com/en/docs
        const WEATHER_CACHE_KEY = "timeroster_weather_cache_v1";
        const WEATHER_CACHE_TTL_MS = 30 * 60 * 1000; // 30 min
        const DEFAULT_WEATHER_COORDS = { lat: 47.3769, lon: 8.5417, label: "Z√ºrich (Fallback)" }; // Zurich
        const getWeatherFallbackLabel = () => t('weatherFallbackLabel');
        
        const HOLIDAY_API_BASE = "https://date.nager.at/api/v3";
        const HOLIDAY_COUNTRIES_CACHE_KEY = "timeroster_holiday_countries_v1";
        const HOLIDAY_COUNTRIES_CACHE_TTL_MS = 30 * 24 * 60 * 60 * 1000; // 30 days
        const getHolidayPrefKey = (uid) => `timeroster_holiday_pref_v1_${uid || "anon"}`;
        const getHolidaySyncKey = (uid) => `timeroster_holiday_sync_v1_${uid || "anon"}`;
        const DEFAULT_HOLIDAY_PREF = {
            countryCode: 'CH',
            countryName: 'Switzerland',
            regionCode: '',
            regionName: '',
            calendarId: null
        };
        const SWISS_CANTONS = [
            { code: 'CH-AG', name: 'Aargau' },
            { code: 'CH-AI', name: 'Appenzell Innerrhoden' },
            { code: 'CH-AR', name: 'Appenzell Ausserrhoden' },
            { code: 'CH-BE', name: 'Bern' },
            { code: 'CH-BL', name: 'Basel-Landschaft' },
            { code: 'CH-BS', name: 'Basel-Stadt' },
            { code: 'CH-FR', name: 'Freiburg' },
            { code: 'CH-GE', name: 'Gen√®ve' },
            { code: 'CH-GL', name: 'Glarus' },
            { code: 'CH-GR', name: 'Graub√ºnden' },
            { code: 'CH-JU', name: 'Jura' },
            { code: 'CH-LU', name: 'Luzern' },
            { code: 'CH-NE', name: 'Neuch√¢tel' },
            { code: 'CH-NW', name: 'Nidwalden' },
            { code: 'CH-OW', name: 'Obwalden' },
            { code: 'CH-SG', name: 'St. Gallen' },
            { code: 'CH-SH', name: 'Schaffhausen' },
            { code: 'CH-SO', name: 'Solothurn' },
            { code: 'CH-SZ', name: 'Schwyz' },
            { code: 'CH-TG', name: 'Thurgau' },
            { code: 'CH-TI', name: 'Ticino' },
            { code: 'CH-UR', name: 'Uri' },
            { code: 'CH-VD', name: 'Vaud' },
            { code: 'CH-VS', name: 'Valais' },
            { code: 'CH-ZG', name: 'Zug' },
            { code: 'CH-ZH', name: 'Z√ºrich' }
        ];

        const getWeatherMeta = (code) => {
            const c = Number(code);
            if (c === 0) return { label: t("weatherClear"), icon: "‚òÄÔ∏è" };
            if ([1,2].includes(c)) return { label: t("weatherPartlyCloudy"), icon: "üå§Ô∏è" };
            if (c === 3) return { label: t("weatherOvercast"), icon: "‚òÅÔ∏è" };
            if ([45,48].includes(c)) return { label: t("weatherFog"), icon: "üå´Ô∏è" };
            if ([51,53,55,56,57].includes(c)) return { label: t("weatherDrizzle"), icon: "üå¶Ô∏è" };
            if ([61,63,65,66,67].includes(c)) return { label: t("weatherRain"), icon: "üåßÔ∏è" };
            if ([71,73,75,77,85,86].includes(c)) return { label: t("weatherSnow"), icon: "üå®Ô∏è" };
            if ([80,81,82].includes(c)) return { label: t("weatherShowers"), icon: "üå¶Ô∏è" };
            if ([95,96,99].includes(c)) return { label: t("weatherStorm"), icon: "‚õàÔ∏è" };
            return { label: t("weatherLabel"), icon: "üå°Ô∏è" };
        };

        const normalizeHolidayCountries = (items) => {
            if (!Array.isArray(items)) return [];
            return items.map(item => {
                if (!item) return null;
                if (typeof item === 'string') return { code: item, name: item };
                const code = item.countryCode || item.code || item.id;
                const name = item.name || item.label || code;
                if (!code || !name) return null;
                return { code, name };
            }).filter(Boolean);
        };

        const sortHolidayCountries = (items) => {
            return [...items].sort((a, b) => a.name.localeCompare(b.name, getCurrentLocale(), { sensitivity: 'base' }));
        };

        const getHolidayFallbackCountries = () => ([
            { code: 'CH', name: 'Switzerland' },
            { code: 'DE', name: 'Germany' },
            { code: 'AT', name: 'Austria' },
            { code: 'FR', name: 'France' },
            { code: 'IT', name: 'Italy' },
            { code: 'LI', name: 'Liechtenstein' },
            { code: 'US', name: 'United States' },
            { code: 'GB', name: 'United Kingdom' },
            { code: 'ES', name: 'Spain' },
            { code: 'PT', name: 'Portugal' },
            { code: 'NL', name: 'Netherlands' },
            { code: 'BE', name: 'Belgium' },
            { code: 'SE', name: 'Sweden' },
            { code: 'NO', name: 'Norway' },
            { code: 'DK', name: 'Denmark' },
            { code: 'FI', name: 'Finland' },
            { code: 'PL', name: 'Poland' },
            { code: 'CZ', name: 'Czechia' },
            { code: 'SK', name: 'Slovakia' },
            { code: 'HU', name: 'Hungary' },
            { code: 'RO', name: 'Romania' },
            { code: 'BG', name: 'Bulgaria' },
            { code: 'GR', name: 'Greece' },
            { code: 'IE', name: 'Ireland' },
            { code: 'AU', name: 'Australia' },
            { code: 'NZ', name: 'New Zealand' },
            { code: 'CA', name: 'Canada' },
            { code: 'BR', name: 'Brazil' },
            { code: 'MX', name: 'Mexico' },
            { code: 'JP', name: 'Japan' }
        ]);

        const getHolidayCache = (cacheKey) => {
            try {
                const raw = safeStorageGet(cacheKey);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                if (!parsed?.ts || !parsed?.items) return null;
                if ((Date.now() - parsed.ts) > HOLIDAY_COUNTRIES_CACHE_TTL_MS) return null;
                return parsed.items;
            } catch {
                return null;
            }
        };

        const setHolidayCache = (cacheKey, items) => {
            try {
                safeStorageSet(cacheKey, JSON.stringify({ ts: Date.now(), items }));
            } catch {
                // Ignore cache errors
            }
        };

        const fetchHolidayCountries = async () => {
            try {
                const cached = getHolidayCache(HOLIDAY_COUNTRIES_CACHE_KEY);
                if (cached) return cached;
                const res = await fetch(`${HOLIDAY_API_BASE}/AvailableCountries`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                const normalized = normalizeHolidayCountries(data);
                const sorted = sortHolidayCountries(normalized);
                if (sorted.length > 0) {
                    setHolidayCache(HOLIDAY_COUNTRIES_CACHE_KEY, sorted);
                }
                return sorted;
            } catch (e) {
                console.error("Holiday countries error", e);
                return [];
            }
        };

        const buildHolidayEventId = (calendarId, source, date, name) => {
            const base = `${calendarId}|${source}|${date}|${name || ''}`;
            const hash = hashStr(base).toString(16);
            return `holiday_${calendarId}_${source}_${date}_${hash}`;
        };

        const getHolidaySourceKey = (countryCode, regionCode) => {
            const region = regionCode ? `_${regionCode}` : '';
            return `${countryCode}${region}`;
        };

        const getHolidayRegionOptions = (countryCode) => {
            if (countryCode === 'CH') return SWISS_CANTONS;
            return [];
        };

        const getTomorrowStr = (baseDate = new Date()) => {
            const tomorrow = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate() + 1);
            return formatDate(tomorrow);
        };

        const getOvermorrowStr = (baseDate = new Date()) => {
            const overmorrow = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate() + 2);
            return formatDate(overmorrow);
        };

        const getForecastForDate = (forecastData, dateStr) => {
            if (!forecastData || !Array.isArray(forecastData.time)) return null;
            const idx = forecastData.time.indexOf(dateStr);
            if (idx === -1) return null;
            return {
                min: forecastData.temperature_2m_min?.[idx],
                max: forecastData.temperature_2m_max?.[idx],
                code: forecastData.weather_code?.[idx]
            };
        };

        const isValidTemperature = (value) => typeof value === 'number' && !Number.isNaN(value);

        const buildWeatherUrl = (lat, lon) => {
            const tz = "Europe/Zurich";
            const params = new URLSearchParams({
                latitude: String(lat),
                longitude: String(lon),
                current: "temperature_2m,weather_code,wind_speed_10m",
                wind_speed_unit: "kmh",
                temperature_unit: "celsius",
                timezone: tz
            });
            return `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
        };

        const buildGeocodeUrl = (name) => {
            const params = new URLSearchParams({
                name: String(name || ""),
                count: "8",
                language: GEO_LANG_MAP[CURRENT_LANG] || "de",
                format: "json"
            });
            return `https://geocoding-api.open-meteo.com/v1/search?${params.toString()}`;
        };

        const CURRENT_UI_PREFS_VERSION = 2;
        const getWeatherPrefKey = (uid) => `timeroster_weather_pref_v1_${uid || "anon"}`;
        const getUiPrefKey = (uid) => `timeroster_ui_prefs_v1_${uid || "anon"}`;

        // --- DAILY QUOTES (Weisheit / Motivation / Kompliment / Wissenswertes) ---
        // Kurz, alltagstauglich. Ein Mix aus Sprichw√∂rtern (gemeinfrei) und kurzen Original-Lines.
        const QUOTE_BANK = {
            wisdom: [
                { text: "Wer langsam geht, kommt auch an.", origin: "Sprichwort (Europa)" },
                { text: "Geduld ist auch eine Form von St√§rke.", origin: "Sprichwort (Asien)" },
                { text: "Der beste Zeitpunkt ist meistens jetzt.", origin: "Moderne Weisheit" },
                { text: "Ein ruhiger Geist sieht weiter.", origin: "Sprichwort (Japan)" },
                { text: "Worte sind leicht ‚Äì Handlungen z√§hlen.", origin: "Sprichwort (Afrika)" },
                { text: "Kleine Schritte schlagen grosse Absichten.", origin: "Sprichwort (Schweiz)" },
                { text: "Man kann den Wind nicht √§ndern, aber die Segel.", origin: "Sprichwort (Nordeuropa)" },
                { text: "Wer fragt, verliert nicht.", origin: "Sprichwort (DACH)" },
                { text: "Ein guter Plan lebt von Anpassung.", origin: "Operations-Realit√§t" },
                { text: "Ein klares Nein sch√ºtzt ein sauberes Ja.", origin: "Moderne Weisheit" },
                { text: "Wenn du es erkl√§ren kannst, hast du es verstanden.", origin: "Alltagsweisheit" },
                { text: "Ordnung schafft Freiheit.", origin: "Sprichwort (Mitteleuropa)" },
                { text: "Der Weg ist das Ziel ‚Äì aber der Kurs muss stimmen.", origin: "Moderne Weisheit" },
                { text: "Wer zuh√∂rt, versteht schneller.", origin: "Sprichwort (Global)" },
                { text: "Ein Fehler ist ein Hinweis, kein Urteil.", origin: "Moderne Weisheit" },
                { text: "Klarheit entsteht durch Entscheidungen.", origin: "Business-Realit√§t" },
                { text: "Was du misst, kannst du steuern.", origin: "Management-Weisheit" },
                { text: "Ein ruhiger Start spart sp√§ter Hektik.", origin: "Sprichwort (Schweiz)" },
                { text: "Nicht alles, was z√§hlt, ist laut.", origin: "Moderne Weisheit" },
                { text: "Sorgfalt ist Geschwindigkeit in Verkleidung.", origin: "Operations-Weisheit" }
            ],
            motivation: [
                { text: "Heute z√§hlt. Nicht irgendwann.", origin: "Motivation (Global)" },
                { text: "Du brauchst keinen perfekten Start ‚Äì nur den ersten Schritt.", origin: "Motivation (Global)" },
                { text: "Konsequenz schl√§gt Intensit√§t.", origin: "Motivation (Work)" },
                { text: "Mach's klein genug, dass du nicht aussteigst.", origin: "Motivation (Produktivit√§t)" },
                { text: "Wenn es unbequem ist, w√§chst du.", origin: "Motivation (Global)" },
                { text: "Fortschritt ist ein System, kein Zufall.", origin: "Motivation (Business)" },
                { text: "Du bist n√§her dran als du denkst.", origin: "Motivation (Global)" },
                { text: "Fokus ist ein Wettbewerbsvorteil.", origin: "Motivation (Business)" },
                { text: "Ein guter Tag beginnt mit einer klaren Priorit√§t.", origin: "Motivation (Work)" },
                { text: "Du steuerst den Kurs ‚Äì nicht den Wind.", origin: "Motivation (Seefahrt)" },
                { text: "Heute sauber arbeiten, morgen weniger Stress.", origin: "Motivation (Operations)" },
                { text: "Du darfst stolz auf deinen Effort sein.", origin: "Motivation (Global)" },
                { text: "Ein Schritt mehr als gestern ist genug.", origin: "Motivation (Global)" },
                { text: "Mach's einfach ‚Äì aber mach's zuverl√§ssig.", origin: "Motivation (Operations)" },
                { text: "Der Start ist schwer, der Rhythmus tr√§gt.", origin: "Motivation (Global)" },
                { text: "Disziplin ist Selbstrespekt in Aktion.", origin: "Motivation (Global)" },
                { text: "Du kannst das Tempo w√§hlen ‚Äì Hauptsache vorw√§rts.", origin: "Motivation (Global)" },
                { text: "Qualit√§t entsteht nicht durch Zufall, sondern durch Standards.", origin: "Motivation (Business)" },
                { text: "Eine Entscheidung pro Tag ver√§ndert ein Jahr.", origin: "Motivation (Global)" },
                { text: "Bleib bei deinem Prozess ‚Äì Resultate folgen.", origin: "Motivation (Business)" }
            ],
            compliment: [
                { text: "Du wirkst wie jemand, der Dinge wirklich zu Ende bringt.", origin: "Kompliment (Global)" },
                { text: "Deine Ruhe ist sp√ºrbar ‚Äì und wirkt ansteckend.", origin: "Kompliment (Global)" },
                { text: "Du denkst strukturiert. Das ist selten.", origin: "Kompliment (Business)" },
                { text: "Du bist verl√§sslich ‚Äì das ist Gold wert.", origin: "Kompliment (Work)" },
                { text: "Du hast ein gutes Auge f√ºr Details.", origin: "Kompliment (Global)" },
                { text: "Du bringst Klarheit in komplexe Themen.", origin: "Kompliment (Business)" },
                { text: "Du h√§ltst dein Wort. Das schafft Vertrauen.", origin: "Kompliment (Global)" },
                { text: "Du machst es anderen leichter ‚Äì ohne grosses Theater.", origin: "Kompliment (Schweiz)" },
                { text: "Du setzt Priorit√§ten wie ein Profi.", origin: "Kompliment (Operations)" },
                { text: "Du bist konsequent. Das sieht man.", origin: "Kompliment (Global)" },
                { text: "Du bist nicht laut ‚Äì aber wirkungsvoll.", origin: "Kompliment (Global)" },
                { text: "Du machst Qualit√§t sichtbar.", origin: "Kompliment (Work)" },
                { text: "Dein Anspruch an Sauberkeit ist sp√ºrbar.", origin: "Kompliment (Operations)" },
                { text: "Du bleibst dran, auch wenn's z√§h ist.", origin: "Kompliment (Global)" },
                { text: "Du schaffst Vertrauen durch Konstanz.", origin: "Kompliment (Business)" },
                { text: "Du hast ein gutes Timing f√ºr Entscheidungen.", origin: "Kompliment (Work)" },
                { text: "Du bringst Ordnung in Chaos ‚Äì diskret und effizient.", origin: "Kompliment (Business)" },
                { text: "Du bist l√∂sungsorientiert, nicht ausredeorientiert.", origin: "Kompliment (Work)" },
                { text: "Du kommunizierst klar ‚Äì das spart allen Zeit.", origin: "Kompliment (Business)" },
                { text: "Du hast eine starke Pr√§senz, ohne dich aufzudr√§ngen.", origin: "Kompliment (Global)" }
            ],
            fact: [
                { text: "Ein Tag auf der Venus ist l√§nger als ein Venusjahr.", origin: "Wissenswertes (Astronomie)" },
                { text: "Oktopusse haben drei Herzen.", origin: "Wissenswertes (Biologie)" },
                { text: "Honig kann bei guter Lagerung extrem lange haltbar sein.", origin: "Wissenswertes (Lebensmittel)" },
                { text: "Die Schweiz hat vier Landessprachen.", origin: "Wissenswertes (Schweiz)" },
                { text: "Ein Blitz kann heisser sein als die Oberfl√§che der Sonne.", origin: "Wissenswertes (Physik)" },
                { text: "Bienen kommunizieren u. a. √ºber einen 'Schw√§nzeltanz'.", origin: "Wissenswertes (Biologie)" },
                { text: "Wasser dehnt sich beim Gefrieren aus ‚Äì deshalb schwimmt Eis.", origin: "Wissenswertes (Physik)" },
                { text: "Dein Gehirn verbraucht rund 20% der Energie im Ruhezustand.", origin: "Wissenswertes (Biologie)" },
                { text: "Die Luft enth√§lt etwa 78% Stickstoff.", origin: "Wissenswertes (Chemie)" },
                { text: "Ein Tag hat 86'400 Sekunden.", origin: "Wissenswertes (Zeit)" },
                { text: "Der l√§ngste Fluss Europas ist die Wolga.", origin: "Wissenswertes (Geografie)" },
                { text: "Der Eiffelturm dehnt sich bei Hitze messbar aus.", origin: "Wissenswertes (Materialkunde)" },
                { text: "Wale schlafen, indem sie jeweils eine Gehirnh√§lfte ruhen lassen.", origin: "Wissenswertes (Biologie)" },
                { text: "Banenen sind botanisch gesehen Beeren.", origin: "Wissenswertes (Botanik)" },
                { text: "Das Herz schl√§gt im Schnitt etwa 100'000 Mal pro Tag.", origin: "Wissenswertes (Medizin)" },
                { text: "Ein Regenbogen ist ein optisches Ph√§nomen durch Brechung und Reflexion.", origin: "Wissenswertes (Physik)" },
                { text: "Die meisten Vulkane liegen entlang von Plattengrenzen.", origin: "Wissenswertes (Geologie)" },
                { text: "Der menschliche K√∂rper besteht zu rund 60% aus Wasser.", origin: "Wissenswertes (Biologie)" },
                { text: "Kaffee enth√§lt u. a. √ºber 800 Aromastoffe.", origin: "Wissenswertes (Lebensmittel)" },
                { text: "Der Mount Everest w√§chst jedes Jahr um wenige Millimeter.", origin: "Wissenswertes (Geologie)" }
            ]
        };

        const QUOTE_TRANSLATIONS = {
            en: {
                wisdom: [
                    { text: "Slow and steady still gets you there.", origin: "Proverb (Europe)" },
                    { text: "Patience is another form of strength.", origin: "Proverb (Asia)" },
                    { text: "The best time is usually now.", origin: "Modern wisdom" },
                    { text: "A calm mind sees farther.", origin: "Proverb (Japan)" },
                    { text: "Words are light ‚Äî actions count.", origin: "Proverb (Africa)" },
                    { text: "Small steps beat big intentions.", origin: "Proverb (Switzerland)" },
                    { text: "You can‚Äôt change the wind, only the sails.", origin: "Proverb (Northern Europe)" },
                    { text: "Those who ask don‚Äôt lose.", origin: "Proverb (DACH)" },
                    { text: "A good plan lives on adaptation.", origin: "Operations reality" },
                    { text: "A clear no protects a clean yes.", origin: "Modern wisdom" },
                    { text: "If you can explain it, you understand it.", origin: "Everyday wisdom" },
                    { text: "Order creates freedom.", origin: "Proverb (Central Europe)" },
                    { text: "The path is the goal ‚Äî but the course must be right.", origin: "Modern wisdom" },
                    { text: "Those who listen understand faster.", origin: "Proverb (Global)" },
                    { text: "A mistake is a clue, not a verdict.", origin: "Modern wisdom" },
                    { text: "Clarity comes from decisions.", origin: "Business reality" },
                    { text: "What you measure, you can steer.", origin: "Management wisdom" },
                    { text: "A calm start saves later chaos.", origin: "Proverb (Switzerland)" },
                    { text: "Not everything that counts is loud.", origin: "Modern wisdom" },
                    { text: "Care is speed in disguise.", origin: "Operations wisdom" }
                ],
                motivation: [
                    { text: "Today counts. Not someday.", origin: "Motivation (Global)" },
                    { text: "You don‚Äôt need a perfect start ‚Äî just the first step.", origin: "Motivation (Global)" },
                    { text: "Consistency beats intensity.", origin: "Motivation (Work)" },
                    { text: "Make it small enough that you won‚Äôt quit.", origin: "Motivation (Productivity)" },
                    { text: "If it‚Äôs uncomfortable, you grow.", origin: "Motivation (Global)" },
                    { text: "Progress is a system, not an accident.", origin: "Motivation (Business)" },
                    { text: "You‚Äôre closer than you think.", origin: "Motivation (Global)" },
                    { text: "Focus is a competitive advantage.", origin: "Motivation (Business)" },
                    { text: "A good day starts with a clear priority.", origin: "Motivation (Work)" },
                    { text: "You steer the course ‚Äî not the wind.", origin: "Motivation (Sailing)" },
                    { text: "Clean work today means less stress tomorrow.", origin: "Motivation (Operations)" },
                    { text: "You can be proud of your effort.", origin: "Motivation (Global)" },
                    { text: "One step more than yesterday is enough.", origin: "Motivation (Global)" },
                    { text: "Keep it simple ‚Äî but keep it reliable.", origin: "Motivation (Operations)" },
                    { text: "The start is hard; rhythm carries you.", origin: "Motivation (Global)" },
                    { text: "Discipline is self-respect in action.", origin: "Motivation (Global)" },
                    { text: "Choose the pace ‚Äî just keep moving.", origin: "Motivation (Global)" },
                    { text: "Quality isn‚Äôt an accident; it‚Äôs a standard.", origin: "Motivation (Business)" },
                    { text: "One decision a day changes a year.", origin: "Motivation (Global)" },
                    { text: "Stay with your process ‚Äî results follow.", origin: "Motivation (Business)" }
                ],
                compliment: [
                    { text: "You look like someone who truly finishes things.", origin: "Compliment (Global)" },
                    { text: "Your calm is noticeable ‚Äî and contagious.", origin: "Compliment (Global)" },
                    { text: "You think in structure. That‚Äôs rare.", origin: "Compliment (Business)" },
                    { text: "You‚Äôre reliable ‚Äî that‚Äôs gold.", origin: "Compliment (Work)" },
                    { text: "You have a good eye for detail.", origin: "Compliment (Global)" },
                    { text: "You bring clarity to complex topics.", origin: "Compliment (Business)" },
                    { text: "You keep your word. That builds trust.", origin: "Compliment (Global)" },
                    { text: "You make it easier for others ‚Äî without drama.", origin: "Compliment (Switzerland)" },
                    { text: "You set priorities like a pro.", origin: "Compliment (Operations)" },
                    { text: "You‚Äôre consistent. It shows.", origin: "Compliment (Global)" },
                    { text: "You‚Äôre not loud ‚Äî but you‚Äôre effective.", origin: "Compliment (Global)" },
                    { text: "You make quality visible.", origin: "Compliment (Work)" },
                    { text: "Your standards for clean work are obvious.", origin: "Compliment (Operations)" },
                    { text: "You keep going, even when it‚Äôs tough.", origin: "Compliment (Global)" },
                    { text: "You build trust through consistency.", origin: "Compliment (Business)" },
                    { text: "You have great timing for decisions.", origin: "Compliment (Work)" },
                    { text: "You bring order to chaos ‚Äî discreetly and efficiently.", origin: "Compliment (Business)" },
                    { text: "You‚Äôre solution-oriented, not excuse-oriented.", origin: "Compliment (Work)" },
                    { text: "You communicate clearly ‚Äî that saves everyone time.", origin: "Compliment (Business)" },
                    { text: "You have a strong presence without pushing.", origin: "Compliment (Global)" }
                ],
                fact: [
                    { text: "A day on Venus is longer than a Venus year.", origin: "Fact (Astronomy)" },
                    { text: "Octopuses have three hearts.", origin: "Fact (Biology)" },
                    { text: "Honey can last a very long time if stored well.", origin: "Fact (Food)" },
                    { text: "Switzerland has four national languages.", origin: "Fact (Switzerland)" },
                    { text: "Lightning can be hotter than the surface of the sun.", origin: "Fact (Physics)" },
                    { text: "Bees communicate, among other ways, through a waggle dance.", origin: "Fact (Biology)" },
                    { text: "Water expands when it freezes ‚Äî that‚Äôs why ice floats.", origin: "Fact (Physics)" },
                    { text: "Your brain uses about 20% of your energy at rest.", origin: "Fact (Biology)" },
                    { text: "Air is about 78% nitrogen.", origin: "Fact (Chemistry)" },
                    { text: "A day has 86,400 seconds.", origin: "Fact (Time)" },
                    { text: "The longest river in Europe is the Volga.", origin: "Fact (Geography)" },
                    { text: "The Eiffel Tower expands measurably in heat.", origin: "Fact (Materials)" },
                    { text: "Whales sleep by resting one brain hemisphere at a time.", origin: "Fact (Biology)" },
                    { text: "Bananas are botanically berries.", origin: "Fact (Botany)" },
                    { text: "The heart beats about 100,000 times per day.", origin: "Fact (Medicine)" },
                    { text: "A rainbow is an optical effect of refraction and reflection.", origin: "Fact (Physics)" },
                    { text: "Most volcanoes are along plate boundaries.", origin: "Fact (Geology)" },
                    { text: "The human body is about 60% water.", origin: "Fact (Biology)" },
                    { text: "Coffee contains over 800 aroma compounds.", origin: "Fact (Food)" },
                    { text: "Mount Everest grows a few millimeters each year.", origin: "Fact (Geology)" }
                ]
            },
            it: {
                wisdom: [
                    { text: "Chi va piano arriva comunque.", origin: "Proverbio (Europa)" },
                    { text: "La pazienza √® una forma di forza.", origin: "Proverbio (Asia)" },
                    { text: "Il momento migliore √® spesso adesso.", origin: "Saggezza moderna" },
                    { text: "Una mente calma vede pi√π lontano.", origin: "Proverbio (Giappone)" },
                    { text: "Le parole sono leggere ‚Äî contano i fatti.", origin: "Proverbio (Africa)" },
                    { text: "Piccoli passi battono grandi intenzioni.", origin: "Proverbio (Svizzera)" },
                    { text: "Non puoi cambiare il vento, ma le vele s√¨.", origin: "Proverbio (Nord Europa)" },
                    { text: "Chi chiede non perde.", origin: "Proverbio (DACH)" },
                    { text: "Un buon piano vive di adattamenti.", origin: "Realt√† operativa" },
                    { text: "Un no chiaro protegge un s√¨ pulito.", origin: "Saggezza moderna" },
                    { text: "Se lo sai spiegare, lo hai capito.", origin: "Saggezza quotidiana" },
                    { text: "L'ordine crea libert√†.", origin: "Proverbio (Europa centrale)" },
                    { text: "La strada √® il traguardo ‚Äî ma la rotta conta.", origin: "Saggezza moderna" },
                    { text: "Chi ascolta capisce pi√π in fretta.", origin: "Proverbio (Globale)" },
                    { text: "Un errore √® un indizio, non un verdetto.", origin: "Saggezza moderna" },
                    { text: "La chiarezza nasce dalle decisioni.", origin: "Realt√† business" },
                    { text: "Ci√≤ che misuri, lo puoi guidare.", origin: "Saggezza manageriale" },
                    { text: "Una partenza calma evita caos dopo.", origin: "Proverbio (Svizzera)" },
                    { text: "Non tutto ci√≤ che conta √® rumoroso.", origin: "Saggezza moderna" },
                    { text: "La cura √® velocit√† travestita.", origin: "Saggezza operativa" }
                ],
                motivation: [
                    { text: "Oggi conta. Non domani.", origin: "Motivazione (Globale)" },
                    { text: "Non serve un inizio perfetto ‚Äî basta il primo passo.", origin: "Motivazione (Globale)" },
                    { text: "La costanza batte l'intensit√†.", origin: "Motivazione (Lavoro)" },
                    { text: "Rendilo abbastanza piccolo da non mollare.", origin: "Motivazione (Produttivit√†)" },
                    { text: "Se √® scomodo, cresci.", origin: "Motivazione (Globale)" },
                    { text: "Il progresso √® un sistema, non un caso.", origin: "Motivazione (Business)" },
                    { text: "Sei pi√π vicino di quanto pensi.", origin: "Motivazione (Globale)" },
                    { text: "La concentrazione √® un vantaggio competitivo.", origin: "Motivazione (Business)" },
                    { text: "Una buona giornata inizia con una priorit√† chiara.", origin: "Motivazione (Lavoro)" },
                    { text: "Guida la rotta ‚Äî non il vento.", origin: "Motivazione (Nautica)" },
                    { text: "Lavorare bene oggi riduce lo stress domani.", origin: "Motivazione (Operazioni)" },
                    { text: "Puoi essere orgoglioso del tuo impegno.", origin: "Motivazione (Globale)" },
                    { text: "Un passo pi√π di ieri √® sufficiente.", origin: "Motivazione (Globale)" },
                    { text: "Semplice s√¨, ma affidabile.", origin: "Motivazione (Operazioni)" },
                    { text: "L'inizio √® duro, poi il ritmo ti porta.", origin: "Motivazione (Globale)" },
                    { text: "La disciplina √® rispetto per s√©.", origin: "Motivazione (Globale)" },
                    { text: "Scegli il ritmo ‚Äî l'importante √® andare avanti.", origin: "Motivazione (Globale)" },
                    { text: "La qualit√† non √® un caso, √® uno standard.", origin: "Motivazione (Business)" },
                    { text: "Una decisione al giorno cambia un anno.", origin: "Motivazione (Globale)" },
                    { text: "Resta nel processo ‚Äî i risultati arrivano.", origin: "Motivazione (Business)" }
                ],
                compliment: [
                    { text: "Sembri una persona che porta davvero a termine le cose.", origin: "Complimento (Globale)" },
                    { text: "La tua calma si sente ‚Äî ed √® contagiosa.", origin: "Complimento (Globale)" },
                    { text: "Pensi in modo strutturato. √à raro.", origin: "Complimento (Business)" },
                    { text: "Sei affidabile ‚Äî vale oro.", origin: "Complimento (Lavoro)" },
                    { text: "Hai un buon occhio per i dettagli.", origin: "Complimento (Globale)" },
                    { text: "Porti chiarezza nei temi complessi.", origin: "Complimento (Business)" },
                    { text: "Mantieni la parola. Questo crea fiducia.", origin: "Complimento (Globale)" },
                    { text: "Rendi tutto pi√π facile senza fare drama.", origin: "Complimento (Svizzera)" },
                    { text: "Imposti le priorit√† da professionista.", origin: "Complimento (Operazioni)" },
                    { text: "Sei coerente. Si vede.", origin: "Complimento (Globale)" },
                    { text: "Non sei rumoroso, ma efficace.", origin: "Complimento (Globale)" },
                    { text: "Rendi la qualit√† visibile.", origin: "Complimento (Lavoro)" },
                    { text: "Il tuo standard di pulizia si nota.", origin: "Complimento (Operazioni)" },
                    { text: "Vai avanti anche quando √® dura.", origin: "Complimento (Globale)" },
                    { text: "Crei fiducia con la costanza.", origin: "Complimento (Business)" },
                    { text: "Hai un ottimo tempismo nelle decisioni.", origin: "Complimento (Lavoro)" },
                    { text: "Porti ordine nel caos con discrezione.", origin: "Complimento (Business)" },
                    { text: "Sei orientato alle soluzioni, non alle scuse.", origin: "Complimento (Lavoro)" },
                    { text: "Comunichi chiaramente ‚Äî fai risparmiare tempo.", origin: "Complimento (Business)" },
                    { text: "Hai una presenza forte senza imporre.", origin: "Complimento (Globale)" }
                ],
                fact: [
                    { text: "Un giorno su Venere √® pi√π lungo di un anno venusiano.", origin: "Curiosit√† (Astronomia)" },
                    { text: "I polpi hanno tre cuori.", origin: "Curiosit√† (Biologia)" },
                    { text: "Il miele pu√≤ durare a lungo se conservato bene.", origin: "Curiosit√† (Alimentazione)" },
                    { text: "La Svizzera ha quattro lingue nazionali.", origin: "Curiosit√† (Svizzera)" },
                    { text: "Un fulmine pu√≤ essere pi√π caldo della superficie del sole.", origin: "Curiosit√† (Fisica)" },
                    { text: "Le api comunicano anche con la danza dell'addome.", origin: "Curiosit√† (Biologia)" },
                    { text: "L'acqua si espande congelando ‚Äî per questo il ghiaccio galleggia.", origin: "Curiosit√† (Fisica)" },
                    { text: "Il cervello usa circa il 20% dell'energia a riposo.", origin: "Curiosit√† (Biologia)" },
                    { text: "L'aria √® circa il 78% azoto.", origin: "Curiosit√† (Chimica)" },
                    { text: "Un giorno ha 86.400 secondi.", origin: "Curiosit√† (Tempo)" },
                    { text: "Il fiume pi√π lungo d'Europa √® il Volga.", origin: "Curiosit√† (Geografia)" },
                    { text: "La Torre Eiffel si dilata con il caldo.", origin: "Curiosit√† (Materiali)" },
                    { text: "Le balene dormono con met√† cervello alla volta.", origin: "Curiosit√† (Biologia)" },
                    { text: "Le banane sono bacche dal punto di vista botanico.", origin: "Curiosit√† (Botanica)" },
                    { text: "Il cuore batte circa 100.000 volte al giorno.", origin: "Curiosit√† (Medicina)" },
                    { text: "Un arcobaleno √® un effetto ottico di rifrazione e riflessione.", origin: "Curiosit√† (Fisica)" },
                    { text: "La maggior parte dei vulcani √® lungo i margini delle placche.", origin: "Curiosit√† (Geologia)" },
                    { text: "Il corpo umano √® circa il 60% acqua.", origin: "Curiosit√† (Biologia)" },
                    { text: "Il caff√® contiene oltre 800 aromi.", origin: "Curiosit√† (Alimentazione)" },
                    { text: "Il Monte Everest cresce di alcuni millimetri ogni anno.", origin: "Curiosit√† (Geologia)" }
                ]
            }
        };

        const hashStr = (s) => {
            // FNV-1a 32-bit
            let h = 0x811c9dc5;
            for (let i = 0; i < s.length; i++) {
                h ^= s.charCodeAt(i);
                h = Math.imul(h, 0x01000193);
            }
            return (h >>> 0);
        };

            const getDailyQuote = (dateStr, uid) => {
            const cats = [
                { key: "wisdom", label: t("quoteCategoryWisdom") },
                { key: "motivation", label: t("quoteCategoryMotivation") },
                { key: "compliment", label: t("quoteCategoryCompliment") },
                { key: "fact", label: t("quoteCategoryFact") }
            ];
            const [y, m, d] = String(dateStr || "").split("-").map(x => parseInt(x, 10));
            const dayIndex = Math.floor(new Date(y, (m || 1) - 1, d || 1).getTime() / 86400000);
            const cat = cats[((dayIndex % cats.length) + cats.length) % cats.length];
            const list = QUOTE_BANK[cat.key] || [];
            const pick = list.length ? (hashStr(`${dateStr}|${uid}|${cat.key}`) % list.length) : 0;
            const item = list[pick] || { text: t('quoteFallbackText'), origin: t('quoteFallbackOrigin') };
            return { category: cat.label, categoryKey: cat.key, ...item };
        };

        const getLocalizedQuote = (dateStr, uid) => {
            const quote = getDailyQuote(dateStr, uid);
            const langQuotes = QUOTE_TRANSLATIONS[CURRENT_LANG];
            if (!langQuotes) return quote;
            const list = langQuotes[quote.categoryKey] || [];
            if (!list.length) return quote;
            const pick = list[hashStr(`${dateStr}|${uid}|${quote.categoryKey}`) % list.length];
            return { ...quote, ...pick };
        };



        // FIX: fehlende Funktion (war Hauptursache f√ºr "Black Screen" nach Login)
        const parseYMD = (s) => {
            const parts = String(s || '').split('-').map(n => parseInt(n, 10));
            if (parts.length !== 3 || parts.some(n => Number.isNaN(n))) return null;
            const [y, m, d] = parts;
            return { y, m, d, date: new Date(y, m - 1, d) };
        };

        const matchesRecurrence = (ev, targetDateStr) => {
            if (!ev || !ev.date) return false;
            const rep = (ev.repeat || 'none');
            if (rep === 'none') return ev.date === targetDateStr;

            const start = parseYMD(ev.date);
            const target = parseYMD(targetDateStr);
            if (!start || !target) return false;

            // Only apply recurrence on/after the start date
            if (target.date.getTime() < start.date.getTime()) return false;

            if (rep === 'daily') return true;

            if (rep === 'weekly') {
                return target.date.getDay() === start.date.getDay();
            }

            if (rep === 'monthly') {
                return target.d === start.d;
            }

            if (rep === 'yearly') {
                return target.m === start.m && target.d === start.d;
            }

            return ev.date === targetDateStr;
        };

        const getEventsForDate = (dateStr, eventsArr) => {
            if (!Array.isArray(eventsArr)) return [];
            return eventsArr
                .filter(ev => ev && (ev.date === dateStr || matchesRecurrence(ev, dateStr)))
                .sort((a, b) => (a.time || '').localeCompare(b.time || ''));
        };

        const getDayCategories = (dateStr, eventsArr) => {
            const dayEvents = getEventsForDate(dateStr, eventsArr);
            return Array.from(new Set(dayEvents.map(ev => ev?.category).filter(Boolean)));
        };

        const getTaskTimeStatus = (taskId, taskTimeEntries) => {
            const entries = (taskTimeEntries && taskTimeEntries[taskId]) ? taskTimeEntries[taskId] : [];
            const totalSeconds = entries.reduce((sum, entry) => sum + (entry.duration || 0), 0);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            return {
                entries,
                label: hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`
            };
        };

        const formatCountdownLabel = (targetDateStr, targetTimeStr) => {
            if (!targetDateStr) return '';
            const [year, month, day] = String(targetDateStr).split('-').map(Number);
            if (!year || !month || !day) return '';
            const [hourRaw, minuteRaw] = String(targetTimeStr || '00:00').split(':');
            const hour = Number(hourRaw);
            const minute = Number(minuteRaw);
            const target = new Date(year, month - 1, day, Number.isNaN(hour) ? 0 : hour, Number.isNaN(minute) ? 0 : minute, 0, 0);
            const diffMs = target.getTime() - Date.now();
            if (!Number.isFinite(diffMs)) return '';
            if (diffMs <= 0) return t('countdownNow');
            const diffMinutes = Math.floor(diffMs / 60000);
            const totalHours = Math.floor(diffMinutes / 60);
            const days = Math.floor(totalHours / 24);
            const hours = totalHours % 24;
            const minutes = diffMinutes % 60;
            if (days > 0) {
                return `${t('countdownPrefix')} ${days} ${t('daysLabel')} ${hours}h`;
            }
            if (hours > 0) {
                return `${t('countdownPrefix')} ${hours}h ${minutes}m`;
            }
            return `${t('countdownPrefix')} ${minutes}m`;
        };

        const toSafeClassName = (value) => {
            const cleaned = String(value || '').toLowerCase().replace(/[^a-z0-9_-]/g, '').trim();
            return cleaned || 'misc';
        };

        const getCalendarCellClasses = ({ isToday, isTomorrow, isOvermorrow, dayCategories, baseClass }) => {
            return [
                baseClass,
                isToday ? 'ring-2 ring-blue-500' : '',
                isTomorrow ? 'tomorrow' : '',
                isOvermorrow ? 'overmorrow' : '',
                ...(dayCategories || []).map(cat => `cat-${toSafeClassName(cat)}`)
            ].filter(Boolean).join(' ');
        };

        // --- CALENDAR & ICS HELPERS ---
        
        // Generate unique calendar ID
        const generateCalendarId = () => `cal_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
        
        // Generate secure token for public/subscription links
        const generateSecureToken = () => {
            const array = new Uint8Array(24);
            window.crypto.getRandomValues(array);
            return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
        };
        
        // Format date/time for ICS format (YYYYMMDDTHHMMSSZ)
        const formatICSDateTime = (dateStr, timeStr = '00:00') => {
            const [year, month, day] = dateStr.split('-');
            const [hour, minute] = timeStr.split(':');
            return `${year}${month}${day}T${hour.padStart(2,'0')}${minute.padStart(2,'0')}00`;
        };
        
        // Escape text for ICS format
        const escapeICSText = (text) => {
            if (!text) return '';
            return text.replace(/\\/g, '\\\\')
                      .replace(/;/g, '\\;')
                      .replace(/,/g, '\\,')
                      .replace(/\n/g, '\\n');
        };
        
        // Generate ICS file content from events
        const generateICS = (events, calendarName = 'TimeRoster Calendar') => {
            const lines = [
                'BEGIN:VCALENDAR',
                'VERSION:2.0',
                'PRODID:-//TimeRoster//Calendar Export//EN',
                `X-WR-CALNAME:${escapeICSText(calendarName)}`,
                'X-WR-TIMEZONE:Europe/Berlin',
                'CALSCALE:GREGORIAN',
                'METHOD:PUBLISH'
            ];
            
            events.forEach(event => {
                const uid = `${event.id}@timeroster.app`;
                const dtstart = formatICSDateTime(event.date, event.time || '00:00');
                
                // Calculate end time (1 hour after start), handling day boundary
                const [hour, minute] = (event.time || '00:00').split(':');
                const hourInt = parseInt(hour);
                const endHour = hourInt >= 23 ? '00' : String(hourInt + 1).padStart(2, '0');
                const dtend = formatICSDateTime(event.date, `${endHour}:${minute}`);
                
                const now = new Date();
                const dtstamp = formatICSDateTime(now.toISOString().split('T')[0], now.toTimeString().substring(0, 5));
                
                lines.push('BEGIN:VEVENT');
                lines.push(`UID:${uid}`);
                lines.push(`DTSTAMP:${dtstamp}`);
                lines.push(`DTSTART:${dtstart}`);
                lines.push(`DTEND:${dtend}`);
                lines.push(`SUMMARY:${escapeICSText(event.title)}`);
                
                if (event.location) {
                    lines.push(`LOCATION:${escapeICSText(event.location)}`);
                }
                
                if (event.category) {
                    lines.push(`CATEGORIES:${escapeICSText(event.category)}`);
                }
                
                // Handle recurring events
                if (event.repeat && event.repeat !== 'none') {
                    const freqMap = {
                        'daily': 'DAILY',
                        'weekly': 'WEEKLY',
                        'monthly': 'MONTHLY',
                        'yearly': 'YEARLY'
                    };
                    if (freqMap[event.repeat]) {
                        lines.push(`RRULE:FREQ=${freqMap[event.repeat]}`);
                    }
                }
                
                lines.push('END:VEVENT');
            });
            
            lines.push('END:VCALENDAR');
            return lines.join('\r\n');
        };
        
        // Download ICS file
        const downloadICS = (icsContent, filename = 'calendar.ics') => {
            const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };

        // --- TRANSLATIONS ---
        const BASE_TRANSLATIONS = {
            dashboard: "√úbersicht", calendar: "Kalender", friends: "Freunde", settings: "Einstellungen",
            newEvent: "Ereignis", title: "Info", category: "Kategorie", save: "Speichern", cancel: "Abbrechen",
            delete: "L√∂schen", edit: "Bearbeiten", details: "Details",
            remove: "Entfernen",
            messenger: "MSN Messenger", contacts: "Kontakte", online: "Online", offline: "Offline",
            addContact: "Kontakt hinzuf√ºgen", requests: "Anfragen", accept: "Annehmen", myCode: "Mein Code",
            typeHere: "Nachricht eingeben...", send: "Senden", photo: "Foto",
            signIn: "Login", register: "Reg.", email: "E-Mail", password: "Passwort", guest: "Gastzugang", or: "oder",
            pendingRequests: "Offene Anfragen", myFriends: "Meine Freunde", backToMe: "Zur√ºck zu mir", viewing: "Ansichtsmodus",
            friend: "Freund", friends: "Freunde", member: "Mitglied", members: "Mitglieder", selected: "ausgew√§hlt",
            addFriend: "Freund per Code adden", shareCode: "Dein Freundes-Code",
            shareCodePlaceholder: "rai123456",
            emailPlaceholder: "Email",
            passwordPlaceholder: "Passwort",
            nameExample: "z.B. Leo",
            aiDesignPlaceholder: "Beispiel: dunkel, akzent #ff8c00, text #f8fafc, schrift elegant, gr√∂√üe 105%",
            citySearchPlaceholder: "z. B. Z√ºrich, Basel, Milano ‚Ä¶",
            templateNamePlaceholder: "Vorlagen-Name (z.B. 'T√§gliches Standup')",
            work: "Arbeit", personal: "Privat", health: "Gesundheit", household: "Haushalt", leisure: "Freizeit", focus: "Fokus-Block", holiday: "Feiertag",
            editEvent: "Ereignis bearbeiten", eventDetails: "Details",
            dayOptions: "Optionen", assignShift: "Schicht zuweisen", createEvent: "Ereignis (+)", clearShift: "Schicht l√∂schen",
            paintMode: "Pinsel", font: "Schriftart", fontSize: "Gr√∂√üe", manageShifts: "Schichten verwalten",
            appearance: "Design", selectShift: "Schicht w√§hlen", save: "Speichern", newShift: "Neue Schicht",
            start: "Start", end: "Ende", color: "Farbe", shiftName: "Name",
            fontModern: "Modern", fontAntique: "Antik", fontElegant: "Elegant", fontReadable: "Lesbar", fontStrong: "Stark",
            repeat: "Wiederholung", repeatNone: "Nie", repeatDaily: "T√§glich", repeatWeekly: "W√∂chentlich", repeatMonthly: "Monatlich", repeatYearly: "J√§hrlich",
            offDuty: "Frei",
            light: "Hell",
            dark: "Dunkel",
            vibrant: "Intensiv",
            custom: "Individuell",
            customizeTheme: "Farben anpassen",
            aiDesign: "KI Design",
            aiDesignHint: "Schreibe Farben und Schrift ‚Äî wir setzen die Vorschau.",
            aiDesignApply: "Design anwenden",
            upcoming: "Anstehend",
            countdownLabel: "Countdown",
            countdownPrefix: "in",
            countdownNow: "l√§uft",
            daysLabel: "Tage",
            birthday: "Geburtstag",
            rangeDay: "Tag",
            rangeWeek: "Woche",
            rangeMonth: "Monat",
            rangeYear: "Jahr",
            noUpcoming: "Keine Ereignisse im gew√§hlten Zeitraum.",
            viewDay: "Tag",
            viewWeek: "Woche",
            viewMonth: "Monat",
            location: "Ort",
            search: "Suchen",
            searchPlaceholder: "Ereignis suchen...",
            searchResults: "Suchergebnisse",
            noResults: "Keine Ereignisse gefunden.",
            clearSearch: "Zur√ºck",
            pleaseEnterName: "Bitte einen Namen eingeben.",
            noEventsToExport: "Keine Events zum Exportieren.",
            sharingRequiresEmailLookup: "Sharing-Funktion erfordert E-Mail-Suche. Verwenden Sie einen √∂ffentlichen Link.",
            calendarNotFound: "Kalender nicht gefunden.",
            onlyOwnerCanChangeSettings: "Nur der Eigent√ºmer kann diese Einstellung √§ndern.",
            manageCalendars: "Kalender verwalten",
            manageFriends: "Freunde verwalten",
            calendarMembers: "Kalender-Mitglieder",
            addMembers: "Mitglieder hinzuf√ºgen",
            selectCalendar: "Kalender ausw√§hlen",
            selectCalendarPlaceholder: "Kalender ausw√§hlen...",
            calendarNoMembers: "Noch keine weiteren Mitglieder.",
            selectMembersPrompt: "Bitte zuerst Mitglieder ausw√§hlen.",
            calendarOnlyOwner: "Nur du bist aktuell im Kalender.",
            onlyOwnerCanManageMembers: "Nur der Eigent√ºmer kann Mitglieder verwalten.",
            friendCount: "Freund",
            friendsCount: "Freunde",
            shareCalendar: "Kalender teilen",
            myCalendars: "Meine Kalender",
            allCalendars: "Alle Kalender",
            shareWithFriends: "Mit Freunden teilen",
            selectFriends: "Freunde ausw√§hlen",
            noFriends: "Keine Freunde verf√ºgbar",
            onlyOwnerCanShare: "Nur der Eigent√ºmer kann den Kalender teilen.",
            selectCalendarForEvent: "Bitte w√§hle zuerst einen Kalender aus.",
            selectCalendarForShift: "Bitte w√§hle zuerst einen Kalender f√ºr Schichten aus.",
            monthEvents: "Ereignisse im Monat",
            noMonthEvents: "Keine Ereignisse im aktuellen Monat.",
            eventsListLabel: "Ereignisse",
            noEventsInRange: "Keine Ereignisse im Zeitraum.",
            calendarOwner: "Eigent√ºmer",
            calendarMember: "Mitglied",
            holidaySettings: "Feiertage",
            holidaySettingsHint: "Feiertage als Internet-Sync (weltweit, inkl. Kantone)",
            holidayCountrySearch: "Land suchen...",
            holidayCountryLabel: "Land",
            holidayRegionLabel: "Region / Kanton",
            holidayRegionHint: "Nur n√∂tig f√ºr kantonale Feiertage (z. B. Schweiz)",
            holidayCalendarLabel: "Kalender f√ºr Feiertage",
            holidayCalendarHint: "Feiertage werden als eigene Events importiert",
            holidaySyncButton: "Feiertage synchronisieren",
            holidaySyncing: "Synchronisiere Feiertage‚Ä¶",
            holidayLastSync: "Letzte Synchronisation",
            holidayNoSync: "Noch nicht synchronisiert",
            holidayCountriesError: "L√§nderliste konnte nicht geladen werden. Fallback wird verwendet.",
            holidaySyncSuccess: "Feiertage wurden synchronisiert.",
            holidaySyncError: "Feiertage konnten nicht geladen werden.",
            holidayNoHolidaysFound: "Keine Feiertage gefunden.",
            holidaySelectCountryFirst: "Bitte zuerst ein Land ausw√§hlen.",
            tasks: "Aufgaben",
            addTask: "Aufgabe hinzuf√ºgen",
            taskTitle: "Aufgabentitel",
            dueDate: "F√§lligkeitsdatum",
            responsible: "Verantwortlich",
            status: "Status",
            priority: "Priorit√§t",
            checklist: "Checkliste",
            addSubtask: "Unterpunkt hinzuf√ºgen",
            subtask: "Unterpunkt",
            statusOpen: "Offen",
            statusInProgress: "In Arbeit",
            statusCompleted: "Erledigt",
            priorityHigh: "Wichtig",
            priorityNormal: "Normal",
            priorityLow: "Niedrig",
            taskReminder: "Aufgaben-Erinnerung",
            noTasks: "Keine Aufgaben",
            deleteTask: "Aufgabe l√∂schen",
            unassigned: "Nicht zugewiesen",
            name: "Name",
            invitees: "Teilnehmer",
            inviteParticipants: "Teilnehmer einladen (nur Freunde)",
            organizer: "Organisator",
            going: "Zusage",
            maybe: "Vielleicht",
            declined: "Absage",
            noResponse: "Keine Antwort",
            requestDropdown: "Event-Anfragen",
            acceptSelected: "Auswahl annehmen",
            declineSelected: "Auswahl ablehnen",
            appLanguage: "Kalender-Sprache",
            appLanguageHint: "Diese Sprache gilt f√ºr den gesamten Kalender.",
            customizeWizardTitle: "Individuelles Design",
            wizardNext: "Weiter",
            wizardBack: "Zur√ºck",
            wizardFinish: "Fertig",
            wizardBg: "Hintergrundfarbe",
            wizardAccent: "Akzentfarbe",
            wizardText: "Textfarbe",
            hourLabel: "Stunde",
            hoursLabel: "Stunden",
            dayLabel: "Tag",
            previewLabel: "Vorschau",
            accentLabel: "Akzent",
            loadMoreMessages: "Weitere Nachrichten laden",
            proposeEventForFriend: "Event vorschlagen",
            profile: "Profil",
            add: "Hinzuf√ºgen",
            profileImage: "Profilbild",
            photoCapture: "Foto aufnehmen",
            openCameraApp: "Kamera-App √∂ffnen",
            deleteImageTitle: "Bild l√∂schen?",
            deleteImageHint: "Dieses Foto wurde als 1x Ansicht markiert.",
            saving: "Speichern...",
            myProfile: "Mein Profil",
            meLabel: "Ich",
            displayName: "Anzeige-Name",
            statusText: "Status (Text)",
            statusTextPlaceholder: "z. B. Besch√§ftigt, Pause, unterwegs...",
            bio: "Bio",
            bioPlaceholder: "Erz√§hl etwas √ºber dich...",
            changeAvatar: "Profilbild √§ndern",
            defaultLabel: "Standard",
            designSettings: "Design-Einstellungen",
            amoledToggle: "AMOLED Dunkelmodus aktivieren",
            amoledHint: "Tiefes Schwarz f√ºr OLED-Displays",
            back: "Zur√ºck",
            sortAlpha: "A-Z",
            lastActive: "Zuletzt aktiv",
            groups: "Gruppen",
            newLabel: "Neu",
            createGroup: "Gruppe erstellen",
            groupName: "Gruppenname",
            groupNamePlaceholder: "Meine Gruppe...",
            groupMembers: "Mitglieder ausw√§hlen (mind. 2)",
            create: "Erstellen",
            addFriendTitle: "Freund hinzuf√ºgen",
            friendProfileTitle: "Freund-Profil",
            securitySettings: "Sicherheitseinstellungen",
            deleteAfterRead: "Nach Lesen l√∂schen",
            expiry: "Ablauf",
            expiry24h: "24h Ablauf",
            expiry7d: "7 Tage Ablauf",
            expiryNever: "Kein Ablauf",
            settingsApplyTo: "Diese Einstellungen gelten nur f√ºr",
            sendMessage: "Nachricht senden",
            sentAtLabel: "Gesendet",
            replyToLabel: "Antwort auf:",
            editedLabel: "(bearbeitet)",
            deletedMessage: "[Nachricht gel√∂scht]",
            replyAction: "Antworten",
            editingMessage: "Bearbeite Nachricht...",
            encryptedLabel: "Verschl√ºsselt",
            readOnceLabel: "Einmalig lesbar",
            expiresAtLabel: "L√§uft ab:",
            attachPhoto: "Foto anh√§ngen",
            openSettingsTitle: "Einstellungen √∂ffnen",
            calendarSettingsTitle: "Kalender-Einstellungen",
            exportIcsTitle: "Als ICS exportieren",
            writeMessagePlaceholder: "Schreibe eine Nachricht...",
            zoomProfileImage: "Profilbild vergr√∂ssern",
            showProfile: "Profil anzeigen",
            clickToZoom: "Klicken zum Vergr√∂ssern",
            groupLabel: "Gruppe",
            tapToDeleteImage: "Tippe erneut, um das Bild zu l√∂schen.",
            calendarOf: "Kalender von",
            shiftsLabel: "Schichten",
            dropHere: "Hier ablegen",
            displayNameHint: "Dein Name (sichtbar f√ºr Freunde)",
            friendCodeLabel: "Freundes-Code",
            saveName: "Name speichern",
            timePlanning: "‚è±Ô∏è Zeitplanung",
            durationShort: "Dauer (min)",
            travelShort: "Reise (min)",
            bufferShort: "Puffer (min)",
            durationLabel: "Dauer",
            travelTimeLabel: "Reisezeit",
            bufferTimeLabel: "Pufferzeit",
            minutesLabel: "Minuten",
            baseDateLabel: "Basisdatum",
            seriesLabel: "Serie",
            atTime: "um",
            smartReminder: "üîî Intelligente Erinnerung",
            smartReminders: "üîî Intelligente Erinnerungen",
            enableSmartReminder: "Intelligente Erinnerung aktivieren",
            reminderType: "Erinnerungs-Typ",
            fixedReminderOption: "‚è∞ Feste Zeit vor Termin",
            workHoursReminderOption: "üíº Basierend auf Arbeitszeiten",
            locationReminderOption: "üìç Basierend auf Standort",
            patternReminderOption: "üîÑ Basierend auf Routine",
            minutesBefore: "Minuten vorher",
            workHoursReminderHint: "Erinnerung wird w√§hrend deiner √ºblichen Arbeitszeiten gesendet",
            locationReminderHint: "Erinnerung basierend auf Reisezeit zum Veranstaltungsort",
            patternReminderHint: "Erinnerung basierend auf deinen wiederkehrenden Routinen",
            eventTemplates: "üìã Event-Vorlagen",
            hide: "Verbergen",
            saveAsTemplate: "Als Vorlage speichern",
            loadTemplate: "Vorlage laden",
            noDescription: "Keine Beschreibung",
            templateNamePlaceholder: "Vorlagen-Name (z.B. 'T√§gliches Standup')",
            saveTemplate: "Vorlage speichern",
            templateSaveHint: "Die aktuelle Konfiguration wird als wiederverwendbare Vorlage gespeichert",
            templateNameRequired: "Bitte geben Sie einen Namen f√ºr die Vorlage ein",
            templateSaveSuccess: "Vorlage erfolgreich gespeichert!",
            templateSaveError: "Fehler beim Speichern der Vorlage",
            templateDeleteConfirm: "Vorlage wirklich l√∂schen?",
            templateDeleteError: "Fehler beim L√∂schen der Vorlage",
            availabilityOverview: "üìÖ Verf√ºgbarkeits-√úbersicht",
            selectContacts: "Kontakte ausw√§hlen",
            noFriendsAvailability: "Keine Freunde verf√ºgbar. F√ºge Freunde hinzu, um deren Verf√ºgbarkeit zu sehen.",
            timeLabel: "Zeit",
            busyLabel: "üî¥ Belegt",
            freeLabel: "üü¢ Frei",
            selectContactsHint: "W√§hle Kontakte aus, um deren Verf√ºgbarkeit zu sehen",
            createModeLabel: "Erstellen",
            createForMe: "Nur f√ºr mich",
            requestTo: "Als Anfrage an",
            requestConfirmationNote: "(im Freund-Kalender nach Best√§tigung)",
            createForMeAndRequest: "F√ºr mich + Anfrage an",
            durationMinutes: "Dauer (Minuten)",
            travelTimeBefore: "üöó Reisezeit vorher (Minuten)",
            travelTimeHint: "Automatische Wegezeit zum vorherigen Termin",
            bufferTimeAfter: "‚è∏Ô∏è Pufferzeit danach (Minuten)",
            bufferTimeHint: "Zeit zwischen diesem und dem n√§chsten Termin",
            weatherLocationTitle: "Wetter-Ort ausw√§hlen",
            autoLocation: "Standort automatisch",
            manualLocation: "Manuell",
            autoLocationTitle: "Automatischer Standort",
            autoLocationHint: "Nutzt GPS/Browser-Standort. Falls blockiert: Fallback Z√ºrich.",
            manualLocationTitle: "Manueller Ort",
            manualLocationHint: "Suche nach Stadt/Region und w√§hle einen Treffer.",
            searchButton: "Suche",
            searchErrorOffline: "Offline ‚Äì Suche nicht verf√ºgbar.",
            searchNoResults: "Keine Treffer gefunden.",
            searchErrorUnavailable: "Suche aktuell nicht verf√ºgbar.",
            currentSaved: "Aktuell gespeichert",
            searchTip: "Tipp: F√ºr konsistente Ergebnisse (ohne Standortfreigabe) Manuell verwenden.",
            weatherForecastTitle: "7-Tage-Wettervorhersage",
            maxTemp: "Max",
            minTemp: "Min",
            windLabel: "Wind",
            dataSource: "Datenquelle: Open-Meteo API",
            weatherLoading: "Wetter wird geladen‚Ä¶",
            locationLabel: "Standort",
            openMeteoLabel: "Open-Meteo",
            selectLocationButton: "Ort",
            refreshWeatherButton: "Aktualisieren",
            selectLocationTitle: "Ort ausw√§hlen",
            refreshWeatherTitle: "Wetter aktualisieren",
            forecastTitle: "Klicken f√ºr 7-Tage-Vorhersage",
            weatherErrorOffline: "Offline ‚Äì Wetter nicht verf√ºgbar.",
            weatherErrorUnavailable: "Wetter aktuell nicht verf√ºgbar.",
            forecastErrorUnavailable: "Vorhersage aktuell nicht verf√ºgbar.",
            manualLabel: "Manuell",
            autoLabel: "Dein Standort",
            weatherFallbackLabel: "Z√ºrich (Fallback)",
            weatherLabel: "Wetter",
            premiumUnlockTitle: "üîí Premium Freischalten",
            premiumAccessHint: "Der Zugriff auf Premium.",
            premiumFeaturesTitle: "‚ú® Premium Features:",
            premiumCodeLabel: "Code-Wort eingeben:",
            premiumCodePlaceholder: "Code-Wort hier eingeben",
            premiumCodeError: "Falscher Code. Bitte versuche es erneut.",
            unlock: "Freischalten",
            premiumCodeHint: "Hinweis: Der Code wird nur einmal ben√∂tigt.",
            newCalendarLabel: "Neuer Kalender",
            calendarNamePlaceholder: "Kalendername",
            calendarDescriptionPlaceholder: "Beschreibung (optional)",
            calendarCreateButton: "Kalender erstellen",
            publicSharing: "√ñffentlich teilen",
            publicSharingHint: "Jeder mit dem Link kann den Kalender ansehen",
            toggleOn: "EIN",
            toggleOff: "AUS",
            publicLinkLabel: "√ñffentlicher Link",
            copyLinkTitle: "Link kopieren",
            readOnlyAccess: "Schreibgesch√ºtzter Zugriff f√ºr alle",
            subscriptionLinkLabel: "Abonnement-Link (ICS)",
            subscriptionLinkHint: "F√ºr Google Calendar, Apple Calendar, Outlook",
            subscriptionLinkInfo: "Der Abonnement-Link erm√∂glicht automatische Synchronisation in anderen Kalender-Apps.",
            errorProfileLoad: "Profil konnte nicht geladen werden.",
            errorProfileSave: "Profil konnte nicht gespeichert werden.",
            errorImageProcess: "Bild konnte nicht verarbeitet werden.",
            errorCameraAccess: "Fehler beim Zugriff auf die Kamera. Bitte stelle sicher, dass du die Kameraberechtigung erteilt hast.",
            errorCameraNotReady: "Kamera nicht bereit. Bitte versuche es erneut.",
            errorCameraLoading: "Video wird geladen. Bitte warte einen Moment.",
            errorPhotoCreate: "Fehler beim Erstellen des Fotos. Bitte versuche es erneut.",
            errorPhotoProcess: "Fehler beim Verarbeiten des Fotos.",
            errorGroupCreate: "Bitte gib einen Gruppennamen ein und w√§hle mindestens 2 Mitglieder aus.",
            groupCreated: "Gruppe erstellt!",
            requestSent: "Anfrage gesendet!",
            errorAddFriend: "Fehler beim Hinzuf√ºgen.",
            codeNotFound: "Code nicht gefunden",
            selfRequest: "Das bist du!",
            nameSaved: "Name gespeichert.",
            nameSaveError: "Fehler beim Speichern des Namens.",
            eventRequestSent: "Event-Anfrage an",
            requestSentSuffix: "gesendet!",
            eventSaveError: "Fehler beim Speichern des Events.",
            eventUpdateError: "Fehler beim Aktualisieren des Events.",
            eventDeleteError: "Fehler beim L√∂schen des Events.",
            shiftDeleteError: "L√∂schen fehlgeschlagen.",
            shiftDeleteLocked: "Die Schicht 'Frei' kann nicht gel√∂scht werden.",
            calendarCreateError: "Fehler beim Erstellen des Kalenders.",
            calendarUpdateError: "Fehler beim Aktualisieren des Kalenders.",
            calendarShareError: "Fehler beim Teilen des Kalenders.",
            calendarVisibilityError: "Fehler beim √Ñndern der Sichtbarkeit.",
            calendarManageNotAllowed: "Du hast keine Berechtigung f√ºr diese Aktion.",
            calendarOwnerCannotRemoveSelf: "Der Eigent√ºmer kann sich nicht selbst entfernen.",
            calendarMemberRemoveFailed: "Mitglied konnte nicht entfernt werden.",
            calendarShareSomeFailed: "Einige Freigaben konnten nicht gespeichert werden.",
            eventsLoadError: "Fehler beim Laden der Events.",
            eventsLoadErrorDetails: "Fehler beim Laden der Events. Datenbank pr√ºfen.",
            criticalError: "Kritischer Fehler:",
            guestAccessDisabled: "Gast-Zugang in Firebase Console aktivieren!",
            userFallback: "User",
            friendFallback: "Freund",
            contactFallback: "Kontakt",
            unknown: "Unbekannt",
            calendarDefaultName: "Mein Kalender",
            calendarDefaultDescription: "Standard Kalender",
            calendarDefaultTitle: "TimeRoster Kalender",
            notificationNewMessage: "Neue Nachricht",
            notificationFriendRequest: "Neue Freundschaftsanfrage",
            notificationFriendRequestBody: "m√∂chte dich als Freund hinzuf√ºgen",
            notificationEventInvite: "Neue Termineinladung",
            notificationEventInviteBody: "hat dich zu einem Termin eingeladen",
            notificationEventReminder: "Terminerinnerung",
            notificationEventReminderBody: "beginnt in K√ºrze",
            notificationSettings: "Benachrichtigungen",
            notificationEnableBtn: "Benachrichtigungen aktivieren",
            notificationEnabled: "Benachrichtigungen aktiv",
            notificationDisabled: "Benachrichtigungen deaktiviert",
            notificationPermissionDenied: "Benachrichtigungs-Berechtigung wurde verweigert",
            notificationNotSupported: "Benachrichtigungen werden nicht unterst√ºtzt",
            notificationChatMessages: "Chat-Nachrichten",
            notificationCalendarEvents: "Kalender-Events",
            notificationFriendRequests: "Freundschaftsanfragen",
            pwaInstall: "App installieren",
            pwaInstallHint: "TimeRoster als App auf deinem Ger√§t installieren",
            pwaInstalled: "App installiert ‚úì",
            pwaInstallIosHint: "Tippe auf 'Teilen' ‚Üí 'Zum Home-Bildschirm'",
            logout: "Logout",
            weatherClear: "Klar",
            weatherPartlyCloudy: "Leicht bew√∂lkt",
            weatherOvercast: "Bedeckt",
            weatherFog: "Nebel",
            weatherDrizzle: "Niesel",
            weatherRain: "Regen",
            weatherSnow: "Schnee",
            weatherShowers: "Schauer",
            weatherStorm: "Gewitter",
            quoteCategoryWisdom: "Weisheit",
            quoteCategoryMotivation: "Motivation",
            quoteCategoryCompliment: "Kompliment",
            quoteCategoryFact: "Wissenswertes",
            quoteFallbackText: "Heute ist ein guter Tag f√ºr einen guten Schritt.",
            quoteFallbackOrigin: "Global",
            fileTooLarge: `Datei zu gross. Bitte unter ${MAX_IMAGE_SIZE_LABEL} bleiben.`,
            messageSendError: "Nachricht konnte nicht gesendet werden. Bitte versuche es erneut.",
            encryptionPreparing: "Verschl√ºsselung wird vorbereitet. Bitte kurz warten.",
            maxFileSizeLabel: "Max. Dateigr√∂sse:",
            // Task Management
            taskCompleted: "Erledigt",
            taskPending: "Ausstehend",
            markComplete: "Als erledigt markieren",
            markIncomplete: "Als ausstehend markieren",
            editTask: "Aufgabe bearbeiten",
            taskDescription: "Beschreibung",
            taskDescriptionPlaceholder: "Beschreibung der Aufgabe...",
            taskCreated: "Aufgabe erstellt!",
            taskUpdated: "Aufgabe aktualisiert!",
            taskDeleted: "Aufgabe gel√∂scht!",
            taskError: "Fehler bei Aufgaben-Operation",
            taskManager: "Aufgaben",
            overdueTasks: "√úberf√§llige Aufgaben",
            todayTasks: "Heute f√§llig",
            upcomingTasks: "Demn√§chst f√§llig",
            noDueDateTasks: "Ohne F√§lligkeitsdatum",
            completedTasks: "Erledigte Aufgaben",
            allTasks: "Alle Aufgaben",
            // Time Tracking
            timeTracking: "Zeiterfassung",
            startTimer: "Timer starten",
            stopTimer: "Timer stoppen",
            timerRunning: "Timer l√§uft",
            timeTracked: "Erfasste Zeit",
            totalTime: "Gesamtzeit",
            timeEntries: "Zeiteintr√§ge",
            noTimeEntries: "Keine Zeiteintr√§ge",
            dailyTotal: "Tagessumme",
            weeklyTotal: "Wochensumme",
            monthlyTotal: "Monatssumme",
            // Templates
            templates: "Vorlagen",
            eventTemplate: "Event-Vorlage",
            useTemplate: "Vorlage verwenden",
            deleteTemplate: "Vorlage l√∂schen",
            noTemplates: "Keine Vorlagen vorhanden",
            templateCreated: "Vorlage erstellt!",
            templateDeleted: "Vorlage gel√∂scht!",
            enterTemplateName: "Vorlagenname eingeben...",
            pleaseEnterTemplateName: "Bitte einen Namen f√ºr die Vorlage eingeben",
            templateSaveError: "Fehler beim Speichern der Vorlage",
            pleaseEnterTitle: "Bitte Titel eingeben",
            // Statistics
            statistics: "Statistiken",
            timeDistribution: "Zeitverteilung",
            categoryStats: "Nach Kategorie",
            dailyStats: "Tagesstatistik",
            weeklyStats: "Wochenstatistik",
            monthlyStats: "Monatsstatistik",
            focusBlocks: "Fokus-Zeiten",
            longestBlock: "L√§ngster Block",
            totalEvents: "Gesamt-Termine",
            eventsLabel: "Termine",
            avgDuration: "√ò Dauer",
            productivity: "Produktivit√§t",
            noStatsData: "Keine Daten f√ºr Statistiken vorhanden",
            hoursTracked: "Stunden erfasst",
            eventsCompleted: "Termine abgeschlossen",
            tasksCompleted: "Aufgaben erledigt"
        };

        const TRANSLATIONS = {
            de: BASE_TRANSLATIONS,
            en: {
                ...BASE_TRANSLATIONS,
                dashboard: "Dashboard",
                calendar: "Calendar",
                friends: "Friends",
                settings: "Settings",
                newEvent: "Event",
                title: "Title",
                category: "Category",
                save: "Save",
                cancel: "Cancel",
                delete: "Delete",
                edit: "Edit",
                details: "Details",
                remove: "Remove",
                messenger: "MSN Messenger",
                contacts: "Contacts",
                online: "Online",
                offline: "Offline",
                add: "Add",
                addContact: "Add contact",
                requests: "Requests",
                accept: "Accept",
                myCode: "My code",
                typeHere: "Type a message...",
                send: "Send",
                photo: "Photo",
                signIn: "Sign in",
                register: "Register",
                email: "Email",
                password: "Password",
                guest: "Guest access",
                or: "or",
                pendingRequests: "Pending requests",
                myFriends: "My friends",
                backToMe: "Back to me",
                viewing: "Viewing mode",
                friend: "friend", friends: "friends", member: "member", members: "members", selected: "selected",
            addFriend: "Add friend by code",
            shareCode: "Your friend code",
            shareCodePlaceholder: "rai123456",
            emailPlaceholder: "Email",
            passwordPlaceholder: "Password",
            nameExample: "e.g. Leo",
            aiDesignPlaceholder: "Example: dark, accent #ff8c00, text #f8fafc, font elegant, size 105%",
            citySearchPlaceholder: "e.g. Zurich, Basel, Milan ‚Ä¶",
            templateNamePlaceholder: "Template name (e.g. 'Daily standup')",
            work: "Work",
            personal: "Personal",
            health: "Health",
            household: "Household",
            leisure: "Leisure",
            focus: "Focus block",
            holiday: "Holiday",
                editEvent: "Edit event",
                eventDetails: "Details",
                dayOptions: "Options",
                assignShift: "Assign shift",
                createEvent: "Create event (+)",
                clearShift: "Clear shift",
                paintMode: "Paint",
                font: "Font",
                fontSize: "Size",
                manageShifts: "Manage shifts",
                appearance: "Appearance",
                selectShift: "Select shift",
                newShift: "New shift",
                start: "Start",
                end: "End",
                color: "Color",
                shiftName: "Name",
                fontModern: "Modern",
                fontAntique: "Antique",
                fontElegant: "Elegant",
                fontReadable: "Readable",
                fontStrong: "Strong",
                repeat: "Repeat",
                repeatNone: "Never",
                repeatDaily: "Daily",
                repeatWeekly: "Weekly",
                repeatMonthly: "Monthly",
                repeatYearly: "Yearly",
                offDuty: "Off",
                light: "Light",
                dark: "Dark",
                vibrant: "Vibrant",
                custom: "Custom",
                customizeTheme: "Customize colors",
                aiDesign: "AI design",
                aiDesignHint: "Describe colors and font ‚Äî we update the preview.",
                aiDesignApply: "Apply design",
                upcoming: "Upcoming",
                countdownLabel: "Countdown",
                countdownPrefix: "in",
                countdownNow: "now",
                daysLabel: "days",
                birthday: "Birthday",
                rangeDay: "Day",
                rangeWeek: "Week",
                rangeMonth: "Month",
                rangeYear: "Year",
                noUpcoming: "No events in the selected range.",
                monthEvents: "Events this month",
                noMonthEvents: "No events this month.",
                selectCalendarForEvent: "Please select a calendar first.",
                selectCalendarForShift: "Please select a calendar for shifts first.",
                eventsLoadErrorDetails: "Error loading events. Check database.",
                viewDay: "Day",
                viewWeek: "Week",
                viewMonth: "Month",
                location: "Location",
                search: "Search",
                searchPlaceholder: "Search events...",
                searchResults: "Results",
                noResults: "No events found.",
                clearSearch: "Back",
                pleaseEnterName: "Please enter a name.",
                noEventsToExport: "No events to export.",
                sharingRequiresEmailLookup: "Sharing requires email lookup. Use a public link.",
                calendarNotFound: "Calendar not found.",
                onlyOwnerCanChangeSettings: "Only the owner can change this setting.",
                manageCalendars: "Manage calendars",
                calendarMembers: "Calendar members",
                addMembers: "Add members",
                selectCalendar: "Select calendar",
                selectCalendarPlaceholder: "Select calendar...",
                calendarNoMembers: "No other members yet.",
                selectMembersPrompt: "Please select members first.",
                calendarOnlyOwner: "You are currently the only member.",
                onlyOwnerCanManageMembers: "Only the owner can manage members.",
                manageFriends: "Manage friends",
                friendCount: "friend",
                friendsCount: "friends",
                shareCalendar: "Share calendar",
                myCalendars: "My calendars",
                shareWithFriends: "Share with friends",
                selectFriends: "Select friends",
                noFriends: "No friends available",
                eventsListLabel: "Events",
                noEventsInRange: "No events in this range.",
                onlyOwnerCanShare: "Only the owner can share the calendar.",
                calendarOwner: "Owner",
                calendarMember: "Member",
                holidaySettings: "Holidays",
                holidaySettingsHint: "Sync holidays from the internet (worldwide, incl. Swiss cantons)",
                holidayCountrySearch: "Search country...",
                holidayCountryLabel: "Country",
                holidayRegionLabel: "Region / Canton",
                holidayRegionHint: "Only required for regional holidays (e.g., Switzerland)",
                holidayCalendarLabel: "Calendar for holidays",
                holidayCalendarHint: "Holidays are imported as separate events",
                holidaySyncButton: "Sync holidays",
                holidaySyncing: "Syncing holidays‚Ä¶",
                holidayLastSync: "Last sync",
                holidayNoSync: "Not synced yet",
                holidayCountriesError: "Country list could not be loaded. Using fallback list.",
                holidaySyncSuccess: "Holidays synced successfully.",
                holidaySyncError: "Could not load holidays.",
                holidayNoHolidaysFound: "No holidays found.",
                holidaySelectCountryFirst: "Please select a country first.",
                tasks: "Tasks",
                addTask: "Add task",
                taskTitle: "Task title",
                dueDate: "Due date",
                responsible: "Responsible",
                status: "Status",
                priority: "Priority",
                checklist: "Checklist",
                addSubtask: "Add subtask",
                subtask: "Subtask",
                statusOpen: "Open",
                statusInProgress: "In progress",
                statusCompleted: "Completed",
                priorityHigh: "High",
                priorityNormal: "Normal",
                priorityLow: "Low",
                taskReminder: "Task reminder",
                noTasks: "No tasks",
                deleteTask: "Delete task",
                unassigned: "Unassigned",
                name: "Name",
                invitees: "Invitees",
                inviteParticipants: "Invite participants (friends only)",
                organizer: "Organizer",
                going: "Going",
                maybe: "Maybe",
                declined: "Declined",
                noResponse: "No response",
            requestDropdown: "Event requests",
                acceptSelected: "Accept selected",
                declineSelected: "Decline selected",
                appLanguage: "Calendar language",
                appLanguageHint: "This language applies to the whole calendar.",
                customizeWizardTitle: "Custom design",
                wizardNext: "Next",
                wizardBack: "Back",
                wizardFinish: "Finish",
                wizardBg: "Background color",
                wizardAccent: "Accent color",
                wizardText: "Text color",
                hourLabel: "hour",
                hoursLabel: "hours",
                dayLabel: "day",
                previewLabel: "Preview",
                accentLabel: "Accent",
                loadMoreMessages: "Load more messages",
                proposeEventForFriend: "Suggest event",
                profile: "Profile",
                profileImage: "Profile picture",
                photoCapture: "Take photo",
                openCameraApp: "Open camera app",
                deleteImageTitle: "Delete image?",
                deleteImageHint: "This photo was marked as one-time view.",
                saving: "Saving...",
                myProfile: "My profile",
                meLabel: "Me",
                displayName: "Display name",
                statusText: "Status (text)",
                statusTextPlaceholder: "e.g. Busy, break, away...",
                bio: "Bio",
                bioPlaceholder: "Tell us about yourself...",
                changeAvatar: "Change profile photo",
                defaultLabel: "Default",
                designSettings: "Design settings",
                amoledToggle: "Enable AMOLED dark mode",
                amoledHint: "Deep black for OLED displays",
                back: "Back",
                sortAlpha: "A-Z",
                lastActive: "Last active",
                groups: "Groups",
                newLabel: "New",
                createGroup: "Create group",
                groupName: "Group name",
                groupNamePlaceholder: "My group...",
                groupMembers: "Select members (min. 2)",
                create: "Create",
                addFriendTitle: "Add friend",
                friendProfileTitle: "Friend profile",
                securitySettings: "Security settings",
                deleteAfterRead: "Delete after reading",
                expiry: "Expiry",
                expiry24h: "24h expiry",
                expiry7d: "7 day expiry",
                expiryNever: "No expiry",
                settingsApplyTo: "These settings apply only to",
                sendMessage: "Send message",
                sentAtLabel: "Sent",
                replyToLabel: "Reply to:",
                editedLabel: "(edited)",
                deletedMessage: "[Message deleted]",
                replyAction: "Reply",
                editingMessage: "Editing message...",
                encryptedLabel: "Encrypted",
                readOnceLabel: "Read once",
                expiresAtLabel: "Expires at:",
                attachPhoto: "Attach photo",
                openSettingsTitle: "Open settings",
                calendarSettingsTitle: "Calendar settings",
                exportIcsTitle: "Export as ICS",
                writeMessagePlaceholder: "Write a message...",
                zoomProfileImage: "Zoom profile picture",
                showProfile: "Show profile",
                clickToZoom: "Click to zoom",
                groupLabel: "Group",
                tapToDeleteImage: "Tap again to delete the image.",
                calendarOf: "Calendar of",
                shiftsLabel: "Shifts",
                dropHere: "Drop here",
                displayNameHint: "Your name (visible to friends)",
                friendCodeLabel: "Friend code",
                saveName: "Save name",
                timePlanning: "‚è±Ô∏è Time planning",
                durationShort: "Duration (min)",
                travelShort: "Travel (min)",
                bufferShort: "Buffer (min)",
                durationLabel: "Duration",
                travelTimeLabel: "Travel time",
                bufferTimeLabel: "Buffer time",
                minutesLabel: "minutes",
                baseDateLabel: "Base date",
                seriesLabel: "Series",
                atTime: "at",
                smartReminder: "üîî Smart reminder",
                smartReminders: "üîî Smart reminders",
                enableSmartReminder: "Enable smart reminder",
                reminderType: "Reminder type",
                fixedReminderOption: "‚è∞ Fixed time before event",
                workHoursReminderOption: "üíº Based on work hours",
                locationReminderOption: "üìç Based on location",
                patternReminderOption: "üîÑ Based on routine",
                minutesBefore: "Minutes before",
                workHoursReminderHint: "Reminder sent during your usual working hours",
                locationReminderHint: "Reminder based on travel time to the venue",
                patternReminderHint: "Reminder based on your recurring routines",
                eventTemplates: "üìã Event templates",
                hide: "Hide",
                saveAsTemplate: "Save as template",
                loadTemplate: "Load template",
                noDescription: "No description",
            templateNamePlaceholder: "Template name (e.g. 'Daily standup')",
                saveTemplate: "Save template",
                templateSaveHint: "The current configuration is saved as a reusable template",
                templateNameRequired: "Please enter a name for the template",
                templateSaveSuccess: "Template saved successfully!",
                templateSaveError: "Error saving template",
                templateDeleteConfirm: "Delete template?",
                templateDeleteError: "Error deleting template",
                availabilityOverview: "üìÖ Availability overview",
                selectContacts: "Select contacts",
                noFriendsAvailability: "No friends available. Add friends to see their availability.",
                timeLabel: "Time",
                busyLabel: "üî¥ Busy",
                freeLabel: "üü¢ Free",
                selectContactsHint: "Select contacts to see availability",
                createModeLabel: "Create",
                createForMe: "Only for me",
                requestTo: "Request to",
                requestConfirmationNote: "(in friend's calendar after approval)",
                createForMeAndRequest: "For me + request to",
                durationMinutes: "Duration (minutes)",
                travelTimeBefore: "üöó Travel time before (minutes)",
                travelTimeHint: "Automatic travel time to previous event",
                bufferTimeAfter: "‚è∏Ô∏è Buffer time after (minutes)",
                bufferTimeHint: "Time between this and the next appointment",
                weatherLocationTitle: "Select weather location",
                autoLocation: "Auto location",
                manualLocation: "Manual",
                autoLocationTitle: "Automatic location",
                autoLocationHint: "Uses GPS/browser location. If blocked: fallback Zurich.",
                manualLocationTitle: "Manual location",
                manualLocationHint: "Search for a city/region and choose a result.",
                searchButton: "Search",
                searchErrorOffline: "Offline ‚Äì search unavailable.",
                searchNoResults: "No results found.",
                searchErrorUnavailable: "Search currently unavailable.",
                currentSaved: "Currently saved",
                searchTip: "Tip: For consistent results (without location sharing) use Manual.",
                weatherForecastTitle: "7-day forecast",
                maxTemp: "Max",
                minTemp: "Min",
                windLabel: "Wind",
                dataSource: "Source: Open-Meteo API",
                weatherLoading: "Loading weather‚Ä¶",
                locationLabel: "Location",
                openMeteoLabel: "Open-Meteo",
                selectLocationButton: "Location",
                refreshWeatherButton: "Refresh",
                selectLocationTitle: "Select location",
                refreshWeatherTitle: "Refresh weather",
                forecastTitle: "Click for 7-day forecast",
                weatherErrorOffline: "Offline ‚Äì weather unavailable.",
                weatherErrorUnavailable: "Weather currently unavailable.",
                forecastErrorUnavailable: "Forecast currently unavailable.",
                manualLabel: "Manual",
                autoLabel: "Your location",
                weatherFallbackLabel: "Zurich (fallback)",
                weatherLabel: "Weather",
                premiumUnlockTitle: "üîí Unlock premium",
                premiumAccessHint: "Premium access.",
                premiumFeaturesTitle: "‚ú® Premium features:",
                premiumCodeLabel: "Enter code word:",
                premiumCodePlaceholder: "Enter code word here",
                premiumCodeError: "Wrong code. Please try again.",
                unlock: "Unlock",
                premiumCodeHint: "Note: the code is only required once.",
                newCalendarLabel: "New calendar",
                calendarNamePlaceholder: "Calendar name",
                calendarDescriptionPlaceholder: "Description (optional)",
                calendarCreateButton: "Create calendar",
                publicSharing: "Public sharing",
                publicSharingHint: "Anyone with the link can view the calendar",
                toggleOn: "ON",
                toggleOff: "OFF",
                publicLinkLabel: "Public link",
                copyLinkTitle: "Copy link",
                readOnlyAccess: "Read-only access for everyone",
                subscriptionLinkLabel: "Subscription link (ICS)",
                subscriptionLinkHint: "For Google Calendar, Apple Calendar, Outlook",
                subscriptionLinkInfo: "The subscription link enables automatic sync in other calendar apps.",
                errorProfileLoad: "Profile could not be loaded.",
                errorProfileSave: "Profile could not be saved.",
                errorImageProcess: "Image could not be processed.",
                errorCameraAccess: "Camera access failed. Please allow camera permissions.",
                errorCameraNotReady: "Camera not ready. Please try again.",
                errorCameraLoading: "Video is loading. Please wait a moment.",
                errorPhotoCreate: "Error creating photo. Please try again.",
                errorPhotoProcess: "Error processing photo.",
                errorGroupCreate: "Enter a group name and select at least 2 members.",
                groupCreated: "Group created!",
                requestSent: "Request sent!",
                errorAddFriend: "Error adding friend.",
                codeNotFound: "Code not found",
                selfRequest: "That's you!",
                nameSaved: "Name saved.",
                nameSaveError: "Error saving name.",
                eventRequestSent: "Event request sent to",
                requestSentSuffix: "sent!",
                eventSaveError: "Error saving event.",
                eventUpdateError: "Error updating event.",
                eventDeleteError: "Error deleting event.",
                shiftDeleteError: "Delete failed.",
                shiftDeleteLocked: "The 'Off' shift cannot be deleted.",
                calendarCreateError: "Error creating calendar.",
                calendarUpdateError: "Error updating calendar.",
                calendarShareError: "Error sharing calendar.",
                calendarVisibilityError: "Error changing visibility.",
                calendarManageNotAllowed: "You don't have permission for this action.",
                calendarOwnerCannotRemoveSelf: "The owner cannot remove themselves.",
                calendarMemberRemoveFailed: "Could not remove member.",
                calendarShareSomeFailed: "Some shares could not be saved.",
                eventsLoadError: "Error loading events.",
                eventsLoadErrorDetails: "Error loading events. Check database.",
                criticalError: "Critical error:",
                guestAccessDisabled: "Enable guest access in Firebase Console!",
                userFallback: "User",
                friendFallback: "Friend",
                contactFallback: "Contact",
                unknown: "Unknown",
                calendarDefaultName: "My calendar",
                calendarDefaultDescription: "Default calendar",
                calendarDefaultTitle: "TimeRoster Calendar",
                notificationNewMessage: "New message",
                notificationFriendRequest: "New friend request",
                notificationFriendRequestBody: "wants to add you as a friend",
                notificationEventInvite: "New event invitation",
                notificationEventInviteBody: "invited you to an event",
                notificationEventReminder: "Event reminder",
                notificationEventReminderBody: "starts soon",
                notificationSettings: "Notifications",
                notificationEnableBtn: "Enable notifications",
                notificationEnabled: "Notifications active",
                notificationDisabled: "Notifications disabled",
                notificationPermissionDenied: "Notification permission denied",
                notificationNotSupported: "Notifications not supported",
                notificationChatMessages: "Chat messages",
                notificationCalendarEvents: "Calendar events",
                notificationFriendRequests: "Friend requests",
                pwaInstall: "Install app",
                pwaInstallHint: "Install TimeRoster as an app on your device",
                pwaInstalled: "App installed ‚úì",
                pwaInstallIosHint: "Tap 'Share' ‚Üí 'Add to Home Screen'",
                logout: "Logout",
                quoteCategoryWisdom: "Wisdom",
                quoteCategoryMotivation: "Motivation",
                quoteCategoryCompliment: "Compliment",
                quoteCategoryFact: "Did you know",
                quoteFallbackText: "Today is a good day for a good step.",
                quoteFallbackOrigin: "Global",
                fileTooLarge: `File too large. Please stay under ${MAX_IMAGE_SIZE_LABEL}.`,
                messageSendError: "Message could not be sent. Please try again.",
                encryptionPreparing: "Encryption is preparing. Please wait a moment.",
                maxFileSizeLabel: "Max file size:"
            },
            it: {
                ...BASE_TRANSLATIONS,
                dashboard: "Dashboard",
                calendar: "Calendario",
                friends: "Amici",
                settings: "Impostazioni",
                newEvent: "Evento",
                title: "Titolo",
                category: "Categoria",
                save: "Salva",
                cancel: "Annulla",
                delete: "Elimina",
                edit: "Modifica",
                details: "Dettagli",
                remove: "Rimuovi",
                messenger: "MSN Messenger",
                contacts: "Contatti",
                online: "Online",
                offline: "Offline",
                add: "Aggiungi",
                addContact: "Aggiungi contatto",
                requests: "Richieste",
                accept: "Accetta",
                myCode: "Il mio codice",
                typeHere: "Scrivi un messaggio...",
                send: "Invia",
                photo: "Foto",
                signIn: "Accedi",
                register: "Registrati",
                email: "Email",
                password: "Password",
                guest: "Accesso ospite",
                or: "o",
                pendingRequests: "Richieste in sospeso",
                myFriends: "I miei amici",
                backToMe: "Torna a me",
                viewing: "Modalit√† visualizzazione",
                friend: "amico", friends: "amici", member: "membro", members: "membri", selected: "selezionato",
                addFriend: "Aggiungi amico con codice",
                shareCode: "Il tuo codice amico",
                shareCodePlaceholder: "rai123456",
                emailPlaceholder: "Email",
                passwordPlaceholder: "Password",
                nameExample: "es. Leo",
                aiDesignPlaceholder: "Esempio: scuro, accento #ff8c00, testo #f8fafc, font elegante, dimensione 105%",
                citySearchPlaceholder: "es. Zurigo, Basilea, Milano ‚Ä¶",
                templateNamePlaceholder: "Nome modello (es. 'Standup quotidiano')",
            work: "Lavoro",
            personal: "Personale",
            health: "Salute",
            household: "Casa",
            leisure: "Tempo libero",
            focus: "Blocco focus",
            holiday: "Festivit√†",
                editEvent: "Modifica evento",
                eventDetails: "Dettagli",
                dayOptions: "Opzioni",
                assignShift: "Assegna turno",
                createEvent: "Crea evento (+)",
                clearShift: "Cancella turno",
                paintMode: "Pennello",
                font: "Font",
                fontSize: "Dimensione",
                manageShifts: "Gestisci turni",
                appearance: "Aspetto",
                selectShift: "Seleziona turno",
                newShift: "Nuovo turno",
                start: "Inizio",
                end: "Fine",
                color: "Colore",
                shiftName: "Nome",
                fontModern: "Moderno",
                fontAntique: "Antico",
                fontElegant: "Elegante",
                fontReadable: "Leggibile",
                fontStrong: "Forte",
                repeat: "Ripeti",
                repeatNone: "Mai",
                repeatDaily: "Giornaliero",
                repeatWeekly: "Settimanale",
                repeatMonthly: "Mensile",
                repeatYearly: "Annuale",
                offDuty: "Libero",
                light: "Chiaro",
                dark: "Scuro",
                vibrant: "Vivace",
                custom: "Personalizzato",
                customizeTheme: "Personalizza colori",
                aiDesign: "Design AI",
                aiDesignHint: "Descrivi colori e font ‚Äî aggiorniamo l'anteprima.",
                aiDesignApply: "Applica design",
                upcoming: "In arrivo",
                countdownLabel: "Conto alla rovescia",
                countdownPrefix: "tra",
                countdownNow: "ora",
                daysLabel: "giorni",
                birthday: "Compleanno",
                rangeDay: "Giorno",
                rangeWeek: "Settimana",
                rangeMonth: "Mese",
                rangeYear: "Anno",
                noUpcoming: "Nessun evento nell'intervallo selezionato.",
                monthEvents: "Eventi del mese",
                noMonthEvents: "Nessun evento in questo mese.",
                selectCalendarForEvent: "Seleziona prima un calendario.",
                selectCalendarForShift: "Seleziona prima un calendario per i turni.",
                eventsLoadErrorDetails: "Errore nel caricamento degli eventi. Controlla il database.",
                viewDay: "Giorno",
                viewWeek: "Settimana",
                viewMonth: "Mese",
                location: "Luogo",
                search: "Cerca",
                searchPlaceholder: "Cerca eventi...",
                searchResults: "Risultati",
                noResults: "Nessun evento trovato.",
                clearSearch: "Indietro",
                pleaseEnterName: "Inserisci un nome.",
                noEventsToExport: "Nessun evento da esportare.",
                sharingRequiresEmailLookup: "La condivisione richiede la ricerca email. Usa un link pubblico.",
                calendarNotFound: "Calendario non trovato.",
                onlyOwnerCanChangeSettings: "Solo il proprietario pu√≤ cambiare questa impostazione.",
                manageCalendars: "Gestisci calendari",
                calendarMembers: "Membri del calendario",
                addMembers: "Aggiungi membri",
                selectCalendar: "Seleziona calendario",
                selectCalendarPlaceholder: "Seleziona calendario...",
                calendarNoMembers: "Ancora nessun altro membro.",
                selectMembersPrompt: "Seleziona prima i membri.",
                calendarOnlyOwner: "Sei attualmente l'unico membro.",
                onlyOwnerCanManageMembers: "Solo il proprietario pu√≤ gestire i membri.",
                manageFriends: "Gestisci amici",
                friendCount: "amico",
                friendsCount: "amici",
                shareCalendar: "Condividi calendario",
                myCalendars: "I miei calendari",
                shareWithFriends: "Condividi con amici",
                selectFriends: "Seleziona amici",
                noFriends: "Nessun amico disponibile",
                eventsListLabel: "Eventi",
                noEventsInRange: "Nessun evento in questo intervallo.",
                onlyOwnerCanShare: "Solo il proprietario pu√≤ condividere il calendario.",
                calendarOwner: "Proprietario",
                calendarMember: "Membro",
                holidaySettings: "Festivit√†",
                holidaySettingsHint: "Sincronizza festivit√† da internet (mondo intero, incl. cantoni svizzeri)",
                holidayCountrySearch: "Cerca paese...",
                holidayCountryLabel: "Paese",
                holidayRegionLabel: "Regione / Cantone",
                holidayRegionHint: "Serve solo per festivit√† regionali (es. Svizzera)",
                holidayCalendarLabel: "Calendario festivit√†",
                holidayCalendarHint: "Le festivit√† vengono importate come eventi",
                holidaySyncButton: "Sincronizza festivit√†",
                holidaySyncing: "Sincronizzazione festivit√†‚Ä¶",
                holidayLastSync: "Ultima sincronizzazione",
                holidayNoSync: "Non ancora sincronizzato",
                holidayCountriesError: "Impossibile caricare l'elenco paesi. Uso fallback.",
                holidaySyncSuccess: "Festivit√† sincronizzate.",
                holidaySyncError: "Impossibile caricare le festivit√†.",
                holidayNoHolidaysFound: "Nessuna festivit√† trovata.",
                holidaySelectCountryFirst: "Seleziona prima un paese.",
                tasks: "Attivit√†",
                addTask: "Aggiungi attivit√†",
                taskTitle: "Titolo attivit√†",
                dueDate: "Scadenza",
                responsible: "Responsabile",
                status: "Stato",
                priority: "Priorit√†",
                checklist: "Checklist",
                addSubtask: "Aggiungi sottoattivit√†",
                subtask: "Sottoattivit√†",
                statusOpen: "Aperto",
                statusInProgress: "In corso",
                statusCompleted: "Completato",
                priorityHigh: "Alta",
                priorityNormal: "Normale",
                priorityLow: "Bassa",
                taskReminder: "Promemoria attivit√†",
                noTasks: "Nessuna attivit√†",
                deleteTask: "Elimina attivit√†",
                unassigned: "Non assegnato",
                name: "Nome",
                invitees: "Invitati",
                inviteParticipants: "Invita partecipanti (solo amici)",
                organizer: "Organizzatore",
                going: "Partecipo",
                maybe: "Forse",
                declined: "Rifiutato",
                noResponse: "Nessuna risposta",
            requestDropdown: "Richieste evento",
                acceptSelected: "Accetta selezionati",
                declineSelected: "Rifiuta selezionati",
                appLanguage: "Lingua calendario",
                appLanguageHint: "Questa lingua si applica all‚Äôintero calendario.",
                customizeWizardTitle: "Design personalizzato",
                wizardNext: "Avanti",
                wizardBack: "Indietro",
                wizardFinish: "Fine",
                wizardBg: "Colore sfondo",
                wizardAccent: "Colore accento",
                wizardText: "Colore testo",
                hourLabel: "ora",
                hoursLabel: "ore",
                dayLabel: "giorno",
                previewLabel: "Anteprima",
                accentLabel: "Accento",
                loadMoreMessages: "Carica altri messaggi",
                proposeEventForFriend: "Proponi evento",
                profile: "Profilo",
                profileImage: "Immagine profilo",
                photoCapture: "Scatta foto",
                openCameraApp: "Apri fotocamera",
                deleteImageTitle: "Eliminare immagine?",
                deleteImageHint: "Questa foto √® stata contrassegnata come visione unica.",
                saving: "Salvataggio...",
                myProfile: "Il mio profilo",
                meLabel: "Io",
                displayName: "Nome visualizzato",
                statusText: "Stato (testo)",
                statusTextPlaceholder: "es. Occupato, pausa, fuori...",
                bio: "Bio",
                bioPlaceholder: "Racconta qualcosa di te...",
                changeAvatar: "Cambia foto profilo",
                defaultLabel: "Predefinito",
                designSettings: "Impostazioni design",
                amoledToggle: "Attiva modalit√† AMOLED",
                amoledHint: "Nero profondo per schermi OLED",
                back: "Indietro",
                sortAlpha: "A-Z",
                lastActive: "Ultimo accesso",
                groups: "Gruppi",
                newLabel: "Nuovo",
                createGroup: "Crea gruppo",
                groupName: "Nome gruppo",
                groupNamePlaceholder: "Il mio gruppo...",
                groupMembers: "Seleziona membri (min. 2)",
                create: "Crea",
                addFriendTitle: "Aggiungi amico",
                friendProfileTitle: "Profilo amico",
                securitySettings: "Impostazioni sicurezza",
                deleteAfterRead: "Elimina dopo lettura",
                expiry: "Scadenza",
                expiry24h: "Scadenza 24h",
                expiry7d: "Scadenza 7 giorni",
                expiryNever: "Nessuna scadenza",
                settingsApplyTo: "Queste impostazioni valgono solo per",
                sendMessage: "Invia messaggio",
                sentAtLabel: "Inviato",
                replyToLabel: "Risposta a:",
                editedLabel: "(modificato)",
                deletedMessage: "[Messaggio eliminato]",
                replyAction: "Rispondi",
                editingMessage: "Modifica messaggio...",
                encryptedLabel: "Crittografato",
                readOnceLabel: "Lettura singola",
                expiresAtLabel: "Scade alle:",
                attachPhoto: "Allega foto",
                openSettingsTitle: "Apri impostazioni",
                calendarSettingsTitle: "Impostazioni calendario",
                exportIcsTitle: "Esporta come ICS",
                writeMessagePlaceholder: "Scrivi un messaggio...",
                zoomProfileImage: "Ingrandisci immagine profilo",
                showProfile: "Mostra profilo",
                clickToZoom: "Clicca per ingrandire",
                groupLabel: "Gruppo",
                tapToDeleteImage: "Tocca di nuovo per eliminare l'immagine.",
                calendarOf: "Calendario di",
                shiftsLabel: "Turni",
                dropHere: "Rilascia qui",
                displayNameHint: "Il tuo nome (visibile agli amici)",
                friendCodeLabel: "Codice amico",
                saveName: "Salva nome",
                timePlanning: "‚è±Ô∏è Pianificazione tempo",
                durationShort: "Durata (min)",
                travelShort: "Viaggio (min)",
                bufferShort: "Buffer (min)",
                durationLabel: "Durata",
                travelTimeLabel: "Tempo di viaggio",
                bufferTimeLabel: "Tempo buffer",
                minutesLabel: "minuti",
                baseDateLabel: "Data base",
                seriesLabel: "Serie",
                atTime: "alle",
                smartReminder: "üîî Promemoria intelligente",
                smartReminders: "üîî Promemoria intelligenti",
                enableSmartReminder: "Attiva promemoria intelligente",
                reminderType: "Tipo promemoria",
                fixedReminderOption: "‚è∞ Ora fissa prima dell'evento",
                workHoursReminderOption: "üíº Basato su orari di lavoro",
                locationReminderOption: "üìç Basato sulla posizione",
                patternReminderOption: "üîÑ Basato sulla routine",
                minutesBefore: "Minuti prima",
                workHoursReminderHint: "Promemoria inviato durante i tuoi orari di lavoro",
                locationReminderHint: "Promemoria basato sul tempo di viaggio verso la sede",
                patternReminderHint: "Promemoria basato sulle tue routine ricorrenti",
                eventTemplates: "üìã Modelli evento",
                hide: "Nascondi",
                saveAsTemplate: "Salva come modello",
                loadTemplate: "Carica modello",
                noDescription: "Nessuna descrizione",
                templateNamePlaceholder: "Nome modello (es. 'Standup quotidiano')",
                saveTemplate: "Salva modello",
                templateSaveHint: "La configurazione attuale viene salvata come modello riutilizzabile",
                templateNameRequired: "Inserisci un nome per il modello",
                templateSaveSuccess: "Modello salvato!",
                templateSaveError: "Errore nel salvataggio del modello",
                templateDeleteConfirm: "Eliminare il modello?",
                templateDeleteError: "Errore nell'eliminazione del modello",
                availabilityOverview: "üìÖ Panoramica disponibilit√†",
                selectContacts: "Seleziona contatti",
                noFriendsAvailability: "Nessun amico disponibile. Aggiungi amici per vedere la disponibilit√†.",
                timeLabel: "Ora",
                busyLabel: "üî¥ Occupato",
                freeLabel: "üü¢ Libero",
                selectContactsHint: "Seleziona contatti per vedere la disponibilit√†",
                createModeLabel: "Crea",
                createForMe: "Solo per me",
                requestTo: "Richiesta a",
                requestConfirmationNote: "(nel calendario dell'amico dopo conferma)",
                createForMeAndRequest: "Per me + richiesta a",
                durationMinutes: "Durata (minuti)",
                travelTimeBefore: "üöó Tempo di viaggio prima (minuti)",
                travelTimeHint: "Tempo di viaggio automatico verso l'evento precedente",
                bufferTimeAfter: "‚è∏Ô∏è Tempo buffer dopo (minuti)",
                bufferTimeHint: "Tempo tra questo e il prossimo appuntamento",
                weatherLocationTitle: "Seleziona posizione meteo",
                autoLocation: "Posizione automatica",
                manualLocation: "Manuale",
                autoLocationTitle: "Posizione automatica",
                autoLocationHint: "Usa GPS/browser. Se bloccato: fallback Zurigo.",
                manualLocationTitle: "Posizione manuale",
                manualLocationHint: "Cerca una citt√†/regione e scegli un risultato.",
                searchButton: "Cerca",
                searchErrorOffline: "Offline ‚Äì ricerca non disponibile.",
                searchNoResults: "Nessun risultato trovato.",
                searchErrorUnavailable: "Ricerca non disponibile.",
                currentSaved: "Salvato attualmente",
                searchTip: "Suggerimento: per risultati coerenti (senza condivisione posizione) usa Manuale.",
                weatherForecastTitle: "Previsioni 7 giorni",
                maxTemp: "Max",
                minTemp: "Min",
                windLabel: "Vento",
                dataSource: "Fonte: Open-Meteo API",
                weatherLoading: "Meteo in caricamento‚Ä¶",
                locationLabel: "Posizione",
                openMeteoLabel: "Open-Meteo",
                selectLocationButton: "Posizione",
                refreshWeatherButton: "Aggiorna",
                selectLocationTitle: "Seleziona posizione",
                refreshWeatherTitle: "Aggiorna meteo",
                forecastTitle: "Clicca per previsioni 7 giorni",
                weatherErrorOffline: "Offline ‚Äì meteo non disponibile.",
                weatherErrorUnavailable: "Meteo non disponibile.",
                forecastErrorUnavailable: "Previsioni non disponibili.",
                manualLabel: "Manuale",
                autoLabel: "La tua posizione",
                weatherFallbackLabel: "Zurigo (fallback)",
                weatherLabel: "Meteo",
                premiumUnlockTitle: "üîí Sblocca premium",
                premiumAccessHint: "Accesso premium.",
                premiumFeaturesTitle: "‚ú® Funzionalit√† premium:",
                premiumCodeLabel: "Inserisci codice:",
                premiumCodePlaceholder: "Inserisci codice qui",
                premiumCodeError: "Codice errato. Riprova.",
                unlock: "Sblocca",
                premiumCodeHint: "Nota: il codice √® richiesto solo una volta.",
                newCalendarLabel: "Nuovo calendario",
                calendarNamePlaceholder: "Nome calendario",
                calendarDescriptionPlaceholder: "Descrizione (opzionale)",
                calendarCreateButton: "Crea calendario",
                publicSharing: "Condivisione pubblica",
                publicSharingHint: "Chiunque con il link pu√≤ vedere il calendario",
                toggleOn: "ON",
                toggleOff: "OFF",
                publicLinkLabel: "Link pubblico",
                copyLinkTitle: "Copia link",
                readOnlyAccess: "Accesso in sola lettura per tutti",
                subscriptionLinkLabel: "Link abbonamento (ICS)",
                subscriptionLinkHint: "Per Google Calendar, Apple Calendar, Outlook",
                subscriptionLinkInfo: "Il link di abbonamento abilita la sincronizzazione automatica in altre app.",
                errorProfileLoad: "Impossibile caricare il profilo.",
                errorProfileSave: "Impossibile salvare il profilo.",
                errorImageProcess: "Impossibile elaborare l'immagine.",
                errorCameraAccess: "Accesso fotocamera non riuscito. Concedi il permesso.",
                errorCameraNotReady: "Fotocamera non pronta. Riprova.",
                errorCameraLoading: "Video in caricamento. Attendi un momento.",
                errorPhotoCreate: "Errore nel creare la foto. Riprova.",
                errorPhotoProcess: "Errore nell'elaborazione della foto.",
                errorGroupCreate: "Inserisci un nome gruppo e seleziona almeno 2 membri.",
                groupCreated: "Gruppo creato!",
                requestSent: "Richiesta inviata!",
                errorAddFriend: "Errore nell'aggiungere l'amico.",
                codeNotFound: "Codice non trovato",
                selfRequest: "Sei tu!",
                nameSaved: "Nome salvato.",
                nameSaveError: "Errore nel salvataggio del nome.",
                eventRequestSent: "Richiesta evento inviata a",
                requestSentSuffix: "inviata!",
                eventSaveError: "Errore nel salvataggio dell'evento.",
                eventUpdateError: "Errore nell'aggiornamento dell'evento.",
                eventDeleteError: "Errore nell'eliminazione dell'evento.",
                shiftDeleteError: "Eliminazione non riuscita.",
                shiftDeleteLocked: "Il turno 'Libero' non pu√≤ essere eliminato.",
                calendarCreateError: "Errore nella creazione del calendario.",
                calendarUpdateError: "Errore nell'aggiornamento del calendario.",
                calendarShareError: "Errore nella condivisione del calendario.",
                calendarVisibilityError: "Errore nel cambiare la visibilit√†.",
                calendarManageNotAllowed: "Non hai i permessi per questa azione.",
                calendarOwnerCannotRemoveSelf: "Il proprietario non pu√≤ rimuovere se stesso.",
                calendarMemberRemoveFailed: "Impossibile rimuovere il membro.",
                calendarShareSomeFailed: "Alcune condivisioni non sono state salvate.",
                eventsLoadError: "Errore nel caricamento degli eventi.",
                eventsLoadErrorDetails: "Errore nel caricamento degli eventi. Controlla il database.",
                criticalError: "Errore critico:",
                guestAccessDisabled: "Abilita accesso ospite nella console Firebase!",
                userFallback: "Utente",
                friendFallback: "Amico",
                contactFallback: "Contatto",
                unknown: "Sconosciuto",
                calendarDefaultName: "Il mio calendario",
                calendarDefaultDescription: "Calendario predefinito",
                calendarDefaultTitle: "Calendario TimeRoster",
                notificationNewMessage: "Nuovo messaggio",
                notificationFriendRequest: "Nuova richiesta di amicizia",
                notificationFriendRequestBody: "vuole aggiungerti come amico",
                notificationEventInvite: "Nuovo invito evento",
                notificationEventInviteBody: "ti ha invitato a un evento",
                notificationEventReminder: "Promemoria evento",
                notificationEventReminderBody: "inizia a breve",
                notificationSettings: "Notifiche",
                notificationEnableBtn: "Attiva notifiche",
                notificationEnabled: "Notifiche attive",
                notificationDisabled: "Notifiche disattivate",
                notificationPermissionDenied: "Permesso notifiche negato",
                notificationNotSupported: "Notifiche non supportate",
                notificationChatMessages: "Messaggi chat",
                notificationCalendarEvents: "Eventi calendario",
                notificationFriendRequests: "Richieste di amicizia",
                pwaInstall: "Installa app",
                pwaInstallHint: "Installa TimeRoster come app sul dispositivo",
                pwaInstalled: "App installata ‚úì",
                pwaInstallIosHint: "Tocca 'Condividi' ‚Üí 'Aggiungi a schermata Home'",
                logout: "Logout",
                quoteCategoryWisdom: "Saggezza",
                quoteCategoryMotivation: "Motivazione",
                quoteCategoryCompliment: "Complimento",
                quoteCategoryFact: "Curiosit√†",
                quoteFallbackText: "Oggi √® un buon giorno per un buon passo.",
                quoteFallbackOrigin: "Globale",
                fileTooLarge: `File troppo grande. Rimani sotto ${MAX_IMAGE_SIZE_LABEL}.`,
                messageSendError: "Messaggio non inviato. Riprova.",
                encryptionPreparing: "Crittografia in preparazione. Attendi un momento.",
                maxFileSizeLabel: "Dimensione max file:"
            }
        };

        const setCurrentLang = (lang) => { CURRENT_LANG = lang; };

        const t = (key) => {
            const map = TRANSLATIONS[CURRENT_LANG] || TRANSLATIONS.de;
            return map[key] || TRANSLATIONS.de[key] || key;
        };

        const isSameDay = (a, b) => {
            if (!(a instanceof Date) || !(b instanceof Date)) return false;
            return a.getFullYear() === b.getFullYear()
                && a.getMonth() === b.getMonth()
                && a.getDate() === b.getDate();
        };

        const SETTINGS_EDITOR_TEXT = {
            de: {
                visualEditor: "Visual-Editor",
                guidedSetup: "Gef√ºhrte Einrichtung",
                stepTheme: "Design w√§hlen",
                stepFont: "Schrift & Gr√∂√üe",
                stepLanguage: "Sprache",
                preview: "Vorschau",
                next: "Weiter",
                back: "Zur√ºck",
                apply: "√úbernehmen",
                cancel: "Abbrechen",
                editorLanguage: "Editor-Sprache",
                languageLabel: "Sprache",
                languageHint: "Diese Sprache gilt f√ºr den Einstellungsbereich.",
                migrationNotice: "Legacy-Einstellungen wurden automatisch aktualisiert."
            },
            en: {
                visualEditor: "Visual Editor",
                guidedSetup: "Guided setup",
                stepTheme: "Choose theme",
                stepFont: "Font & size",
                stepLanguage: "Language",
                preview: "Preview",
                next: "Next",
                back: "Back",
                apply: "Apply",
                cancel: "Cancel",
                editorLanguage: "Editor language",
                languageLabel: "Language",
                languageHint: "This language applies to the settings area.",
                migrationNotice: "Legacy settings were upgraded automatically."
            },
            it: {
                visualEditor: "Editor visivo",
                guidedSetup: "Configurazione guidata",
                stepTheme: "Scegli tema",
                stepFont: "Font e dimensione",
                stepLanguage: "Lingua",
                preview: "Anteprima",
                next: "Avanti",
                back: "Indietro",
                apply: "Applica",
                cancel: "Annulla",
                editorLanguage: "Lingua editor",
                languageLabel: "Lingua",
                languageHint: "Questa lingua vale per le impostazioni.",
                migrationNotice: "Le impostazioni precedenti sono state aggiornate."
            }
        };

        const SETTINGS_LANG_OPTIONS = [
            { id: 'de', label: 'Deutsch' },
            { id: 'en', label: 'English' },
            { id: 'it', label: 'Italiano' }
        ];

        const getSettingsText = (lang, key) => SETTINGS_EDITOR_TEXT[lang]?.[key] || SETTINGS_EDITOR_TEXT.de[key] || key;

            const CATEGORIES = [
                { id: 'work', name: 'Arbeit', icon: 'üíº', color: '#f59e0b' },
            { id: 'personal', name: 'Privat', icon: 'üë§', color: '#3b82f6' },
            { id: 'birthday', name: 'Geburtstag', icon: 'üéÇ', color: '#ec4899' },
            { id: 'health', name: 'Gesundheit', icon: '‚ù§Ô∏è', color: '#ef4444' },
            { id: 'household', name: 'Haushalt', icon: 'üè†', color: '#10b981' },
            { id: 'leisure', name: 'Freizeit', icon: 'üéâ', color: '#8b5cf6' },
            { id: 'focus', name: 'Fokus-Block', icon: 'üéØ', color: '#7c3aed' },
            { id: 'holiday', name: 'Feiertag', icon: 'üéå', color: '#16a34a' },
        ];

        const FONT_LABEL_KEYS = {
            'font-inter': 'fontModern',
            'font-cinzel': 'fontAntique',
            'font-playfair': 'fontElegant',
            'font-merriweather': 'fontReadable',
            'font-oswald': 'fontStrong'
        };

        const DEFAULT_SHIFTS = [
            { id: 'early', name: 'Fr√ºh', start: '06:00', end: '14:00', color: '#10b981' }, 
            { id: 'late', name: 'Sp√§t', start: '14:00', end: '22:00', color: '#f59e0b' }, 
            { id: 'night', name: 'Nacht', start: '22:00', end: '06:00', color: '#6366f1' }, 
            { id: 'off', name: 'Frei', start: '-', end: '-', color: '#9ca3af' } 
        ];


        // --- END-TO-END ENCRYPTION (Web Crypto API) ---
        // Uses AES-GCM for encryption with ECDH for key exchange
        const E2EE = {
            // Generate a new key pair for the user
            async generateKeyPair() {
                return await crypto.subtle.generateKey(
                    { name: "ECDH", namedCurve: "P-256" },
                    true,
                    ["deriveKey", "deriveBits"]
                );
            },

            // Export public key to Base64
            async exportPublicKey(publicKey) {
                const exported = await crypto.subtle.exportKey("spki", publicKey);
                return btoa(String.fromCharCode(...new Uint8Array(exported)));
            },

            // Import public key from Base64
            async importPublicKey(base64Key) {
                const binary = atob(base64Key);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                return await crypto.subtle.importKey(
                    "spki",
                    bytes.buffer,
                    { name: "ECDH", namedCurve: "P-256" },
                    true,
                    []
                );
            },

            // Export private key to Base64
            async exportPrivateKey(privateKey) {
                const exported = await crypto.subtle.exportKey("pkcs8", privateKey);
                return btoa(String.fromCharCode(...new Uint8Array(exported)));
            },

            // Import private key from Base64
            async importPrivateKey(base64Key) {
                const binary = atob(base64Key);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                return await crypto.subtle.importKey(
                    "pkcs8",
                    bytes.buffer,
                    { name: "ECDH", namedCurve: "P-256" },
                    true,
                    ["deriveKey", "deriveBits"]
                );
            },

            // Derive shared secret from key pair
            async deriveSharedSecret(privateKey, publicKey) {
                return await crypto.subtle.deriveKey(
                    { name: "ECDH", public: publicKey },
                    privateKey,
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                );
            },

            // Encrypt message with AES-GCM
            async encrypt(text, sharedSecret) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encoded = new TextEncoder().encode(text);
                const encrypted = await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv },
                    sharedSecret,
                    encoded
                );
                // Return IV + encrypted data as Base64
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);
                return btoa(String.fromCharCode(...combined));
            },

            // Decrypt message with AES-GCM
            async decrypt(encryptedBase64, sharedSecret) {
                try {
                    const binary = atob(encryptedBase64);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                    
                    const iv = bytes.slice(0, 12);
                    const data = bytes.slice(12);
                    
                    const decrypted = await crypto.subtle.decrypt(
                        { name: "AES-GCM", iv },
                        sharedSecret,
                        data
                    );
                    return new TextDecoder().decode(decrypted);
                } catch (e) {
                    console.error("Decryption error:", e);
                    return "[Entschl√ºsselung fehlgeschlagen]";
                }
            },

            // For group conversations: encrypt for multiple recipients
            async encryptForGroup(text, sharedSecrets) {
                const encrypted = {};
                for (const [userId, secret] of Object.entries(sharedSecrets)) {
                    encrypted[userId] = await this.encrypt(text, secret);
                }
                return encrypted;
            }
        };

        // --- SECRET MSN NACHRICHTEN (Modern UI + MSN Presence + Avatar Upload) ---
        const INITIAL_MESSAGE_LIMIT = 100;
        const MESSAGE_BATCH_SIZE = 50;
        const INPUT_REFOCUS_DELAY = 50;
        const DEFAULT_MESSAGE_SETTINGS = { readOnce: false, expiry: '24h' };
        
        const SecretMsnMessages = ({ user, onClose, queuePushNotification, initialOpen, notificationPrefs, saveNotificationPrefs }) => {
            const [view, setView] = useState('list'); // list | add | message | profile | friendProfile | createGroup
            const [contacts, setContacts] = useState([]);
            const [groups, setGroups] = useState([]);
            const [activeConversation, setActiveConversation] = useState(null);
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [myCode, setMyCode] = useState('');
            const ensureSecretContact = async (friendId, name = '') => {
                if (!user || !friendId) return;
                try {
                    const ref = doc(db, 'artifacts', appId, 'users', user.uid, 'secret_contacts', friendId);
                    await setDoc(ref, {
                        friendId,
                        name: (name || '').trim() || friendId.slice(0, 6) + '‚Ä¶',
                        updatedAt: serverTimestamp()
                    }, { merge: true });
                } catch (e) {
                    console.warn('ensureSecretContact failed:', e?.message || e);
                }
            };

            // Deep-link: open chat from outside (Messages tab)
            useEffect(() => {
                if (!initialOpen?.friendId) return;
                (async () => {
                    await ensureSecretContact(initialOpen.friendId, initialOpen.friendName || '');
                })();
            }, [initialOpen?.friendId]);

            useEffect(() => {
                if (!initialOpen?.friendId) return;
                const c = contacts.find(x => x.friendId === initialOpen.friendId);
                if (c) {
                    setActiveConversation(c);
                    setView('message');
                }
            }, [initialOpen?.friendId, contacts]);

            const [addCode, setAddCode] = useState('');
            const [requests, setRequests] = useState([]);
            const [profile, setProfile] = useState({ username: '', avatar: '', statusText: '', bio: '' });
            const [avatarZoom, setAvatarZoom] = useState(null); // { src, name }
            const [savingProfile, setSavingProfile] = useState(false);
            const [messageLimit, setMessageLimit] = useState(INITIAL_MESSAGE_LIMIT);
            const [hasMoreMessages, setHasMoreMessages] = useState(false);
            const scrollRef = useRef();
            const inputRef = useRef();
            const [editingMessage, setEditingMessage] = useState(null);
            const [replyingTo, setReplyingTo] = useState(null);
            const [friendSortMode, setFriendSortMode] = useState(() => safeStorageGet('msn_friend_sort') || 'status');
            const [viewingFriendProfile, setViewingFriendProfile] = useState(null);
            const [myKeys, setMyKeys] = useState(null); // { publicKey, privateKey }
            const [sharedSecrets, setSharedSecrets] = useState({}); // { friendId: sharedSecret }
            const [messageExpiry, setMessageExpiry] = useState(DEFAULT_MESSAGE_SETTINGS.expiry); // '24h', '7d', 'never'
            const [readOnceMode, setReadOnceMode] = useState(DEFAULT_MESSAGE_SETTINGS.readOnce);
            const [groupName, setGroupName] = useState('');
            const [selectedGroupMembers, setSelectedGroupMembers] = useState([]);
            const [messagesDarkMode, setMessagesDarkMode] = useState(() => safeStorageGet('msn_messages_dark_mode') === 'true');
            const [cameraOpen, setCameraOpen] = useState(false);
            const [cameraStream, setCameraStream] = useState(null);
            const [imageZoom, setImageZoom] = useState(null); // { src, readOnce, messageId }
            const [pendingDeleteImage, setPendingDeleteImage] = useState(null); // { id, readOnce }
            const videoRef = useRef();
            const canvasRef = useRef();
            const messageRefs = useRef({});
            const filePickerRef = useRef();

            const getMessageSettingsKey = (friendId) => `msn_message_settings_${friendId}`;
            const getConversationAvatarClass = (isGroup) => {
                const base = 'w-8 h-8 border border-slate-200 rounded-full overflow-hidden';
                const groupClasses = 'bg-gradient-to-br from-blue-500 to-purple-500 flex items-center justify-center text-white text-xs font-bold cursor-default';
                const friendClasses = 'bg-white hover:opacity-80';
                return `${base} ${isGroup ? groupClasses : friendClasses}`;
            };

            const loadMessageSettings = (contact) => {
                if (!contact || contact.isGroup || !contact.friendId) {
                    setReadOnceMode(DEFAULT_MESSAGE_SETTINGS.readOnce);
                    setMessageExpiry(DEFAULT_MESSAGE_SETTINGS.expiry);
                    return;
                }
                const raw = safeStorageGet(getMessageSettingsKey(contact.friendId));
                if (!raw) {
                    setReadOnceMode(DEFAULT_MESSAGE_SETTINGS.readOnce);
                    setMessageExpiry(DEFAULT_MESSAGE_SETTINGS.expiry);
                    return;
                }
                try {
                    const parsed = JSON.parse(raw);
                    setReadOnceMode(!!parsed.readOnce);
                    setMessageExpiry(parsed.expiry || DEFAULT_MESSAGE_SETTINGS.expiry);
                } catch {
                    console.warn('Failed to parse message settings:', raw);
                    setReadOnceMode(DEFAULT_MESSAGE_SETTINGS.readOnce);
                    setMessageExpiry(DEFAULT_MESSAGE_SETTINGS.expiry);
                }
            };

            const saveMessageSettings = (friendId, nextSettings) => {
                if (!friendId) return;
                const payload = {
                    readOnce: !!nextSettings.readOnce,
                    expiry: nextSettings.expiry || DEFAULT_MESSAGE_SETTINGS.expiry
                };
                if (!safeStorageSet(getMessageSettingsKey(friendId), JSON.stringify(payload))) {
                    console.warn('Storage blocked: cannot save message settings.');
                }
            };

            // Helper function to safely convert timestamps
            const toMillis = (timestamp) => {
                if (!timestamp) return 0;
                if (typeof timestamp === 'number') return timestamp;
                if (timestamp.toMillis) return timestamp.toMillis();
                if (timestamp instanceof Date) return timestamp.getTime();
                return 0;
            };

            const avatarSrc = (uid, avatar) => {
                if (avatar && String(avatar).trim().length > 0) return avatar;
                return `https://api.dicebear.com/7.x/pixel-art/svg?seed=${encodeURIComponent(uid)}`;
            };

            // Save dark mode preference
            useEffect(() => {
                if (!safeStorageSet('msn_messages_dark_mode', messagesDarkMode)) {
                    console.warn('Storage blocked: cannot save dark mode preference.');
                }
            }, [messagesDarkMode]);

            useEffect(() => {
                const updatePresence = async () => {
                    try {
                        const profileRef = doc(db, 'artifacts', appId, 'users', user.uid, 'secret_msn_profile', 'main');
                        const snap = await getDoc(profileRef);
                        let code = '';
                        let keys = myKeys;
                        
                        if (!snap.exists()) {
                            code = generateCode();
                            const username = user.email?.split('@')[0] || "Gast";
                            
                            // Generate encryption keys
                            const keyPair = await E2EE.generateKeyPair();
                            const publicKeyB64 = await E2EE.exportPublicKey(keyPair.publicKey);
                            const privateKeyB64 = await E2EE.exportPrivateKey(keyPair.privateKey);
                            keys = { publicKey: keyPair.publicKey, privateKey: keyPair.privateKey };
                            setMyKeys(keys);
                            
                            const base = { 
                                shareCode: code, 
                                username, 
                                avatar: '', 
                                statusText: '', 
                                bio: '', 
                                status: 'online', 
                                lastSeen: serverTimestamp(),
                                publicKey: publicKeyB64,
                                privateKey: privateKeyB64 // Store encrypted in production
                            };
                            await setDoc(profileRef, base);
                            await setDoc(doc(db, 'artifacts', appId, 'secret_public_codes', code), { userId: user.uid });
                            setProfile({ username, avatar: '', statusText: '', bio: '' });
                        } else {
                            const data = snap.data() || {};
                            code = data.shareCode || generateCode();
                            
                            // Load encryption keys
                            if (data.publicKey && data.privateKey) {
                                const publicKey = await E2EE.importPublicKey(data.publicKey);
                                const privateKey = await E2EE.importPrivateKey(data.privateKey);
                                keys = { publicKey, privateKey };
                                setMyKeys(keys);
                            } else {
                                // Generate keys if missing
                                const keyPair = await E2EE.generateKeyPair();
                                const publicKeyB64 = await E2EE.exportPublicKey(keyPair.publicKey);
                                const privateKeyB64 = await E2EE.exportPrivateKey(keyPair.privateKey);
                                keys = { publicKey: keyPair.publicKey, privateKey: keyPair.privateKey };
                                setMyKeys(keys);
                                await updateDoc(profileRef, { 
                                    publicKey: publicKeyB64,
                                    privateKey: privateKeyB64
                                });
                            }
                            
                            await updateDoc(profileRef, { lastSeen: serverTimestamp(), status: 'online' });
                            setProfile({
                                username: data.username || (user.email?.split('@')[0] || "Gast"),
                                avatar: data.avatar || '',
                                statusText: data.statusText || '',
                                bio: data.bio || ''
                            });
                        }
                        setMyCode(code);
                    } catch(e) { console.error("MSN Presence Error", e); }
                };
                updatePresence();
                const interval = setInterval(updatePresence, 60000);
                return () => clearInterval(interval);
            }, [user]);

            useEffect(() => {
                const q = collection(db, 'artifacts', appId, 'users', user.uid, 'secret_contacts');
                const unsub = onSnapshot(q, async (snap) => {
                    const list = [];
                    for (const d of snap.docs) {
                        const contactData = d.data();
                        const friendProfileRef = doc(db, 'artifacts', appId, 'users', contactData.friendId, 'secret_msn_profile', 'main');
                        const friendProfile = await getDoc(friendProfileRef);
                        let status = 'offline';
                        let avatar = '';
                        let statusText = '';
                        let username = contactData.name || 'Kontakt';
                        if (friendProfile.exists()) {
                            const fp = friendProfile.data() || {};
                            const lastSeen = fp.lastSeen?.toMillis() || 0;
                            if (Date.now() - lastSeen < 120000) status = 'online';
                            avatar = fp.avatar || '';
                            statusText = fp.statusText || '';
                            username = fp.username || username;
                            
                            // Derive shared secret for E2E encryption
                            if (myKeys && fp.publicKey) {
                                try {
                                    const friendPublicKey = await E2EE.importPublicKey(fp.publicKey);
                                    const sharedSecret = await E2EE.deriveSharedSecret(myKeys.privateKey, friendPublicKey);
                                    setSharedSecrets(prev => ({ ...prev, [contactData.friendId]: sharedSecret }));
                                } catch (e) {
                                    console.error("Error deriving shared secret:", e);
                                }
                            }
                        }
                        list.push({ id: d.id, ...contactData, name: username, status, avatar, statusText, isGroup: false });
                    }
                    setContacts(list);
                }, err => console.error("Contacts Err", err));
                return () => unsub();
            }, [user, myKeys]);
            
            // Load group conversations
            useEffect(() => {
                const q = query(
                    collection(db, 'artifacts', appId, 'secret_groups'),
                    where('members', 'array-contains', user.uid)
                );
                const unsub = onSnapshot(q, async (snap) => {
                    const list = [];
                    for (const d of snap.docs) {
                        const groupData = d.data();
                        list.push({ 
                            id: d.id, 
                            groupId: d.id,
                            name: groupData.name, 
                            avatar: groupData.avatar || '', 
                            members: groupData.members || [],
                            isGroup: true,
                            status: 'online'
                        });
                    }
                    setGroups(list);
                }, err => console.error("Groups Err", err));
                return () => unsub();
            }, [user]);

            useEffect(() => {
                const q = query(collection(db, 'artifacts', appId, 'secret_requests'), where('to', '==', user.uid), where('status', '==', 'pending'));
                const unsub = onSnapshot(q, (snap) => {
                    setRequests(snap.docs.map(d => ({ id: d.id, ...d.data() })));
                }, err => console.error("Requests Err", err));
                return () => unsub();
            }, [user]);

            useEffect(() => {
                if (!activeConversation) return;
                loadMessageSettings(activeConversation);
                setMessageLimit(INITIAL_MESSAGE_LIMIT); // Reset limit when switching conversations
                
                const chatId = activeConversation.isGroup 
                    ? activeConversation.groupId 
                    : [user.uid, activeConversation.friendId].sort().join('_');
                    
                const collectionPath = activeConversation.isGroup
                    ? collection(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs')
                    : collection(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs');
                    
                const q = query(collectionPath, orderBy('ts', 'desc'), limit(messageLimit));
                const unsub = onSnapshot(q, async (snap) => {
                    const msgs = [];
                    const batch = writeBatch(db);
                    const now = Date.now();
                    let hasOperations = false;
                    
                    for (const msgDoc of snap.docs) {
                        const data = msgDoc.data();
                        
                        // Check if message is expired
                        const expiresAt = toMillis(data.expiresAt);
                        if (expiresAt > 0 && now > expiresAt) {
                            // Delete expired message
                            const msgRef = activeConversation.isGroup
                                ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', msgDoc.id)
                                : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', msgDoc.id);
                            batch.delete(msgRef);
                            hasOperations = true;
                            continue;
                        }
                        
                        // Check if read-once message was already read
                        if (data.readOnce && data.readBy && data.readBy.includes(user.uid) && data.from !== user.uid) {
                            // Delete read-once message after it's been read
                            const msgRef = activeConversation.isGroup
                                ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', msgDoc.id)
                                : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', msgDoc.id);
                            batch.delete(msgRef);
                            hasOperations = true;
                            continue;
                        }
                        
                        // Decrypt message
                        let decryptedText = data.text || '';
                        let decryptedImg = data.img || '';
                        
                        if (data.encrypted && !data.deleted) {
                            if (activeConversation.isGroup) {
                                // For group messages, decrypt using our own encrypted copy
                                if (data.encryptedText && data.encryptedText[user.uid]) {
                                    // We need to derive shared secret with the sender
                                    const senderSecret = sharedSecrets[data.from];
                                    if (senderSecret) {
                                        decryptedText = await E2EE.decrypt(data.encryptedText[user.uid], senderSecret);
                                    }
                                }
                                if (data.encryptedImg && data.encryptedImg[user.uid]) {
                                    const senderSecret = sharedSecrets[data.from];
                                    if (senderSecret) {
                                        decryptedImg = await E2EE.decrypt(data.encryptedImg[user.uid], senderSecret);
                                    }
                                }
                            } else {
                                // For 1-on-1 conversations
                                const secret = sharedSecrets[activeConversation.friendId];
                                if (secret) {
                                    if (data.encryptedText) {
                                        decryptedText = await E2EE.decrypt(data.encryptedText, secret);
                                    }
                                    if (data.encryptedImg) {
                                        decryptedImg = await E2EE.decrypt(data.encryptedImg, secret);
                                    }
                                }
                            }
                        }
                        
                        msgs.push({ 
                            id: msgDoc.id, 
                            ...data, 
                            text: decryptedText,
                            img: decryptedImg
                        });
                        
                        // Mark messages as read
                        if (data.from !== user.uid && (!data.readBy || !data.readBy.includes(user.uid))) {
                            const msgRef = activeConversation.isGroup
                                ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', msgDoc.id)
                                : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', msgDoc.id);
                            const currentReadBy = data.readBy || [];
                            batch.update(msgRef, { readBy: [...currentReadBy, user.uid] });
                            hasOperations = true;
                        }
                    }
                    
                    if (hasOperations) {
                        batch.commit();
                    }
                    
                    setMessages(msgs.reverse());
                    setTimeout(() => scrollRef.current?.scrollIntoView({ behavior: 'smooth' }), 100);
                });
                return () => unsub();
            }, [activeConversation, messageLimit, sharedSecrets]);

            const sendMsg = async (imgData = null) => {
                const trimmedInput = input.trim();
                setUiError('');
                if (!activeConversation) {
                    alert('Bitte w√§hle eine Unterhaltung aus.');
                    return;
                }
                if (!trimmedInput && !imgData) return;
                
                const chatId = activeConversation.isGroup 
                    ? activeConversation.groupId 
                    : [user.uid, activeConversation.friendId].sort().join('_');
                
                if ((activeConversation.isGroup && !activeConversation.groupId) || (!activeConversation.isGroup && !activeConversation.friendId) || !chatId) {
                    alert('Unterhaltung konnte nicht geladen werden. Bitte erneut √∂ffnen.');
                    return;
                }

                if (activeConversation.isGroup) {
                    const missingSecrets = (activeConversation.members || []).filter(memberId => memberId !== user.uid && !sharedSecrets[memberId]);
                    if (missingSecrets.length) {
                        setUiError(t('encryptionPreparing'));
                        return;
                    }
                }
                
                try {
                    if (editingMessage) {
                        // Edit existing message - encrypt if needed
                        const msgRef = activeConversation.isGroup
                            ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', editingMessage.id)
                            : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', editingMessage.id);
                        
                        let updateData = { edited: serverTimestamp() };
                        
                        if (activeConversation.isGroup) {
                            // Encrypt for all group members
                            const encryptedForMembers = {};
                            for (const memberId of activeConversation.members) {
                                const secret = sharedSecrets[memberId];
                                if (secret && memberId !== user.uid) {
                                    encryptedForMembers[memberId] = await E2EE.encrypt(trimmedInput, secret);
                                }
                            }
                            updateData.encryptedText = encryptedForMembers;
                            updateData.encrypted = true;
                        } else {
                            const secret = sharedSecrets[activeConversation.friendId];
                            if (secret) {
                                updateData.encryptedText = await E2EE.encrypt(trimmedInput, secret);
                                updateData.encrypted = true;
                            } else {
                                updateData.text = trimmedInput;
                            }
                        }
                        
                        await updateDoc(msgRef, updateData);
                        setEditingMessage(null);
                    } else {
                        // Send new message with encryption
                        const msgData = { 
                            from: user.uid, 
                            ts: serverTimestamp(),
                            readBy: [user.uid],
                            encrypted: true,
                            readOnce: readOnceMode
                        };
                        
                        // Calculate expiration time
                        if (messageExpiry !== 'never') {
                            const expiryMs = messageExpiry === '24h' ? 24 * 60 * 60 * 1000 : 7 * 24 * 60 * 60 * 1000;
                            msgData.expiresAt = new Date(Date.now() + expiryMs);
                        }
                        
                        if (activeConversation.isGroup) {
                            // Encrypt for all group members
                            if (trimmedInput) {
                                const encryptedForMembers = {};
                                for (const memberId of activeConversation.members) {
                                    const secret = sharedSecrets[memberId];
                                    if (secret && memberId !== user.uid) {
                                        encryptedForMembers[memberId] = await E2EE.encrypt(trimmedInput, secret);
                                    }
                                }
                                msgData.encryptedText = encryptedForMembers;
                            }
                            
                            if (imgData) {
                                const encryptedImgForMembers = {};
                                for (const memberId of activeConversation.members) {
                                    const secret = sharedSecrets[memberId];
                                    if (secret && memberId !== user.uid) {
                                        encryptedImgForMembers[memberId] = await E2EE.encrypt(imgData, secret);
                                    }
                                }
                                msgData.encryptedImg = encryptedImgForMembers;
                            }
                        } else {
                            // Encrypt for single recipient
                            const secret = sharedSecrets[activeConversation.friendId];
                            if (secret) {
                                if (trimmedInput) {
                                    msgData.encryptedText = await E2EE.encrypt(trimmedInput, secret);
                                }
                                if (imgData) {
                                    msgData.encryptedImg = await E2EE.encrypt(imgData, secret);
                                }
                            } else {
                                // Fallback if encryption not available
                                msgData.text = trimmedInput;
                                msgData.img = imgData;
                                msgData.encrypted = false;
                            }
                        }
                        
                        // Add reply reference if replying
                        if (replyingTo) {
                            msgData.replyTo = {
                                messageId: replyingTo.id,
                                text: replyingTo.text || '[Image]',
                                from: replyingTo.from
                            };
                        }
                        
                        const collectionPath = activeConversation.isGroup
                            ? collection(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs')
                            : collection(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs');
                        
                        await addDoc(collectionPath, msgData);
                        setReplyingTo(null);
                        
                        // Queue push notification for the recipient
                        if (!activeConversation.isGroup && activeConversation.friendId) {
                            const senderName = profile.username || user.email?.split('@')[0] || t('guest');
                            queuePushNotification(
                                activeConversation.friendId,
                                senderName,
                                imgData ? 'üì∑ ' + t('photo') : (trimmedInput ? trimmedInput.substring(0, 100) : t('notificationNewMessage')),
                                { type: 'chat_message', chatId }
                            );
                        } else if (activeConversation.isGroup && activeConversation.members) {
                            const senderName = profile.username || user.email?.split('@')[0] || t('guest');
                            activeConversation.members.filter(m => m !== user.uid).forEach(memberId => {
                                queuePushNotification(
                                    memberId,
                                    `${activeConversation.name}`,
                                    `${senderName}: ${imgData ? 'üì∑' : (trimmedInput ? trimmedInput.substring(0, 80) : '')}`,
                                    { type: 'group_message', groupId: activeConversation.groupId }
                                );
                            });
                        }
                    }
                    
                    setInput('');
                    // Keep keyboard open by re-focusing the input
                    setTimeout(() => inputRef.current?.focus(), INPUT_REFOCUS_DELAY);
                } catch (err) {
                    console.error('sendMsg error:', err);
                    setUiError(t('messageSendError'));
                }
            };

            const deleteMsg = async (msgId) => {
                if (!activeConversation) return;
                const chatId = activeConversation.isGroup 
                    ? activeConversation.groupId 
                    : [user.uid, activeConversation.friendId].sort().join('_');
                const msgRef = activeConversation.isGroup
                    ? doc(db, 'artifacts', appId, 'secret_groups', chatId, 'msgs', msgId)
                    : doc(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs', msgId);
                await updateDoc(msgRef, { 
                    deleted: true, 
                    text: '', 
                    encryptedText: deleteField(),
                    encryptedImg: deleteField(),
                    img: ''
                });
            };

            const createGroup = async () => {
                if (!groupName.trim() || selectedGroupMembers.length < 2) {
                    alert(t('errorGroupCreate'));
                    return;
                }
                
                const groupMembers = [user.uid, ...selectedGroupMembers];
                const groupData = {
                    name: groupName,
                    avatar: '',
                    members: groupMembers,
                    createdBy: user.uid,
                    createdAt: serverTimestamp()
                };
                
                await addDoc(collection(db, 'artifacts', appId, 'secret_groups'), groupData);
                alert(t('groupCreated'));
                setGroupName('');
                setSelectedGroupMembers([]);
                setView('list');
            };

            const startEditMsg = (msg) => {
                setEditingMessage(msg);
                setInput(msg.text);
                setReplyingTo(null);
                inputRef.current?.focus();
            };

            const startReplyMsg = (msg) => {
                setReplyingTo(msg);
                setEditingMessage(null);
                inputRef.current?.focus();
            };

            const cancelEdit = () => {
                setEditingMessage(null);
                setInput('');
            };

            const cancelReply = () => {
                setReplyingTo(null);
            };

            const triggerFilePickerFallback = () => {
                setTimeout(() => filePickerRef.current?.click(), FILE_PICKER_FALLBACK_DELAY);
            };

            const handlePhoto = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (file.size > MAX_IMAGE_BYTES) {
                        alert(t('fileTooLarge'));
                        return;
                    }
                    const base64 = await compressImage(file);
                    sendMsg(base64);
                }
                if (e.target) e.target.value = '';
            };

            const openCamera = async () => {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                    setCameraStream(null);
                }
                try {
                    if (!navigator.mediaDevices?.getUserMedia) {
                        setUiError(t('errorCameraAccess'));
                        triggerFilePickerFallback();
                        return;
                    }
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: { ideal: 'environment' } } 
                    });
                    setCameraStream(stream);
                    setCameraOpen(true);
                    // Wait for video element to be rendered and set stream
                    setTimeout(() => {
                        if (videoRef.current) {
                            videoRef.current.srcObject = stream;
                            videoRef.current.play().catch(err => {
                                console.error('Video play error:', err);
                            });
                        }
                    }, 100);
                } catch (err) {
                    console.error('Camera access error:', err);
                    setUiError(t('errorCameraAccess'));
                    triggerFilePickerFallback();
                }
            };

            const closeCamera = () => {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                    setCameraStream(null);
                }
                setCameraOpen(false);
            };

            const hasCameraStream = !!cameraStream;

            const openImageZoom = (msg) => {
                if (!msg?.img) return;
                setImageZoom({ src: msg.img, readOnce: !!msg.readOnce, messageId: msg.id });
            };

            const confirmImageDelete = () => {
                if (!imageZoom?.messageId || !imageZoom.readOnce) {
                    setImageZoom(null);
                    return;
                }
                setPendingDeleteImage({ id: imageZoom.messageId, readOnce: true });
            };

            const cancelImageDelete = () => {
                setPendingDeleteImage(null);
            };

            const deleteReadOnceImage = async () => {
                if (!pendingDeleteImage?.id) return;
                await deleteMsg(pendingDeleteImage.id);
                setPendingDeleteImage(null);
                setImageZoom(null);
            };

            const capturePhoto = async () => {
                if (!videoRef.current || !canvasRef.current) {
                    alert(t('errorCameraNotReady'));
                    return;
                }
                
                const video = videoRef.current;
                const canvas = canvasRef.current;
                
                // Check if video is ready
                if (video.readyState !== video.HAVE_ENOUGH_DATA) {
                    alert(t('errorCameraLoading'));
                    return;
                }
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                
                canvas.toBlob(async (blob) => {
                    if (!blob) {
                        alert(t('errorPhotoCreate'));
                        return;
                    }
                    if (blob.size > MAX_IMAGE_BYTES) {
                        alert(t('fileTooLarge'));
                        return;
                    }
                    
                    try {
                        const file = new File([blob], 'camera-photo.jpg', { type: 'image/jpeg' });
                        const base64 = await compressImage(file);
                        await sendMsg(base64);
                        closeCamera();
                    } catch (err) {
                        console.error('Photo processing error:', err);
                        alert(t('errorPhotoProcess'));
                    }
                }, 'image/jpeg', 0.8);
            };


            const sendRequest = async () => {
                if(!addCode) return;
                const q = query(collection(db, 'artifacts', appId, 'secret_public_codes'), where('__name__', '==', addCode.trim()));
                const snap = await getDocs(q);
                if (!snap.empty) {
                    const targetId = snap.docs[0].data().userId;
                    if(targetId === user.uid) return alert(t('selfRequest'));
                    await addDoc(collection(db, 'artifacts', appId, 'secret_requests'), { from: user.uid, fromName: user.email || t('guest'), to: targetId, status: 'pending', ts: serverTimestamp() });
                    alert(t('requestSent')); setAddCode(''); setView('list');
                } else alert(t('codeNotFound'));
            };

            const acceptRequest = async (req) => {
                try {
                    await setDoc(
                        doc(db, 'artifacts', appId, 'users', user.uid, 'secret_contacts', req.from),
                        { friendId: req.from, name: req.fromName || (req.from || '').slice(0, 6) + '‚Ä¶', acceptedAt: serverTimestamp() },
                        { merge: true }
                    );
                    // Mark accepted so Cloud Function can mirror contact to requester (no client cross-writes needed)
                    await setDoc(
                        doc(db, 'artifacts', appId, 'secret_requests', req.id),
                        {
                            status: 'accepted',
                            acceptedAt: serverTimestamp(),
                            toName: user.email || t('guest'),
                            to: user.uid
                        },
                        { merge: true }
                    );
                } catch (e) {
                    console.error('acceptRequest error', e);
                }
            };

            const saveMyProfile = async () => {
                setSavingProfile(true);
                try {
                    const profileRef = doc(db, 'artifacts', appId, 'users', user.uid, 'secret_msn_profile', 'main');
                    await setDoc(profileRef, {
                        username: profile.username || (user.email?.split('@')[0] || t('guest')),
                        avatar: profile.avatar || '',
                        statusText: profile.statusText || '',
                        bio: profile.bio || '',
                        lastSeen: serverTimestamp(),
                        status: 'online'
                    }, { merge: true });
                    setView('list');
                } catch (e) {
                    console.error(e);
                    alert(t('errorProfileSave'));
                } finally {
                    setSavingProfile(false);
                }
            };

            const handleAvatarUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (file.size > MAX_IMAGE_BYTES) {
                    alert(t('fileTooLarge'));
                    return;
                }
                try {
                    const base64 = await compressImage(file);
                    setProfile(p => ({ ...p, avatar: base64 }));
                } catch (err) {
                    console.error(err);
                    alert(t('errorImageProcess'));
                }
                if (e.target) e.target.value = '';
            };

            const onlineContacts = contacts.filter(c => c.status === 'online');
            const offlineContacts = contacts.filter(c => c.status !== 'online');

            const formatMessageText = (text) => {
                if (!text) return [];
                const urlRegex = /(https?:\/\/[^\s]+|www\.[^\s]+)/gi;
                const parts = [];
                let lastIndex = 0;
                let match;
                while ((match = urlRegex.exec(text)) !== null) {
                    if (match.index > lastIndex) {
                        parts.push({ type: 'text', value: text.slice(lastIndex, match.index) });
                    }
                    const raw = match[0];
                    const href = raw.startsWith('http') ? raw : `https://${raw}`;
                    parts.push({ type: 'link', value: raw, href });
                    lastIndex = match.index + raw.length;
                }
                if (lastIndex < text.length) {
                    parts.push({ type: 'text', value: text.slice(lastIndex) });
                }
                return parts.length ? parts : [{ type: 'text', value: text }];
            };

            const scrollToMessage = (messageId) => {
                if (!messageId) return;
                const node = messageRefs.current[messageId];
                if (!node) return;
                node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                node.classList.add('ring-2', 'ring-blue-400', 'ring-offset-2');
                setTimeout(() => node.classList.remove('ring-2', 'ring-blue-400', 'ring-offset-2'), 1600);
            };

            const sortContacts = (contactList) => {
                const sorted = [...contactList];
                if (friendSortMode === 'alpha') {
                    sorted.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                } else if (friendSortMode === 'lastActive') {
                    sorted.sort((a, b) => {
                        const aTime = a.lastSeen?.toMillis?.() || 0;
                        const bTime = b.lastSeen?.toMillis?.() || 0;
                        return bTime - aTime;
                    });
                }
                // 'status' mode keeps default online/offline split
                return sorted;
            };

            const sortedOnline = sortContacts(onlineContacts);
            const sortedOffline = sortContacts(offlineContacts);

            const handleSortChange = (mode) => {
                setFriendSortMode(mode);
                if (!safeStorageSet('msn_friend_sort', mode)) {
                    console.warn('Storage blocked: cannot save sort preference.');
                }
            };

            const viewFriendProfile = async (contact) => {
                const friendProfileRef = doc(db, 'artifacts', appId, 'users', contact.friendId, 'secret_msn_profile', 'main');
                const friendProfile = await getDoc(friendProfileRef);
                if (friendProfile.exists()) {
                    const fp = friendProfile.data() || {};
                    setViewingFriendProfile({
                        ...contact,
                        bio: fp.bio || '',
                        username: fp.username || contact.name,
                        avatar: fp.avatar || '',
                        statusText: fp.statusText || ''
                    });
                    loadMessageSettings(contact);
                    setView('friendProfile');
                } else {
                    alert(t('errorProfileLoad'));
                }
            };

            return (
                <div className={`fixed inset-0 z-[100] ${messagesDarkMode ? 'bg-black' : 'bg-black/80'} flex items-center justify-center font-msn ${messagesDarkMode ? 'text-white' : 'text-black'}`}>
                    {avatarZoom && (
                        <div className="fixed inset-0 z-[110] bg-black/90 backdrop-blur-md flex items-center justify-center p-4" onClick={() => setAvatarZoom(null)}>
                            <div className={`max-w-sm w-full rounded-2xl overflow-hidden shadow-2xl photo-preview ${messagesDarkMode ? 'bg-[#0a0a0a] border border-white/10' : 'bg-white border border-gray-200'}`} onClick={(e)=>e.stopPropagation()}>
                                <div className={`${messagesDarkMode ? 'bg-[#0a0a0a] text-white border-b border-white/5' : 'msn-header'} p-3 flex justify-between items-center`}>
                                    <div className="text-xs font-bold tracking-tight">{avatarZoom.name || t('profileImage')}</div>
                                    <button onClick={() => setAvatarZoom(null)} className="w-7 h-7 rounded-lg bg-white/10 flex items-center justify-center hover:bg-red-500/30 transition"><X size={14}/></button>
                                </div>
                                <div className={`p-6 ${messagesDarkMode ? 'bg-[#0a0a0a]' : 'bg-white'} flex items-center justify-center`}>
                                    <img src={avatarZoom.src} className={`max-h-[60vh] w-auto rounded-2xl shadow-lg ${messagesDarkMode ? 'border-white/5' : 'border-gray-100'} border`} />
                                </div>
                            </div>
                        </div>
                    )}

                    {cameraOpen && (
                        <div className="fixed inset-0 z-[110] bg-black flex flex-col" onClick={closeCamera}>
                            <div className="w-full h-full flex flex-col" onClick={(e)=>e.stopPropagation()}>
                                {/* Camera top bar */}
                                <div className="absolute top-0 left-0 right-0 z-20 flex justify-between items-center p-4 bg-gradient-to-b from-black/70 to-transparent">
                                    <button onClick={closeCamera} className="cam-control-btn"><X size={20}/></button>
                                    <div className="text-white text-xs font-semibold tracking-wider uppercase opacity-80">{t('photoCapture')}</div>
                                    <div className="w-11"/>
                                </div>
                                
                                {/* Video viewfinder */}
                                <div className="flex-1 relative overflow-hidden bg-black flex items-center justify-center">
                                    <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover"></video>
                                    <canvas ref={canvasRef} className="hidden"></canvas>
                                    {/* Rule of thirds grid overlay */}
                                    <div className="cam-viewfinder"></div>
                                    {/* Corner brackets */}
                                    <div className="absolute top-8 left-8 w-8 h-8 border-t-2 border-l-2 border-white/40 rounded-tl-sm pointer-events-none"></div>
                                    <div className="absolute top-8 right-8 w-8 h-8 border-t-2 border-r-2 border-white/40 rounded-tr-sm pointer-events-none"></div>
                                    <div className="absolute bottom-28 left-8 w-8 h-8 border-b-2 border-l-2 border-white/40 rounded-bl-sm pointer-events-none"></div>
                                    <div className="absolute bottom-28 right-8 w-8 h-8 border-b-2 border-r-2 border-white/40 rounded-br-sm pointer-events-none"></div>
                                </div>
                                
                                {/* Camera bottom controls */}
                                <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/90 via-black/60 to-transparent pt-16 pb-8 px-6">
                                    <div className="flex items-center justify-center gap-8">
                                        {/* Gallery / attach from file */}
                                        <label className="cam-control-btn cursor-pointer">
                                            <ImageIcon size={20}/>
                                            <input
                                                ref={filePickerRef}
                                                type="file"
                                                accept="image/*"
                                                className="hidden"
                                                onChange={handlePhoto}
                                            />
                                        </label>
                                        
                                        {/* Capture button */}
                                        {hasCameraStream ? (
                                            <button onClick={capturePhoto} className="cam-capture-btn" title={t('photoCapture')}></button>
                                        ) : (
                                            <label className="cam-capture-btn flex items-center justify-center cursor-pointer" title={t('openCameraApp')}>
                                                <Camera size={24} className="text-slate-600 absolute z-10"/>
                                                <input
                                                    type="file"
                                                    accept="image/*"
                                                    capture="environment"
                                                    className="hidden"
                                                    onChange={handlePhoto}
                                                />
                                            </label>
                                        )}
                                        
                                        {/* Close button */}
                                        <button onClick={closeCamera} className="cam-control-btn">
                                            <X size={20}/>
                                        </button>
                                    </div>
                                    <div className="text-center text-white/40 text-[10px] mt-3 tracking-wide">{hasCameraStream ? t('photoCapture') : t('openCameraApp')}</div>
                                </div>
                            </div>
                        </div>
                    )}

                    {imageZoom && (
                        <div className="fixed inset-0 z-[120] bg-black/95 backdrop-blur-sm flex items-center justify-center p-4" onClick={confirmImageDelete}>
                            <div className="max-w-4xl w-full photo-preview" onClick={(e)=>e.stopPropagation()}>
                                <img src={imageZoom.src} className="w-full max-h-[85vh] object-contain rounded-2xl shadow-2xl" />
                                {imageZoom.readOnce && (
                                    <div className="text-center text-xs text-slate-400 mt-3 flex items-center justify-center gap-2">
                                        <Eye size={12} className="text-amber-400"/>
                                        {t('tapToDeleteImage')}
                                    </div>
                                )}
                                <button onClick={confirmImageDelete} className="absolute top-4 right-4 cam-control-btn"><X size={18}/></button>
                            </div>
                        </div>
                    )}

                    {pendingDeleteImage && (
                        <div className="fixed inset-0 z-[130] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
                            <div className="bg-slate-900/95 backdrop-blur-xl text-white rounded-2xl p-5 w-full max-w-sm shadow-2xl border border-white/10 photo-preview">
                                <div className="font-bold mb-2 text-base">{t('deleteImageTitle')}</div>
                                <div className="text-sm opacity-60 mb-5">{t('deleteImageHint')}</div>
                                <div className="flex gap-3">
                                    <button onClick={cancelImageDelete} className="flex-1 border border-white/10 py-2.5 rounded-xl text-sm hover:bg-white/5 transition">{t('cancel')}</button>
                                    <button onClick={deleteReadOnceImage} className="flex-1 bg-red-500 hover:bg-red-600 py-2.5 rounded-xl text-sm font-bold transition">{t('delete')}</button>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className={`w-full h-screen ${messagesDarkMode ? 'bg-[#0a0a0a] border border-white/5' : 'msn-window'} rounded-t-2xl flex flex-col overflow-hidden relative`}>
                        {messagesDarkMode ? (
                            <div className="bg-[#0a0a0a] border-b border-white/5 text-white p-4 flex justify-between items-center">
                                <div className="flex items-center gap-3"><div className="w-8 h-8 rounded-xl bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center"><MessageCircle size={14}/></div><span className="font-bold text-sm tracking-tight">{t('messenger')}</span></div>
                                <div className="flex items-center gap-1">
                                    <button onClick={() => setView('profile')} title={t('profile')} className="cam-control-btn" style={{width:32,height:32,background:'rgba(255,255,255,0.06)'}}><User size={14}/></button>
                                    <button onClick={onClose} className="cam-control-btn" style={{width:32,height:32,background:'rgba(255,255,255,0.06)'}}><X size={14}/></button>
                                </div>
                            </div>
                        ) : (
                            <>
                                <div className="msn-header p-4 flex justify-between items-center">
                                    <div className="flex items-center gap-3"><div className="w-8 h-8 rounded-xl bg-white/10 flex items-center justify-center"><MessageCircle size={14}/></div><span className="font-bold text-sm tracking-tight">Messenger</span></div>
                                    <div className="flex items-center gap-1">
                                        <button onClick={() => setView('profile')} title="Profil" className="w-8 h-8 rounded-lg bg-white/10 flex items-center justify-center hover:bg-white/20 transition"><User size={14}/></button>
                                        <button onClick={onClose} className="w-8 h-8 rounded-lg bg-white/10 flex items-center justify-center hover:bg-red-500/30 transition"><X size={14}/></button>
                                    </div>
                                </div>

                                <div className={`${messagesDarkMode ? 'bg-black border-b border-white/5 text-white' : 'msn-toolbar'} px-4 py-2.5 flex gap-5 text-xs`}>
                                    <button onClick={() => setView('list')} className={`hover:opacity-80 font-medium transition ${messagesDarkMode ? 'text-blue-400' : 'text-slate-700'}`}>{t('contacts')}</button>
                                    <button onClick={() => setView('add')} className={`hover:opacity-80 font-medium transition ${messagesDarkMode ? 'text-blue-400' : 'text-slate-700'}`}>{t('add')}</button>
                                    <button onClick={() => setView('profile')} className={`hover:opacity-80 font-medium transition ${messagesDarkMode ? 'text-blue-400' : 'text-slate-700'}`}>{t('profile')}</button>
                                    <span className={`flex-1 text-right font-mono ${messagesDarkMode ? 'text-gray-500' : 'text-gray-400'} select-all text-[10px]`}>{myCode}</span>
                                </div>
                            </>
                        )}

                        <div className={`flex-1 ${messagesDarkMode ? 'bg-[#0a0a0a] text-white' : 'msn-surface'} p-4 overflow-y-auto relative`}>
                            {view === 'profile' && (
                                <div className="p-3 space-y-4">
                                <h3 className="font-bold text-lg mb-2">{t('myProfile')}</h3>
                                    <div className="flex items-center gap-4">
                                        <button
                                            onClick={() => setAvatarZoom({ src: avatarSrc(user.uid, profile.avatar), name: profile.username || 'Ich' })}
                                            className={`w-16 h-16 ${messagesDarkMode ? 'border-white/10 bg-black' : 'border-gray-200 bg-white'} border-2 rounded-2xl overflow-hidden shadow-lg hover:scale-105 transition`}
                                            title={t('clickToZoom')}
                                        >
                                            <img src={avatarSrc(user.uid, profile.avatar)} className="w-full h-full object-cover"/>
                                        </button>
                                        <div className="flex-1">
                                            <div className={`text-xs font-medium mb-1.5 ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>{t('displayName')}</div>
                                            <input value={profile.username} onChange={e => setProfile(p => ({ ...p, username: e.target.value }))} className={`border p-2.5 w-full text-sm rounded-xl ${messagesDarkMode ? 'bg-white/5 border-white/10 text-white focus:border-blue-500' : 'bg-white border-gray-200 text-black focus:border-blue-500'} outline-none transition`} placeholder={t('name')}/>
                                        </div>
                                    </div>

                                    <div>
                                        <div className={`text-xs font-medium mb-1.5 ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>{t('statusText')}</div>
                                        <input value={profile.statusText} onChange={e => setProfile(p => ({ ...p, statusText: e.target.value }))} className={`border p-2.5 w-full text-sm rounded-xl ${messagesDarkMode ? 'bg-white/5 border-white/10 text-white focus:border-blue-500' : 'bg-white border-gray-200 text-black focus:border-blue-500'} outline-none transition`} placeholder={t('statusTextPlaceholder')}/>
                                    </div>

                                    <div>
                                        <div className={`text-xs font-medium mb-1.5 ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>{t('bio')}</div>
                                        <textarea value={profile.bio} onChange={e => setProfile(p => ({ ...p, bio: e.target.value }))} className={`border p-2.5 w-full text-sm rounded-xl resize-none ${messagesDarkMode ? 'bg-white/5 border-white/10 text-white focus:border-blue-500' : 'bg-white border-gray-200 text-black focus:border-blue-500'} outline-none transition`} placeholder={t('bioPlaceholder')} rows="3"/>
                                    </div>

                                    <div className="flex items-center gap-3">
                                        <label className={`cursor-pointer px-4 py-2 text-sm rounded-xl font-medium transition ${messagesDarkMode ? 'bg-white/5 border border-white/10 hover:bg-white/10 active:bg-white/15' : 'bg-slate-100 border border-gray-200 hover:bg-slate-200 active:bg-slate-300'}`}>
                                            {t('changeAvatar')}
                                            <input type="file" accept="image/*" className="hidden" onChange={handleAvatarUpload}/>
                                        </label>
                                        <button onClick={() => setProfile(p => ({ ...p, avatar: '' }))} className={`text-sm font-medium ${messagesDarkMode ? 'text-blue-400 hover:text-blue-300' : 'text-blue-600 hover:text-blue-700'} transition`}>{t('defaultLabel')}</button>
                                    </div>

                                    <div className={`border-t pt-4 mt-2 ${messagesDarkMode ? 'border-white/5' : 'border-gray-200'}`}>
                                        <div className={`text-xs font-medium mb-3 ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>{t('designSettings')}</div>
                                        <label className={`flex items-center gap-3 cursor-pointer p-3 rounded-xl border transition ${messagesDarkMode ? 'bg-white/5 border-white/10 hover:bg-white/8' : 'bg-slate-50 border-gray-200 hover:bg-slate-100'}`}>
                                            <input 
                                                type="checkbox" 
                                                checked={messagesDarkMode} 
                                                onChange={(e) => setMessagesDarkMode(e.target.checked)}
                                                className="w-4 h-4 rounded"
                                            />
                                            <span className="text-sm flex-1 font-medium">{t('amoledToggle')}</span>
                                            <Moon size={14} className="opacity-40"/>
                                        </label>
                                        <div className={`text-[10px] mt-1.5 ml-7 ${messagesDarkMode ? 'text-gray-600' : 'text-gray-400'}`}>{t('amoledHint')}</div>
                                    </div>

                                    <div className={`border-t pt-4 mt-4 ${messagesDarkMode ? 'border-white/5' : 'border-gray-200'}`}>
                                        <div className={`text-xs font-medium mb-3 ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>{t('notificationSettings')}</div>
                                        <label className={`flex items-center gap-3 cursor-pointer p-3 rounded-xl border transition ${messagesDarkMode ? 'bg-white/5 border-white/10 hover:bg-white/8' : 'bg-slate-50 border-gray-200 hover:bg-slate-100'}`}>
                                            <input
                                                type="checkbox"
                                                checked={(notificationPrefs?.friendRequests !== false)}
                                                onChange={(e) => saveNotificationPrefs && saveNotificationPrefs({ ...(notificationPrefs || {}), friendRequests: e.target.checked })}
                                                className="w-4 h-4 rounded"
                                            />
                                            <span className="text-sm flex-1 font-medium">{t('notificationFriendRequests')}</span>
                                            <UserPlus size={14} className="opacity-40"/>
                                        </label>
                                        <label className={`mt-2 flex items-center gap-3 cursor-pointer p-3 rounded-xl border transition ${messagesDarkMode ? 'bg-white/5 border-white/10 hover:bg-white/8' : 'bg-slate-50 border-gray-200 hover:bg-slate-100'}`}>
                                            <input
                                                type="checkbox"
                                                checked={(notificationPrefs?.chatMessages !== false)}
                                                onChange={(e) => saveNotificationPrefs && saveNotificationPrefs({ ...(notificationPrefs || {}), chatMessages: e.target.checked })}
                                                className="w-4 h-4 rounded"
                                            />
                                            <span className="text-sm flex-1 font-medium">{t('notificationChatMessages')}</span>
                                            <MessageCircle size={14} className="opacity-40"/>
                                        </label>
                                        <div className={`text-[10px] mt-1.5 ml-7 ${messagesDarkMode ? 'text-gray-600' : 'text-gray-400'}`}>Diese Einstellungen steuern die Popups/Toasts auch im Secret-Chat.</div>
                                    </div>


                                    <div className="flex gap-3 pt-3">
                            <button onClick={() => setView('list')} className={`text-sm font-medium ${messagesDarkMode ? 'text-blue-400' : 'text-blue-600'}`}>{t('back')}</button>
                                        <button onClick={saveMyProfile} disabled={savingProfile} className={`ml-auto px-5 py-2 text-sm font-semibold rounded-xl transition disabled:opacity-50 ${messagesDarkMode ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-slate-900 text-white hover:bg-slate-800'}`}>
                                            {savingProfile ? t('saving') : t('save')}
                                        </button>
                                    </div>
                                </div>
                            )}

                            {view === 'list' && (
                                <>
                                    <div className={`flex items-center gap-3 mb-4 p-3.5 rounded-2xl shadow-sm transition ${messagesDarkMode ? 'bg-white/5 border border-white/5' : 'border border-slate-200/80 bg-white/80 backdrop-blur-sm'}`}>
                                        <button
                                            onClick={() => setAvatarZoom({ src: avatarSrc(user.uid, profile.avatar), name: profile.username || (user.email?.split('@')[0] || 'Gast') })}
                                            className={`w-12 h-12 rounded-2xl overflow-hidden shadow-md hover:scale-105 transition ${messagesDarkMode ? 'border border-white/10' : 'border border-gray-200'}`}
                                            title={t('clickToZoom')}
                                        >
                                            <img src={avatarSrc(user.uid, profile.avatar)} className="w-full h-full object-cover"/>
                                        </button>
                                        <div className="min-w-0 flex-1">
                                            <div className={`text-sm font-bold truncate ${messagesDarkMode ? 'text-white' : 'text-black'}`}>{profile.username || (user.email?.split('@')[0] || "Gast")}</div>
                                            <div className="text-xs text-green-500 flex items-center gap-1.5 mt-0.5">
                                                <div className="w-2 h-2 rounded-full bg-green-500 shadow-sm shadow-green-500/50"></div> Online
                                            </div>
                                            {profile.statusText && <div className={`text-[11px] truncate mt-0.5 ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>"{profile.statusText}"</div>}
                                        </div>
                                    </div>

                                    {requests.length > 0 && (
                                        <div className={`mb-3 p-3 rounded-2xl text-xs ${messagesDarkMode ? 'bg-amber-900/20 border border-amber-500/20 text-amber-200' : 'bg-amber-50 border border-amber-200 text-amber-900'}`}>
                                            <div className="font-bold mb-2 flex items-center gap-1.5"><AlertCircle size={12}/> {requests.length} {t('requests')}</div>
                                            {requests.map(r => (
                                                <div key={r.id} className="flex justify-between items-center mt-1.5">
                                                    <span className="truncate">{r.fromName}</span>
                                                    <button onClick={() => acceptRequest(r)} className={`font-semibold ${messagesDarkMode ? 'text-blue-400' : 'text-blue-600'}`}>{t('accept')}</button>
                                                </div>
                                            ))}
                                        </div>
                                    )}

                                    <div className={`mb-3 flex gap-2 text-[10px] pb-3 ${messagesDarkMode ? 'border-b border-white/5' : 'border-b border-slate-200'}`}>
                                        <button onClick={() => handleSortChange('status')} className={`px-3 py-1.5 rounded-full text-[10px] font-semibold transition ${friendSortMode === 'status' ? (messagesDarkMode ? 'bg-blue-600 text-white' : 'bg-slate-900 text-white') : (messagesDarkMode ? 'bg-white/5 text-gray-400' : 'bg-slate-100 text-slate-600')}`}>Status</button>
                                        <button onClick={() => handleSortChange('alpha')} className={`px-3 py-1.5 rounded-full text-[10px] font-semibold transition ${friendSortMode === 'alpha' ? (messagesDarkMode ? 'bg-blue-600 text-white' : 'bg-slate-900 text-white') : (messagesDarkMode ? 'bg-white/5 text-gray-400' : 'bg-slate-100 text-slate-600')}`}>{t('sortAlpha')}</button>
                                        <button onClick={() => handleSortChange('lastActive')} className={`px-3 py-1.5 rounded-full text-[10px] font-semibold transition ${friendSortMode === 'lastActive' ? (messagesDarkMode ? 'bg-blue-600 text-white' : 'bg-slate-900 text-white') : (messagesDarkMode ? 'bg-white/5 text-gray-400' : 'bg-slate-100 text-slate-600')}`}>{t('lastActive')}</button>
                                    </div>

                                    <div className={`text-[11px] font-bold uppercase tracking-wider mb-2 ${messagesDarkMode ? 'text-green-400/60' : 'text-green-600/60'}`}>{t('online')} ({sortedOnline.length})</div>
                                    <div className="space-y-0.5">
                                        {sortedOnline.map(c => (
                                            <div key={c.id} className={`contact-card flex items-center gap-3 p-2.5 text-sm rounded-xl ${messagesDarkMode ? 'text-white hover:bg-white/5' : 'text-slate-900 hover:bg-blue-50/50'}`}>
                                                <button
                                                    onClick={(e) => { e.stopPropagation(); setAvatarZoom({ src: avatarSrc(c.friendId, c.avatar), name: c.name }); }}
                                                    className={`w-9 h-9 rounded-xl overflow-hidden shadow-sm hover:scale-105 transition ${messagesDarkMode ? 'border border-white/10' : 'border border-gray-200'}`}
                                                    title={t('zoomProfileImage')}
                                                >
                                                    <img src={avatarSrc(c.friendId, c.avatar)} className="w-full h-full object-cover" />
                                                </button>
                                                <div className="w-2.5 h-2.5 rounded-full bg-green-500 shadow-sm shadow-green-500/50"></div>
                                                <div className="min-w-0 flex-1 cursor-pointer" onClick={() => { setActiveConversation(c); loadMessageSettings(c); setView('message'); }}>
                                                    <div className="truncate font-medium">{c.name}</div>
                                                    {c.statusText && <div className={`text-[10px] truncate ${messagesDarkMode ? 'text-gray-500' : 'text-gray-400'}`}>"{c.statusText}"</div>}
                                                </div>
                                                <button onClick={(e) => { e.stopPropagation(); viewFriendProfile(c); }} className={`p-1.5 rounded-lg transition ${messagesDarkMode ? 'hover:bg-white/10' : 'hover:bg-blue-100'}`} title={t('showProfile')}>
                                                    <User size={14} className={messagesDarkMode ? 'text-blue-400' : 'text-blue-600'} />
                                                </button>
                                            </div>
                                        ))}
                                    </div>

                                    <div className={`text-[11px] font-bold uppercase tracking-wider mb-2 mt-5 ${messagesDarkMode ? 'text-gray-500' : 'text-slate-400'}`}>{t('offline')} ({sortedOffline.length})</div>
                                    <div className="space-y-0.5">
                                        {sortedOffline.map(c => (
                                            <div key={c.id} className={`contact-card flex items-center gap-3 p-2.5 text-sm rounded-xl ${messagesDarkMode ? 'text-gray-400 hover:bg-white/5' : 'text-slate-500 hover:bg-slate-50'}`}>
                                                <button
                                                    onClick={(e) => { e.stopPropagation(); setAvatarZoom({ src: avatarSrc(c.friendId, c.avatar), name: c.name }); }}
                                                    className={`w-9 h-9 rounded-xl overflow-hidden opacity-60 hover:opacity-100 transition ${messagesDarkMode ? 'border border-white/5' : 'border border-gray-200'}`}
                                                    title={t('zoomProfileImage')}
                                                >
                                                    <img src={avatarSrc(c.friendId, c.avatar)} className="w-full h-full object-cover" />
                                                </button>
                                                <div className={`w-2.5 h-2.5 rounded-full ${messagesDarkMode ? 'bg-gray-600' : 'bg-gray-300'}`}></div>
                                                <div className="min-w-0 flex-1 cursor-pointer" onClick={() => { setActiveConversation(c); loadMessageSettings(c); setView('message'); }}>
                                                    <div className="truncate font-medium">{c.name}</div>
                                                    {c.statusText && <div className={`text-[10px] truncate ${messagesDarkMode ? 'text-gray-600' : 'text-gray-400'}`}>"{c.statusText}"</div>}
                                                </div>
                                                <button onClick={(e) => { e.stopPropagation(); viewFriendProfile(c); }} className={`p-1.5 rounded-lg transition ${messagesDarkMode ? 'hover:bg-white/10' : 'hover:bg-slate-200'}`} title={t('showProfile')}>
                                                    <User size={14} className={messagesDarkMode ? 'text-gray-500' : 'text-gray-400'} />
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                    
                                    {/* Groups section */}
                                    <div className={`text-[11px] font-bold uppercase tracking-wider mb-2 mt-5 flex items-center gap-2 ${messagesDarkMode ? 'text-indigo-400/60' : 'text-indigo-500/60'}`}>
                                        {t('groups')} ({groups.length})
                                        <button onClick={() => setView('createGroup')} className={`ml-auto font-semibold normal-case text-xs flex items-center gap-1 px-2.5 py-1 rounded-lg transition ${messagesDarkMode ? 'text-blue-400 hover:bg-white/5' : 'text-blue-600 hover:bg-blue-50'}`} title={t('createGroup')}>
                                            <Users size={12}/> {t('newLabel')}
                                        </button>
                                    </div>
                                    <div className="space-y-0.5">
                                        {groups.map(g => (
                                            <div key={g.id} className={`contact-card flex items-center gap-3 p-2.5 text-sm rounded-xl cursor-pointer ${messagesDarkMode ? 'text-white hover:bg-white/5' : 'text-slate-900 hover:bg-indigo-50/50'}`} onClick={() => { setActiveConversation(g); loadMessageSettings(g); setView('message'); }}>
                                                <div className="w-9 h-9 rounded-xl bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center text-white text-xs font-bold shadow-md shadow-indigo-500/20">
                                                    {g.name.substring(0, 2).toUpperCase()}
                                                </div>
                                                <div className="min-w-0 flex-1">
                                                    <div className="truncate font-semibold">{g.name}</div>
                                                    <div className={`text-[10px] ${messagesDarkMode ? 'text-gray-500' : 'text-gray-400'}`}>{g.members.length} Mitglieder</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </>
                            )}
                            
                            {view === 'createGroup' && (
                                    <div className={`p-3 ${messagesDarkMode ? 'text-white' : 'text-slate-900'}`}>
                                    <h3 className="font-bold text-lg mb-3 flex items-center gap-2">
                                        <Users size={16}/>
                                        {t('createGroup')}
                                    </h3>
                                    <div className="mb-4">
                                        <label className={`text-xs font-medium block mb-1.5 ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>{t('groupName')}</label>
                                        <input 
                                            value={groupName} 
                                            onChange={e => setGroupName(e.target.value)} 
                                            placeholder={t('groupNamePlaceholder')} 
                                            className={`p-2.5 w-full text-sm rounded-xl outline-none transition ${messagesDarkMode ? 'bg-white/5 border border-white/10 text-white focus:border-blue-500' : 'bg-white border border-slate-200 focus:border-blue-500'}`}
                                        />
                                    </div>
                                    <div className="mb-4">
                                        <label className={`text-xs font-medium block mb-1.5 ${messagesDarkMode ? 'text-gray-400' : 'text-gray-500'}`}>{t('groupMembers')}</label>
                                        <div className={`rounded-2xl p-2 max-h-48 overflow-y-auto space-y-0.5 ${messagesDarkMode ? 'bg-white/5 border border-white/10' : 'bg-slate-50 border border-slate-200'}`}>
                                            {contacts.map(c => (
                                                <label key={c.id} className={`flex items-center gap-3 p-2.5 rounded-xl cursor-pointer transition ${messagesDarkMode ? 'hover:bg-white/5' : 'hover:bg-white'}`}>
                                                    <input 
                                                        type="checkbox"
                                                        checked={selectedGroupMembers.includes(c.friendId)}
                                                        onChange={(e) => {
                                                            if (e.target.checked) {
                                                                setSelectedGroupMembers(prev => [...prev, c.friendId]);
                                                            } else {
                                                                setSelectedGroupMembers(prev => prev.filter(id => id !== c.friendId));
                                                            }
                                                        }}
                                                        className="rounded"
                                                    />
                                                    <img src={avatarSrc(c.friendId, c.avatar)} className="w-7 h-7 rounded-lg border border-slate-200"/>
                                                    <span className="text-sm font-medium">{c.name}</span>
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                    <div className="flex gap-3 items-center">
                        <button onClick={() => setView('list')} className={`text-sm font-medium ${messagesDarkMode ? 'text-blue-400' : 'text-blue-600'}`}>{t('back')}</button>
                                        <button 
                                            onClick={createGroup} 
                                            disabled={!groupName.trim() || selectedGroupMembers.length < 2}
                                            className={`ml-auto px-5 py-2 text-sm font-semibold rounded-xl transition disabled:opacity-40 disabled:cursor-not-allowed ${messagesDarkMode ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-slate-900 text-white hover:bg-slate-800'}`}
                                        >
                                            {t('create')}
                                        </button>
                                    </div>
                                </div>
                            )}

                            {view === 'add' && (
                                <div className={`p-3 ${messagesDarkMode ? 'text-white' : 'text-slate-900'}`}>
                                    <h3 className="font-bold text-lg mb-3">{t('addFriendTitle')}</h3>
                                    <input value={addCode} onChange={e => setAddCode(e.target.value)} placeholder={t('shareCodePlaceholder')} className={`p-2.5 w-full mb-3 text-sm rounded-xl outline-none transition ${messagesDarkMode ? 'bg-white/5 border border-white/10 text-white focus:border-blue-500' : 'bg-white border border-slate-200 focus:border-blue-500'}`}/>
                                    <div className="flex gap-3 items-center">
                                        <button onClick={() => setView('list')} className={`text-sm font-medium ${messagesDarkMode ? 'text-blue-400' : 'text-blue-600'}`}>{t('back')}</button>
                                        <button onClick={sendRequest} className={`ml-auto px-5 py-2 text-sm font-semibold rounded-xl transition ${messagesDarkMode ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-slate-900 text-white hover:bg-slate-800'}`}>{t('send')}</button>
                                    </div>
                                </div>
                            )}

                            {view === 'friendProfile' && viewingFriendProfile && (
                                    <div className={`p-3 space-y-4 ${messagesDarkMode ? 'text-white' : 'text-slate-900'}`}>
                                    <div className="flex items-center justify-between mb-2">
                                        <h3 className="font-bold text-lg">{t('friendProfileTitle')}</h3>
                                        <button onClick={() => setView('list')} className={`text-sm font-medium ${messagesDarkMode ? 'text-blue-400' : 'text-blue-600'}`}>{t('back')}</button>
                                    </div>
                                    <div className={`flex items-center gap-4 p-4 rounded-2xl ${messagesDarkMode ? 'bg-white/5 border border-white/5' : 'bg-gradient-to-b from-white to-slate-50 border border-slate-200'}`}>
                                        <button
                                            onClick={() => setAvatarZoom({ src: avatarSrc(viewingFriendProfile.friendId, viewingFriendProfile.avatar), name: viewingFriendProfile.username })}
                                            className={`w-16 h-16 rounded-2xl overflow-hidden shadow-lg hover:scale-105 transition ${messagesDarkMode ? 'border border-white/10' : 'border border-gray-200'}`}
                                            title={t('clickToZoom')}
                                        >
                                            <img src={avatarSrc(viewingFriendProfile.friendId, viewingFriendProfile.avatar)} className="w-full h-full object-cover"/>
                                        </button>
                                        <div className="flex-1">
                                            <div className="font-bold text-lg">{viewingFriendProfile.username}</div>
                                            <div className="text-xs flex items-center gap-1.5 mt-1">
                                                <div className={`w-2.5 h-2.5 rounded-full ${viewingFriendProfile.status === 'online' ? 'bg-green-500 shadow-sm shadow-green-500/50' : (messagesDarkMode ? 'bg-gray-600' : 'bg-gray-300')}`}></div>
                                                <span className={viewingFriendProfile.status === 'online' ? 'text-green-500' : (messagesDarkMode ? 'text-gray-500' : 'text-gray-400')}>
                                                    {viewingFriendProfile.status === 'online' ? t('online') : t('offline')}
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                    {viewingFriendProfile.statusText && (
                                        <div className={`p-3 rounded-2xl ${messagesDarkMode ? 'bg-blue-500/10 border border-blue-500/20' : 'bg-blue-50 border border-blue-200'}`}>
                                            <div className={`text-[10px] uppercase font-bold mb-1 ${messagesDarkMode ? 'text-blue-400/60' : 'text-blue-500/60'}`}>{t('status')}</div>
                                            <div className="text-sm">"{viewingFriendProfile.statusText}"</div>
                                        </div>
                                    )}
                                    {viewingFriendProfile.bio && (
                                        <div className={`p-3 rounded-2xl ${messagesDarkMode ? 'bg-purple-500/10 border border-purple-500/20' : 'bg-purple-50 border border-purple-200'}`}>
                                            <div className={`text-[10px] uppercase font-bold mb-1 ${messagesDarkMode ? 'text-purple-400/60' : 'text-purple-500/60'}`}>{t('bio')}</div>
                                            <div className="text-sm whitespace-pre-wrap">{viewingFriendProfile.bio}</div>
                                        </div>
                                    )}
                                    <div className={`p-4 rounded-2xl space-y-3 ${messagesDarkMode ? 'bg-emerald-500/10 border border-emerald-500/20' : 'bg-emerald-50 border border-emerald-200'}`}>
                                        <div className="flex items-center gap-2">
                                            <Shield size={12} className={messagesDarkMode ? 'text-emerald-400' : 'text-green-600'}/>
                                            <span className={`text-[10px] font-bold uppercase tracking-wider ${messagesDarkMode ? 'text-emerald-400/70' : 'text-green-700'}`}>{t('securitySettings')}</span>
                                        </div>
                                        <label className="flex items-center gap-3 text-xs cursor-pointer">
                                            <input 
                                                type="checkbox"
                                                checked={readOnceMode}
                                                onChange={(e) => {
                                                    const next = { readOnce: e.target.checked, expiry: messageExpiry };
                                                    setReadOnceMode(next.readOnce);
                                                    saveMessageSettings(viewingFriendProfile.friendId, next);
                                                }}
                                                className="rounded"
                                            />
                                            <span>{t('deleteAfterRead')}</span>
                                        </label>
                                        <div>
                                            <label className={`text-[10px] uppercase font-bold tracking-wider ${messagesDarkMode ? 'text-emerald-400/60' : 'text-gray-500'}`}>{t('expiry')}</label>
                                            <select 
                                                value={messageExpiry} 
                                                onChange={(e) => {
                                                    const next = { readOnce: readOnceMode, expiry: e.target.value };
                                                    setMessageExpiry(next.expiry);
                                                    saveMessageSettings(viewingFriendProfile.friendId, next);
                                                }}
                                                className={`w-full rounded-xl px-3 py-2 text-xs mt-1 outline-none ${messagesDarkMode ? 'bg-white/5 border border-white/10 text-white' : 'bg-white border border-gray-200'}`}
                                            >
                                                <option value="24h">{t('expiry24h')}</option>
                                                <option value="7d">{t('expiry7d')}</option>
                                                <option value="never">{t('expiryNever')}</option>
                                            </select>
                                        </div>
                                        <div className={`text-[10px] ${messagesDarkMode ? 'text-gray-500' : 'text-gray-400'}`}>{t('settingsApplyTo')} {viewingFriendProfile.username}.</div>
                                    </div>
                                    <button 
                                        onClick={() => { setActiveConversation(viewingFriendProfile); loadMessageSettings(viewingFriendProfile); setView('message'); }} 
                                        className={`w-full p-3.5 rounded-2xl font-bold flex items-center justify-center gap-2 transition shadow-lg ${messagesDarkMode ? 'bg-blue-600 text-white hover:bg-blue-700 shadow-blue-500/20' : 'bg-blue-500 text-white hover:bg-blue-600 shadow-blue-500/20'}`}
                                    >
                                        <MessageCircle size={16} /> {t('sendMessage')}
                                    </button>
                                </div>
                            )}

                            {view === 'message' && activeConversation && (
                                <div className="flex flex-col h-full">
                                    <div className={`flex items-center gap-3 pb-3 mb-3 ${messagesDarkMode ? 'border-b border-white/5' : 'border-b border-slate-200'}`}>
                                        <button onClick={() => setView('list')} className={`p-1.5 rounded-lg transition ${messagesDarkMode ? 'text-white hover:bg-white/10' : 'text-slate-700 hover:bg-slate-100'}`}><ArrowLeft size={16} /></button>
                                                <button
                                                    onClick={() => activeConversation.isGroup 
                                                        ? null 
                                                        : setAvatarZoom({ src: avatarSrc(activeConversation.friendId, activeConversation.avatar), name: activeConversation.name })}
                                                    className={`w-10 h-10 rounded-2xl overflow-hidden shadow-sm ${activeConversation.isGroup ? 'bg-gradient-to-br from-blue-500 to-indigo-600 flex items-center justify-center text-white text-xs font-bold' : (messagesDarkMode ? 'border border-white/10' : 'border border-slate-200')}`}
                                                    title={activeConversation.isGroup ? t('groupLabel') : t('zoomProfileImage')}
                                                >
                                            {activeConversation.isGroup 
                                                ? activeConversation.name.substring(0, 2).toUpperCase()
                                                : <img src={avatarSrc(activeConversation.friendId, activeConversation.avatar)} className="w-full h-full object-cover"/>
                                            }
                                        </button>
                                        <div className="flex-1 min-w-0">
                                            <div className={`font-semibold text-sm truncate ${messagesDarkMode ? 'text-white' : 'text-slate-900'}`}>
                                                {activeConversation.name}
                                            </div>
                                        </div>
                                    </div>
                                    <div className={`flex-1 overflow-y-auto space-y-3 p-4 rounded-2xl border ${messagesDarkMode ? 'chat-shell-dark border-white/5' : 'chat-shell-light border-slate-200/50'}`}>
                                        {hasMoreMessages && (
                                            <button 
                                                onClick={() => setMessageLimit(prev => prev + MESSAGE_BATCH_SIZE)} 
                                                className={`w-full py-2.5 mb-2 rounded-xl text-xs font-bold transition ${messagesDarkMode ? 'bg-blue-500/10 text-blue-400 hover:bg-blue-500/20' : 'bg-blue-500/10 text-blue-600 hover:bg-blue-500/20'}`}
                                            >
                                                {t('loadMoreMessages')}
                                            </button>
                                        )}
                                        {messages.map((m) => {
                                            const isOwn = m.from === user.uid;
                                            const isRead = m.readBy && activeConversation.isGroup 
                                                ? m.readBy.length > 1 // For groups, show if read by others
                                                : m.readBy.includes(activeConversation.friendId);
                                            const isDeleted = m.deleted;
                                            const isEncrypted = m.encrypted;
                                            
                                            return (
                                                    <div key={m.id} data-message-id={m.id} ref={(el) => { messageRefs.current[m.id] = el; }} className={`text-sm ${isOwn ? (messagesDarkMode ? 'text-white' : 'text-slate-900') : (messagesDarkMode ? 'text-gray-300' : 'text-slate-700')} relative group ${isOwn ? 'msg-animate-right' : 'msg-animate-left'}`}>
                                                        <div className={`flex items-start gap-2 ${isOwn ? 'justify-end' : 'justify-start'}`}>
                                                            <div className="flex-1">
                                                                <div className={`flex items-center gap-2 mb-1 text-[11px] ${messagesDarkMode ? 'text-gray-500' : 'text-slate-400'}`}>
                                                                    <span className={`font-semibold ${messagesDarkMode ? 'text-gray-400' : 'text-slate-500'}`}>{isOwn ? t('meLabel') : (activeConversation.isGroup ? '...' : activeConversation.name)}</span>
                                                                    {isEncrypted && <Shield size={10} className="text-emerald-400" title={t('encryptedLabel')}/>}
                                                                    {m.readOnce && <Eye size={10} className="text-amber-400" title={t('readOnceLabel')}/>}
                                                                    {m.expiresAt && (
                                                                        <Clock size={10} className="text-blue-400" title={`${t('expiresAtLabel')} ${new Date(toMillis(m.expiresAt)).toLocaleString(getCurrentLocale())}`}/>
                                                                    )}
                                                                    {m.ts && (
                                                                        <span className={`text-[10px] ${messagesDarkMode ? 'text-gray-600' : 'text-slate-400'}`}>
                                                                            {new Date(toMillis(m.ts)).toLocaleTimeString(getCurrentLocale(), { hour: '2-digit', minute: '2-digit' })}
                                                                        </span>
                                                                    )}
                                                                </div>
                                                                <div className={`max-w-[75%] chat-message ${isOwn ? 'ml-auto' : ''} ${messagesDarkMode ? (isOwn ? 'chat-message-own-dark' : 'chat-message-other-dark') : (isOwn ? 'chat-message-own-light' : 'chat-message-other-light')}`}>
                                                                    {m.replyTo && (
                                                                        <button
                                                                            type="button"
                                                                            onClick={() => scrollToMessage(m.replyTo.messageId)}
                                                                            className={`text-[10px] text-left w-full ${isOwn ? 'text-blue-100' : 'text-slate-500'} border-l-2 ${isOwn ? 'border-blue-200' : 'border-slate-300'} pl-2 mb-1 italic`}
                                                                        >
                                                                            {t('replyToLabel')} {m.replyTo.text}
                                                                        </button>
                                                                    )}
                                                                    {isDeleted ? (
                                                                        <span className="text-xs opacity-60 italic">{t('deletedMessage')}</span>
                                                                    ) : m.img ? (
                                                                        <button onClick={() => openImageZoom(m)} className="block">
                                                                            <img src={m.img} className={`max-w-[200px] rounded-2xl border block shadow-sm hover:shadow-md transition ${isOwn ? 'border-white/20' : (messagesDarkMode ? 'border-white/5' : 'border-slate-200/50')}`} />
                                                                        </button>
                                                                    ) : (
                                                                        <span className="text-sm leading-relaxed">
                                                                            {formatMessageText(m.text).map((part, idx) => (
                                                                                part.type === 'link' ? (
                                                                                    <a
                                                                                        key={`${m.id}-link-${idx}`}
                                                                                        href={part.href}
                                                                                        target="_blank"
                                                                                        rel="noreferrer"
                                                                                        className={`underline ${messagesDarkMode ? 'text-blue-200' : 'text-blue-700'}`}
                                                                                    >
                                                                                        {part.value}
                                                                                    </a>
                                                                                ) : (
                                                                                    <span key={`${m.id}-text-${idx}`}>{part.value}</span>
                                                                                )
                                                                            ))}
                                                                        </span>
                                                                    )}
                                                                    {m.edited && !isDeleted && (
                                                                        <span className={`text-[9px] ${isOwn ? 'text-blue-100' : 'text-slate-400'} ml-2`}>{t('editedLabel')}</span>
                                                                    )}
                                                                {isOwn && !isDeleted && (
                                                                    <span className={`text-[10px] ml-2 ${isRead ? 'text-blue-200' : 'text-white/40'}`}>
                                                                        {isRead ? '‚úì‚úì' : '‚úì'}
                                                                    </span>
                                                                )}
                                                            </div>
                                                        </div>
                                                        {isOwn && !isDeleted && (
                                                            <div className="opacity-0 group-hover:opacity-100 flex gap-0.5 transition-opacity">
                                                                <button onClick={() => startReplyMsg(m)} className={`p-1 rounded-lg transition ${messagesDarkMode ? 'text-gray-500 hover:text-blue-400 hover:bg-white/5' : 'text-gray-400 hover:text-blue-600 hover:bg-blue-50'}`} title={t('replyAction')}>
                                                                    <ArrowLeft size={12} className="rotate-180" />
                                                                </button>
                                                                {!m.img && (
                                                                    <button onClick={() => startEditMsg(m)} className={`p-1 rounded-lg transition ${messagesDarkMode ? 'text-gray-500 hover:text-green-400 hover:bg-white/5' : 'text-gray-400 hover:text-green-600 hover:bg-green-50'}`} title={t('edit')}>
                                                                        <Edit3 size={12} />
                                                                    </button>
                                                                )}
                                                                <button onClick={() => deleteMsg(m.id)} className={`p-1 rounded-lg transition ${messagesDarkMode ? 'text-gray-500 hover:text-red-400 hover:bg-white/5' : 'text-gray-400 hover:text-red-600 hover:bg-red-50'}`} title={t('delete')}>
                                                                    <Trash2 size={12} />
                                                                </button>
                                                            </div>
                                                        )}
                                                        {!isOwn && !isDeleted && (
                                                            <div className="opacity-0 group-hover:opacity-100 transition-opacity">
                                                            <button onClick={() => startReplyMsg(m)} className={`p-1 rounded-lg transition ${messagesDarkMode ? 'text-gray-500 hover:text-blue-400 hover:bg-white/5' : 'text-gray-400 hover:text-blue-600 hover:bg-blue-50'}`} title={t('replyAction')}>
                                                                <ArrowLeft size={12} className="rotate-180" />
                                                            </button>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        <div ref={scrollRef}/>
                                    </div>
                                    {(editingMessage || replyingTo) && (
                                        <div className={`${messagesDarkMode ? 'bg-blue-500/10 border-t border-blue-500/20' : 'bg-blue-50/80 border-t border-blue-200/50'} p-2.5 text-xs flex items-center justify-between rounded-b-xl`}>
                                            <div className="flex-1">
                                                {editingMessage && <span className={messagesDarkMode ? 'text-blue-300' : 'text-blue-700'}>{t('editingMessage')}</span>}
                                                {replyingTo && <span className={messagesDarkMode ? 'text-blue-300' : 'text-blue-700'}>{t('replyToLabel')} {replyingTo.text || t('photo')}</span>}
                                            </div>
                                            <button onClick={() => { editingMessage ? cancelEdit() : cancelReply(); }} className={`p-1 rounded-lg transition ${messagesDarkMode ? 'text-gray-400 hover:text-red-400 hover:bg-white/5' : 'text-gray-400 hover:text-red-500 hover:bg-red-50'}`}>
                                                <X size={14} />
                                            </button>
                                        </div>
                                    )}
                                    <div className={`mt-3 pt-3 border-t flex gap-3 items-center p-3 rounded-2xl shadow-sm transition ${messagesDarkMode ? 'border-white/5 bg-white/5' : 'border-slate-200/50 bg-white/90 backdrop-blur-sm'}`}>
                                        <button onClick={openCamera} className={`p-2 rounded-xl transition ${messagesDarkMode ? 'text-gray-400 hover:text-white hover:bg-white/10' : 'text-slate-400 hover:text-slate-700 hover:bg-slate-100'}`} title={t('photoCapture')}><Camera size={18}/></button>
                                        <label className={`p-2 rounded-xl cursor-pointer transition ${messagesDarkMode ? 'text-gray-400 hover:text-white hover:bg-white/10' : 'text-slate-400 hover:text-slate-700 hover:bg-slate-100'}`} title={t('attachPhoto')}><Paperclip size={18}/><input ref={filePickerRef} type="file" accept="image/*" className="hidden" onChange={handlePhoto}/></label>
                                        <div className="flex-1">
                                            <input ref={inputRef} value={input} onChange={e => setInput(e.target.value)} onKeyDown={e => { if (e.key === 'Enter') { e.preventDefault(); sendMsg(); } }} className={`w-full p-2.5 text-sm rounded-xl focus:outline-none transition ${messagesDarkMode ? 'bg-white/5 text-white border border-white/10 focus:border-blue-500/50 placeholder-gray-600' : 'bg-slate-50 text-slate-900 border border-slate-200 focus:border-blue-400 placeholder-slate-400'}`} placeholder={t('writeMessagePlaceholder')}/>
                                            <div className={`${messagesDarkMode ? 'text-gray-600' : 'text-slate-400'} text-[10px] mt-1`}>{t('maxFileSizeLabel')} {MAX_IMAGE_SIZE_LABEL}</div>
                                        </div>
                                        <button onClick={() => sendMsg()} className={`px-4 py-2.5 rounded-xl text-sm font-semibold transition shadow-sm ${messagesDarkMode ? 'bg-blue-600 text-white hover:bg-blue-700 shadow-blue-500/20' : 'bg-slate-900 text-white hover:bg-slate-800 shadow-slate-900/20'}`}>{editingMessage ? t('save') : <Send size={16}/>}</button>
                                    </div>
                                </div>
                            )}
                        </div>
                        <div className={`py-1.5 text-[10px] text-center border-t ${messagesDarkMode ? 'bg-[#0a0a0a] text-gray-600 border-white/5' : 'bg-slate-50 text-gray-400 border-slate-200/50'}`}>TimeRoster Messenger ¬© 2026</div>
                    </div>
                </div>
            );
        };


        // --- SUB-COMPONENTS ---

        const AuthView = ({ setView }) => {
            const [isRegister, setIsRegister] = useState(false);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            const handleAuth = async () => {
                setError('');
                try {
                    if (isRegister) await createUserWithEmailAndPassword(auth, email, password);
                    else await signInWithEmailAndPassword(auth, email, password);
                } catch (e) { setError(e.message); }
            };

                const handleGuest = async () => {
                    setError('');
                    try { await signInAnonymously(auth); } 
                    catch (e) { if(e.code === 'auth/admin-restricted-operation') setError(t('guestAccessDisabled')); else setError(e.message); }
                };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen p-6 relative z-50">
                    <div className="w-full max-w-sm space-y-6">
                        <h1 className="text-4xl font-bold text-center mb-8 text-white font-cinzel">TimeRoster</h1>
                        <div className="bg-slate-900 p-6 rounded-2xl border border-slate-800 space-y-4 shadow-2xl">
                            <div className="flex bg-slate-800 p-1 rounded-lg">
                                <button onClick={() => setIsRegister(false)} className={`flex-1 py-2 rounded text-white ${!isRegister ? 'bg-blue-600' : 'text-slate-400'}`}>{t('signIn')}</button>
                                <button onClick={() => setIsRegister(true)} className={`flex-1 py-2 rounded text-white ${isRegister ? 'bg-blue-600' : 'text-slate-400'}`}>{t('register')}</button>
                            </div>
                            {error && <div className="bg-red-500/20 text-red-300 p-3 rounded text-xs">{error}</div>}

                            <input type="email" value={email} onChange={e=>setEmail(e.target.value)} className="w-full bg-slate-950 p-3 rounded border border-slate-800 text-white placeholder-slate-500" placeholder={t('emailPlaceholder')} />
                            <input type="password" value={password} onChange={e=>setPassword(e.target.value)} className="w-full bg-slate-950 p-3 rounded border border-slate-800 text-white placeholder-slate-500" placeholder={t('passwordPlaceholder')} />

                            <button onClick={handleAuth} className="w-full py-3 bg-blue-600 rounded font-bold text-white shadow-lg shadow-blue-900/20">{isRegister ? t('register') : t('signIn')}</button>
                        </div>
                        <button onClick={handleGuest} className="w-full py-3 bg-slate-800 rounded font-bold text-slate-300 hover:bg-slate-700">{t('guest')}</button>
                    </div>
                </div>
            );
        };


        // --- DAY VIEW ---
        const DayView = ({ events, selectedDate, onDateClick, themeClasses, isComic, onEventUpdate }) => {
            const dateStr = formatDate(selectedDate);
            const dayEvents = getEventsForDate(dateStr, events);
            const hours = Array.from({ length: 24 }, (_, i) => i);
            const [draggedEvent, setDraggedEvent] = useState(null);
            const [dragOverHour, setDragOverHour] = useState(null);

            const handleDragStart = (e, event) => {
                setDraggedEvent(event);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, hour) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                setDragOverHour(hour);
            };

            const handleDragLeave = () => {
                setDragOverHour(null);
            };

            const handleDrop = async (e, hour) => {
                e.preventDefault();
                setDragOverHour(null);
                
                if (draggedEvent && onEventUpdate) {
                    // Preserve minutes from original time, only change the hour
                    const oldTime = draggedEvent.time || '00:00';
                    const oldMinutes = oldTime.split(':')[1] || '00';
                    const newTime = String(hour).padStart(2, '0') + ':' + oldMinutes;
                    await onEventUpdate(draggedEvent, { time: newTime });
                }
                setDraggedEvent(null);
            };

            const handleDragEnd = () => {
                setDraggedEvent(null);
                setDragOverHour(null);
            };

            return (
                <div className="pb-32 h-full flex flex-col">
                    <div className={`flex justify-between items-center p-4 ${themeClasses.calendarHeader}`}>
                        <button onClick={() => {
                            const prev = new Date(selectedDate);
                            prev.setDate(prev.getDate() - 1);
                            onDateClick(prev);
                        }} className="p-2"><ChevronLeft /></button>
                        <h2 className="text-xl font-bold">{selectedDate.toLocaleDateString(getCurrentLocale(), { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}</h2>
                        <button onClick={() => {
                            const next = new Date(selectedDate);
                            next.setDate(next.getDate() + 1);
                            onDateClick(next);
                        }} className="p-2"><ChevronRight /></button>
                    </div>

                    <div className="flex-1 overflow-y-auto px-4">
                        {hours.map(hour => {
                            const hourStr = String(hour).padStart(2, '0') + ':00';
                            const hourEvents = dayEvents.filter(ev => {
                                const evHour = parseInt(ev.time?.split(':')[0] || '0');
                                return evHour === hour;
                            });

                            return (
                                <div 
                                    key={hour} 
                                    className={`border-b ${isComic ? 'border-[#8b5a2b]' : 'border-slate-700'} py-2 flex gap-2 transition-colors ${dragOverHour === hour ? 'bg-blue-500/20' : ''}`}
                                    onDragOver={(e) => handleDragOver(e, hour)}
                                    onDragLeave={handleDragLeave}
                                    onDrop={(e) => handleDrop(e, hour)}
                                >
                                    <div className="w-16 text-sm opacity-60 font-mono">{hourStr}</div>
                                    <div className="flex-1 space-y-1">
                                        {hourEvents.map((ev, idx) => {
                                            const cat = CATEGORIES.find(c => c.id === ev.category);
                                            const isFocusBlock = ev.category === 'focus';
                                            return (
                                                <div 
                                                    key={idx} 
                                                    draggable={true}
                                                    onDragStart={(e) => handleDragStart(e, ev)}
                                                    onDragEnd={handleDragEnd}
                                                    className={`p-3 rounded-lg cursor-move ${isFocusBlock ? 'ring-2 ring-purple-500' : ''} ${isComic ? 'bg-[#f4e4bc] border border-[#8b5a2b]' : 'bg-slate-800'} hover:opacity-80 transition-opacity`}
                                                    onClick={() => onDateClick(selectedDate, ev)}
                                                >
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-lg">{cat?.icon}</span>
                                                        <div className="flex-1">
                                                            <div className="font-bold text-sm">{ev.title}</div>
                                                            <div className="text-xs opacity-70">
                                                                {ev.time}
                                                                {ev.duration && ` ‚Ä¢ ${ev.duration}min`}
                                                                {ev.travelTime > 0 && ` ‚Ä¢ üöó ${ev.travelTime}min`}
                                                            </div>
                                                        </div>
                                                        {isFocusBlock && (
                                                            <span className="text-xs bg-purple-500/20 text-purple-400 px-2 py-1 rounded">Fokus</span>
                                                        )}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        {hourEvents.length === 0 && dragOverHour === hour && (
                                            <div className="text-xs opacity-40 text-center py-2">
                                                Hier ablegen
                                            </div>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- WEEK VIEW ---
        const WeekView = ({ events, selectedDate, onDateClick, themeClasses, isComic, forecastData }) => {
            const getWeekDays = (date) => {
                const curr = new Date(date);
                const first = curr.getDate() - curr.getDay() + 1; // Monday
                const days = [];
                for (let i = 0; i < 7; i++) {
                    const day = new Date(curr.setDate(first + i));
                    days.push(new Date(day));
                }
                return days;
            };

            const [weekStart, setWeekStart] = useState(getWeekDays(selectedDate)[0]);
            
            // Update weekStart when selectedDate changes
            useEffect(() => {
                setWeekStart(getWeekDays(selectedDate)[0]);
            }, [selectedDate]);

            const weekDays = getWeekDays(weekStart);

            const goToPrevWeek = () => {
                const prev = new Date(weekStart);
                prev.setDate(prev.getDate() - 7);
                setWeekStart(prev);
            };

            const goToNextWeek = () => {
                const next = new Date(weekStart);
                next.setDate(next.getDate() + 7);
                setWeekStart(next);
            };

            const weekEnd = new Date(weekDays[6]);
            const monthStr = weekStart.getMonth() === weekEnd.getMonth() 
                ? weekStart.toLocaleDateString(getCurrentLocale(), { month: 'long', year: 'numeric' })
                : `${weekStart.toLocaleDateString(getCurrentLocale(), { month: 'short' })} - ${weekEnd.toLocaleDateString(getCurrentLocale(), { month: 'long', year: 'numeric' })}`;

            return (
                <div className="pb-32 h-full flex flex-col">
                    <div className={`flex justify-between items-center p-4 ${themeClasses.calendarHeader}`}>
                        <button onClick={goToPrevWeek} className="p-2"><ChevronLeft /></button>
                        <h2 className="text-xl font-bold">{monthStr}</h2>
                        <button onClick={goToNextWeek} className="p-2"><ChevronRight /></button>
                    </div>

                    <div className="flex-1 overflow-y-auto">
                        <div className="grid grid-cols-8 gap-1 p-2">
                            <div className="text-center text-[10px] font-bold uppercase opacity-40 mb-2">KW</div>
                            {['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'].map((day, idx) => (
                                <div key={idx} className="text-center text-xs font-bold opacity-60 mb-2">{day}</div>
                            ))}
                        </div>
                        <div className="grid grid-cols-8 gap-1 p-2">
                            <div className="flex items-start justify-center pt-3 text-[10px] uppercase tracking-wide opacity-50">
                                KW {getISOWeekNumber(weekStart)}
                            </div>
                            {weekDays.map((day, idx) => {
                                const dateStr = formatDate(day);
                                const dayEvents = getEventsForDate(dateStr, events);
                                const isToday = dateStr === formatDate(new Date());
                                const isTomorrow = dateStr === getTomorrowStr();
                                const isOvermorrow = dateStr === getOvermorrowStr();
                                const dayForecast = getForecastForDate(forecastData, dateStr);
                                const dayForecastMin = dayForecast?.min;
                                const dayCategories = getDayCategories(dateStr, events);

                                return (
                                    <div key={idx} 
                                        className={getCalendarCellClasses({
                                            isToday,
                                            isTomorrow,
                                            isOvermorrow,
                                            dayCategories,
                                            baseClass: `p-2 rounded-lg cursor-pointer min-h-[100px] border ${isComic ? 'bg-[#f4e4bc] border-[#8b5a2b]' : 'bg-slate-800 border-white/10'}`
                                        })}
                                        onClick={() => onDateClick(day)}>
                                        <div className={`text-sm font-bold mb-1 ${isToday ? 'text-blue-400' : ''}`}>
                                            {day.getDate()}
                                        </div>
                                        {isValidTemperature(dayForecastMin) && (
                                            <div className="text-[10px] text-blue-400 leading-none">
                                                {Math.round(dayForecastMin)}¬∞
                                            </div>
                                        )}
                                        <div className="space-y-1">
                                            {dayEvents.slice(0, 3).map((ev, evIdx) => {
                                                const cat = CATEGORIES.find(c => c.id === ev.category);
                                                return (
                                                    <div key={evIdx} className="text-[9px] truncate flex items-center gap-1">
                                                        <span>{cat?.icon}</span>
                                                        <span className="truncate">{ev.title}</span>
                                                    </div>
                                                );
                                            })}
                                            {dayEvents.length > 3 && (
                                                <div className="text-[8px] opacity-60">+{dayEvents.length - 3}</div>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const CalendarView = ({ events, shifts, schedule, assignShift, onDateClick, onDateLongPress, viewingFriend, viewingFriendName, onSecretTrigger, themeClasses, isComic, currentUserId, secretPremiumUnlocked, forecastData, disableShiftInteractions }) => {
            const [currentDate, setCurrentDate] = useState(new Date());
            const [isPaintMode, setIsPaintMode] = useState(false);
            const [paintShiftId, setPaintShiftId] = useState(shifts[0]?.id || 'off'); 
            const [isDragging, setIsDragging] = useState(false);
            const titleTimer = useRef(null);
            const longPressTimer = useRef(null);
            const longPressTriggered = useRef(false);
            const [pulseTitle, setPulseTitle] = useState(false);
            const TITLE_TAP_WINDOW_MS = 3000;
            const TITLE_TAP_REQUIRED = 5;

            useEffect(() => {
                if (!paintShiftId || (paintShiftId !== 'eraser' && !shifts.find(s => s.id === paintShiftId))) {
                    setPaintShiftId(shifts[0]?.id || 'off');
                }
            }, [shifts]);

            // Filter events based on viewing mode
            const filteredEvents = useMemo(() => {
                if (!viewingFriend) {
                    // Own calendar - show all events
                    return events;
                }
                // Friend's calendar - only show approved events, or pending events created by current user
                return events.filter(ev => 
                    !ev.status || ev.status === 'approved' || (ev.status === 'pending' && ev.createdBy === (typeof currentUserId!=='undefined' ? currentUserId : (auth?.currentUser?.uid || null)))
                );
            }, [events, viewingFriend, auth?.currentUser?.uid]);

            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const daysInMonth = getDaysInMonth(year, month);
            const startOffset = getFirstDayOfMonth(year, month) === 0 ? 6 : getFirstDayOfMonth(year, month) - 1; 
            const days = [];
            for(let i=0; i<startOffset; i++) days.push(null);
            for(let i=1; i<=daysInMonth; i++) days.push(new Date(year, month, i));
            while (days.length % 7 !== 0) days.push(null);
            const weeks = [];
            for (let i = 0; i < days.length; i += 7) {
                weeks.push(days.slice(i, i + 7));
            }

            const monthStats = useMemo(() => {
                const stats = {};
                shifts.forEach(s => stats[s.id] = 0);
                days.forEach(d => {
                    if (d) {
                        const sId = schedule[formatDate(d)];
                        const shiftItems = Array.isArray(sId) ? sId : (sId ? [sId] : []);
                        shiftItems.forEach(item => {
                            const id = typeof item === 'string' ? item : item?.shiftId;
                            if (id && stats[id] !== undefined) stats[id]++;
                        });
                    }
                });
                return stats;
            }, [schedule, month, shifts]);

            const handleTouchMove = (e) => {
                if (!isPaintMode || !isDragging || viewingFriend || disableShiftInteractions) return;
                const t = e.touches[0];
                const target = document.elementFromPoint(t.clientX, t.clientY);
                if (target) {
                    const cell = target.closest('[data-date]');
                    if (cell) {
                        const dateStr = cell.getAttribute('data-date');
                        if (dateStr) assignShift(dateStr, paintShiftId === 'eraser' ? null : paintShiftId);
                    }
                }
            };

            const applyPaint = (dateStr) => assignShift(dateStr, paintShiftId === 'eraser' ? null : paintShiftId);
            const handlePaintStart = (dateStr, event) => {
                if (!isPaintMode || viewingFriend || disableShiftInteractions) return;
                if (event && event.button !== 0) return;
                setIsDragging(true);
                applyPaint(dateStr);
            };
            const handlePaintEnter = (dateStr) => {
                if (!isPaintMode || !isDragging || viewingFriend || disableShiftInteractions) return;
                applyPaint(dateStr);
            };
            const clearLongPress = () => {
                if (longPressTimer.current) {
                    clearTimeout(longPressTimer.current);
                    longPressTimer.current = null;
                }
            };
            const handleCellPointerDown = (dateStr, date, event) => {
                longPressTriggered.current = false;
                if (isPaintMode) {
                    handlePaintStart(dateStr, event);
                    return;
                }
                clearLongPress();
                longPressTimer.current = setTimeout(() => {
                    longPressTriggered.current = true;
                    onDateLongPress(date);
                }, 550);
            };
            const handleCellPointerUp = () => {
                clearLongPress();
            };

            const handleShiftCycle = (dateStr, shiftId) => {
                if (longPressTriggered.current) {
                    longPressTriggered.current = false;
                    return;
                }
                if (isPaintMode || isDragging || viewingFriend || disableShiftInteractions) return;
                if (Array.isArray(shiftId) && !shiftId.every(item => typeof item === 'string')) return;
                const currentId = Array.isArray(shiftId) ? (shiftId[0] || 'off') : (shiftId || 'off');
                const idx = shifts.findIndex(s => s.id === currentId);
                assignShift(dateStr, shifts[(idx + 1) % shifts.length].id);
            };

            const titleTapCount = useRef(0);
            const titleTapTimer = useRef(null);
            const handleTitleDown = () => { setPulseTitle(true); titleTimer.current = setTimeout(() => { onSecretTrigger(); setPulseTitle(false); }, 3000); };
            const handleTitleUp = () => { if (titleTimer.current) clearTimeout(titleTimer.current); setPulseTitle(false); };
            const handleTitleTap = () => {
                if (!titleTapTimer.current) {
                    titleTapTimer.current = setTimeout(() => {
                        titleTapCount.current = 0;
                        titleTapTimer.current = null;
                    }, TITLE_TAP_WINDOW_MS);
                }
                titleTapCount.current += 1;
                if (titleTapCount.current >= TITLE_TAP_REQUIRED) {
                    titleTapCount.current = 0;
                    if (titleTapTimer.current) {
                        clearTimeout(titleTapTimer.current);
                        titleTapTimer.current = null;
                    }
                    onSecretTrigger({ forceCodePrompt: true });
                }
            };

            return (
                <div className="pb-32 select-none h-full flex flex-col" onPointerUp={() => { setIsDragging(false); clearLongPress(); }} onMouseLeave={() => { setIsDragging(false); clearLongPress(); }}>
                    <div className={`flex justify-between items-center p-4 ${themeClasses.calendarHeader}`}>
                        <button onClick={() => setCurrentDate(new Date(year, month - 1, 1))} className="p-2"><ChevronLeft /></button>
                        <div 
                            className={`flex flex-col items-center cursor-pointer active:scale-95 transition-all select-none ${pulseTitle ? 'animate-pulse-soft text-blue-400' : ''}`}
                            onMouseDown={handleTitleDown} onMouseUp={handleTitleUp} onMouseLeave={handleTitleUp} onTouchStart={handleTitleDown} onTouchEnd={handleTitleUp}
                            onClick={handleTitleTap}
                        >
                            {viewingFriendName && <span className="text-sm opacity-70">Kalender von {viewingFriendName}</span>}
                            <h2 className="text-xl font-bold">{currentDate.toLocaleDateString(getCurrentLocale(), { month: 'long', year: 'numeric' })}</h2>
                            <span className="text-xs opacity-60 flex items-center gap-1"><BarChart2 size={10}/> {shifts.reduce((acc,s)=>acc+(monthStats[s.id]||0),0)} Schichten</span>
                        </div>
                        <button onClick={() => setCurrentDate(new Date(year, month + 1, 1))} className="p-2"><ChevronRight /></button>
                    </div>

                    {!viewingFriend && !disableShiftInteractions && (
                        <div className={`px-4 py-2 flex items-center justify-between gap-2 overflow-x-auto ${themeClasses.calendarToolbar}`}>
                            <button onClick={() => setIsPaintMode(!isPaintMode)} className={`p-2 rounded-lg flex items-center gap-2 text-xs font-bold transition-all ${isPaintMode ? 'bg-blue-600 text-white' : 'opacity-60'}`}><Edit3 size={14}/> {t('paintMode')}</button>
                            {isPaintMode && (
                                <div className="flex gap-1">
                                    <button onClick={() => setPaintShiftId('eraser')} className={`w-8 h-8 rounded-full border-2 flex items-center justify-center transition-all bg-slate-700/50 ${paintShiftId==='eraser' ? 'border-red-500 scale-110' : 'border-transparent opacity-50'}`}><Eraser size={14} className={paintShiftId==='eraser' ? 'text-red-400' : 'text-slate-400'}/></button>
                                    {shifts.map(s => <button key={s.id} onClick={() => setPaintShiftId(s.id)} className={`w-8 h-8 rounded-full border-2 flex items-center justify-center ${paintShiftId===s.id ? 'border-white scale-110 shadow-md' : 'border-transparent opacity-50'}`} style={{ backgroundColor: s.color }}>{paintShiftId === s.id && <CheckCircle size={14} className="text-white mix-blend-difference"/>}</button>)}
                                </div>
                            )}
                        </div>
                    )}

                    <div className={`grid grid-cols-8 text-center py-2 text-xs opacity-70 font-bold ${themeClasses.calendarWeek}`}>
                        <div className="text-[10px] uppercase opacity-40">KW</div>
                        {['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'].map(d => <div key={d}>{d}</div>)}
                    </div>
                    <div className="grid grid-cols-8 gap-1 px-2 touch-none flex-1 overflow-y-auto" style={{ touchAction: isPaintMode ? 'none' : 'auto' }} onTouchMove={handleTouchMove}>
                        {weeks.map((week, weekIndex) => {
                            const weekLabelDate = week.find(date => date);
                            return (
                                <React.Fragment key={`week-${weekIndex}`}>
                                    <div className="aspect-square flex items-start justify-center pt-2 text-[10px] uppercase tracking-wide opacity-50">
                                        {weekLabelDate ? `KW ${getISOWeekNumber(weekLabelDate)}` : ''}
                                    </div>
                                    {week.map((date, idx) => {
                                        if (!date) return <div key={`empty-${weekIndex}-${idx}`} className="aspect-square"></div>;
                                        const dateStr = formatDate(date);
                                        const shiftId = schedule[dateStr];
                                        const shiftItems = Array.isArray(shiftId) ? shiftId : (shiftId ? [shiftId] : []);
                                        const shiftIndicators = shiftItems.map(item => {
                                            const id = typeof item === 'string' ? item : item?.shiftId;
                                            return id ? shifts.find(s => s.id === id) : null;
                                        }).filter(Boolean);
                                        const primaryShift = shiftIndicators.length === 1 ? shiftIndicators[0] : null;
                                        const dayEvents = getEventsForDate(dateStr, filteredEvents);
                                        const isToday = dateStr === formatDate(new Date());
                                        const isTomorrow = dateStr === getTomorrowStr();
                                        const isOvermorrow = dateStr === getOvermorrowStr();
                                        const dayCategories = getDayCategories(dateStr, filteredEvents);
                                        const dayForecast = getForecastForDate(forecastData, dateStr);
                                        const dayForecastMin = dayForecast?.min;
                                        return (
                                            <div key={dateStr} data-date={dateStr}
                                                onPointerDown={(event) => handleCellPointerDown(dateStr, date, event)} onPointerUp={handleCellPointerUp} onPointerLeave={handleCellPointerUp}
                                                onPointerEnter={() => handlePaintEnter(dateStr)}
                                                onClick={() => handleShiftCycle(dateStr, shiftId)}
                                                className={getCalendarCellClasses({
                                                    isToday,
                                                    isTomorrow,
                                                    isOvermorrow,
                                                    dayCategories,
                                                    baseClass: `aspect-square relative rounded-lg flex flex-col items-center justify-start pt-1 transition-all active:scale-95 cursor-pointer border ${isToday ? 'border-blue-500 bg-blue-500/10' : themeClasses.calendarCell}`
                                                })}
                                                style={{ backgroundColor: primaryShift ? primaryShift.color + '80' : undefined }}
                                            >
                                                <span className={`text-sm ${isToday ? 'font-bold' : ''}`}>{date.getDate()}</span>
                                                {isValidTemperature(dayForecastMin) && (
                                                    <div className="text-[9px] text-blue-400 leading-none">
                                                        {Math.round(dayForecastMin)}¬∞
                                                    </div>
                                                )}
                                                <div className="flex gap-0.5 mt-1 flex-wrap justify-center h-2 overflow-hidden">{dayEvents.slice(0,3).map((ev, i) => <div key={i} className="w-1.5 h-1.5 rounded-full" style={{ backgroundColor: CATEGORIES.find(c => c.id === ev.category)?.color }}></div>)}</div>
                                                {shiftIndicators.length > 1 && (
                                                    <div className="flex gap-0.5 mt-1 flex-wrap justify-center h-2 overflow-hidden">
                                                        {shiftIndicators.slice(0, 4).map((s, i) => (
                                                            <div key={`${s.id || 'shift'}-${i}`} className="w-1.5 h-1.5 rounded-full" style={{ backgroundColor: s.color }}></div>
                                                        ))}
                                                        {shiftIndicators.length > 4 && <span className="text-[7px] opacity-70">+{shiftIndicators.length - 4}</span>}
                                                    </div>
                                                )}
                                                {primaryShift && primaryShift.id !== 'off' && shiftIndicators.length === 1 && <span className="text-[9px] mt-auto mb-1 opacity-80 leading-tight truncate px-1">{primaryShift.name.substring(0,2)}</span>}
                                            </div>
                                        );
                                    })}
                                </React.Fragment>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const FriendsView = ({ user, themeClasses, isComic, currentShareCode, currentUserName, onSelectFriend }) => {
            const [friendCode, setFriendCode] = useState('');
            const [friends, setFriends] = useState([]);
            const [requests, setRequests] = useState([]);
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                if(!user) return;
                const unsub = onSnapshot(collection(db, 'artifacts', appId, 'users', user.uid, 'friends'), (snap) => {
                    const reqs = [], fris = [];
                    snap.forEach(doc => {
                        const d = doc.data();
                        if (d.status === 'pending_received') reqs.push({ id: doc.id, ...d });
                        else if (d.status === 'accepted') fris.push({ id: doc.id, ...d });
                    });
                    setRequests(reqs); setFriends(fris);
                }, err => console.error("Friends Error", err));
                return () => unsub();
            }, [user]);

                        const addFriend = () => {
                const code = (friendCode || '').trim();
                if (!code) return;
                setLoading(true);

                const profileRef = doc(db, 'artifacts', appId, 'public_profiles', code);
                getDoc(profileRef)
                    .then((snap) => {
                        if (!snap.exists()) throw new Error('CODE_NOT_FOUND');
                        const profileData = snap.data() || {};
                        const fid = profileData.userId;
                        const friendName = profileData.name || 'Friend';
                        if (!fid) throw new Error('INVALID_PROFILE');
                        if (fid === user.uid) throw new Error('SELF_REQUEST');

                        const myName = (currentUserName || '').trim() || getUserName(user);
                        const batch = writeBatch(db);
                        batch.set(doc(db, 'artifacts', appId, 'users', user.uid, 'friends', fid), {
                            status: 'pending_sent',
                            shareCode: code,
                            name: friendName
                        });
                        batch.set(doc(db, 'artifacts', appId, 'users', fid, 'friends', user.uid), {
                            status: 'pending_received',
                            shareCode: currentShareCode,
                            name: myName
                        });
                        return batch.commit();
                    })
                    .then(() => {
                        alert(t('requestSent'));
                        setFriendCode('');
                    })
                    .catch((e) => {
                        console.error(e);
                        const msg = String(e && e.message ? e.message : e);
                        if (msg.includes('CODE_NOT_FOUND')) return alert(t('codeNotFound'));
                        if (msg.includes('SELF_REQUEST')) return alert(t('selfRequest'));
                        alert(t('errorAddFriend'));
                    })
                    .finally(() => setLoading(false));
            };


            const accept = (fid) => {
                if (!fid) return;
                const batch = writeBatch(db);
                batch.update(doc(db, 'artifacts', appId, 'users', user.uid, 'friends', fid), { status: 'accepted' });
                batch.update(doc(db, 'artifacts', appId, 'users', fid, 'friends', user.uid), { status: 'accepted' });
                batch.commit().catch((e) => console.error('accept friend error', e));
            };

            return (
                <div className="p-4 space-y-6 pb-32">
                    <div className={`p-6 rounded-2xl text-center ${themeClasses.card}`}>
                        <h2 className="text-xl font-bold mb-2">{t('shareCode')}</h2>
                        <div className="text-3xl font-mono tracking-widest text-blue-400 select-all font-bold bg-black/20 p-2 rounded">{currentShareCode || "..."}</div>
                    </div>
                    <div className="space-y-2">
                        <label className="text-xs font-bold opacity-70 uppercase">{t('addFriend')}</label>
                        <div className="flex gap-2">
                            <input value={friendCode} onChange={e=>setFriendCode(e.target.value)} placeholder={t('shareCodePlaceholder')} className={`flex-1 p-3 rounded-xl outline-none ${themeClasses.input}`}/>
                            <button onClick={addFriend} disabled={loading} className={`p-3 rounded-xl ${themeClasses.button}`}><Plus/></button>
                        </div>
                    </div>
                    {requests.length > 0 && <div className="space-y-2"><label className="text-xs font-bold opacity-70 uppercase text-orange-400">{t('pendingRequests')}</label>{requests.map(r=><div key={r.id} className={`p-4 rounded-xl flex items-center justify-between ${isComic?'bg-[#fdf6e3]':themeClasses.listItem}`}><div className="flex flex-col"><span className="font-bold">{r.name || r.shareCode}</span><span className="text-xs opacity-60 font-mono">{r.shareCode}</span></div><button onClick={()=>accept(r.id)} className="bg-green-600 text-white p-2 rounded text-xs font-bold">{t('accept')}</button></div>)}</div>}
                    <div className="space-y-2"><label className="text-xs font-bold opacity-70 uppercase">{t('myFriends')}</label>{friends.length===0?<p className="opacity-40 text-sm">Keine Freunde.</p>:friends.map(f=><div key={f.id} className={`p-4 rounded-xl flex items-center justify-between ${isComic?'bg-[#fdf6e3]':themeClasses.listItem}`}><div className="flex items-center gap-3"><div className="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white"><User size={16}/></div><div className="flex flex-col"><span className="font-bold">{f.name || f.shareCode}</span><span className="text-xs opacity-60 font-mono">{f.shareCode}</span></div></div><button onClick={()=>onSelectFriend(f.id)} className="p-2 rounded-full bg-blue-500/20 text-blue-400"><Eye size={20}/></button></div>)}</div>
                </div>
            );
        };

        // --- SETTINGS COMPONENT ---
            const SettingsView = ({ theme, setTheme, lang, setLang, fontScale, setFontScale, currentFont, setCurrentFont, shifts, saveShiftConfig, deleteShift, signOut, themeClasses, user, shareCode, displayName, setDisplayName, onSaveDisplayName, onOpenVisualEditor, onOpenFriends, settingsEditorLang, setSettingsEditorLang, openCustomThemeWizard, onApplyAiDesign, onOpenCalendarManager, onOpenCalendarSettings, onExportCalendarICS, calendars, friends, activeCalendarId, setActiveCalendarId, updateCalendar, shareCalendarWithUser, holidayCountries, holidayCountriesLoading, holidayCountriesError, holidayPref, setHolidayPref, holidaySyncing, holidayLastSync, onSyncHolidays, holidayFilter, setHolidayFilter, notificationPrefs, saveNotificationPrefs, notificationsSupported, fcmToken, requestNotificationPermission, pwaInstallPrompt, isPwaInstalled, installPwa, onRegisterFcm }) => {
            const [openSection, setOpenSection] = useState(null);
            const [editingShiftId, setEditingShiftId] = useState('');
            const [editForm, setEditForm] = useState({ name: '', start: '', end: '', color: '#000000' });
            const [aiDesignPrompt, setAiDesignPrompt] = useState('');
            const [manageCalendarId, setManageCalendarId] = useState('');
            const [vapidKey, setVapidKey] = useState(() => (localStorage.getItem('timeroster_fcm_vapid_key') || '').trim());

            const [friendSelections, setFriendSelections] = useState([]);
            const [manageCalendarError, setManageCalendarError] = useState('');
            const [calendarNameDraft, setCalendarNameDraft] = useState('');

            const toggle = (s) => setOpenSection(openSection === s ? null : s);
            const fonts = [ { id: 'font-inter', name: t('fontModern') }, { id: 'font-cinzel', name: t('fontAntique') }, { id: 'font-playfair', name: t('fontElegant') }, { id: 'font-merriweather', name: t('fontReadable') }, { id: 'font-oswald', name: t('fontStrong') } ];

            const [nameDraft, setNameDraft] = useState(displayName || '');
            useEffect(() => { setNameDraft(displayName || ''); }, [displayName]);
            useEffect(() => {
                setManageCalendarId(activeCalendarId && activeCalendarId !== 'all' ? activeCalendarId : '');
            }, [activeCalendarId]);
            useEffect(() => {
                setFriendSelections([]);
                setManageCalendarError('');
            }, [manageCalendarId, friends]);

            const selectedCalendar = useMemo(() => calendars?.find(c => c.id === manageCalendarId), [calendars, manageCalendarId]);
            const isCalendarOwner = selectedCalendar?.ownerId === user?.uid;
            useEffect(() => {
                setCalendarNameDraft(selectedCalendar?.name || '');
            }, [selectedCalendar?.id]);
            const memberFriends = useMemo(() => {
                if (!selectedCalendar?.members) return [];
                return (friends || []).filter(friend => selectedCalendar.members.includes(friend.id));
            }, [friends, selectedCalendar]);
            const availableFriends = useMemo(() => {
                if (!selectedCalendar) return [];
                return (friends || []).filter(friend => !(selectedCalendar.members || []).includes(friend.id));
            }, [friends, selectedCalendar]);
            const hasOnlyOwnerMember = selectedCalendar && Array.isArray(selectedCalendar.members)
                && selectedCalendar.members.length === 1
                && selectedCalendar.members[0] === selectedCalendar.ownerId;
            const holidayRegions = useMemo(() => getHolidayRegionOptions(holidayPref?.countryCode), [holidayPref?.countryCode]);
            const holidayCalendarOptions = useMemo(() => (calendars || []).filter(cal => cal.id !== 'all'), [calendars]);
            const filteredHolidayCountries = useMemo(() => {
                const query = (holidayFilter || '').trim().toLowerCase();
                const base = holidayCountries || [];
                if (!query) return base;
                return base.filter(item => item.name.toLowerCase().includes(query) || item.code.toLowerCase().includes(query));
            }, [holidayCountries, holidayFilter]);
            const lastSyncLabel = holidayLastSync ? new Date(holidayLastSync).toLocaleString(getCurrentLocale()) : t('holidayNoSync');

            const toggleFriendSelection = (friendId) => {
                setFriendSelections(prev => prev.includes(friendId) ? prev.filter(id => id !== friendId) : [...prev, friendId]);
            };

            const handleAddMembers = async () => {
                if (!selectedCalendar || !isCalendarOwner) {
                    alert(t('calendarManageNotAllowed'));
                    return;
                }
                setManageCalendarError('');
                    if (friendSelections.length === 0) {
                        setManageCalendarError(t('selectMembersPrompt'));
                        return;
                    }
                try {
                    await Promise.all(friendSelections.map(friendId => shareCalendarWithUser(selectedCalendar.id, friendId, 'viewer')));
                    setFriendSelections([]);
                } catch (e) {
                    console.error("shareCalendarWithUser error", e);
                    alert(t('calendarShareSomeFailed'));
                }
            };

            const handleCalendarNameSave = async () => {
                if (!selectedCalendar) return;
                if (!isCalendarOwner) {
                    alert(t('calendarManageNotAllowed'));
                    return;
                }
                const trimmed = (calendarNameDraft || '').trim();
                if (!trimmed) {
                    alert(t('pleaseEnterName'));
                    return;
                }
                if (trimmed === selectedCalendar.name) return;
                await updateCalendar(selectedCalendar.id, { name: trimmed });
            };

            const handleRemoveMember = async (friendId) => {
                if (!selectedCalendar || !isCalendarOwner) {
                    alert(t('calendarManageNotAllowed'));
                    return;
                }
                if (friendId === user?.uid) {
                    alert(t('calendarOwnerCannotRemoveSelf'));
                    return;
                }
                const updatedMembers = (selectedCalendar.members || []).filter(id => id !== friendId);
                const updatedRoles = { ...(selectedCalendar.roles || {}) };
                delete updatedRoles[friendId];
                try {
                    await updateCalendar(selectedCalendar.id, { members: updatedMembers, roles: updatedRoles });
                } catch (e) {
                    console.error("removeMember error", e);
                    alert(t('calendarMemberRemoveFailed'));
                }
            };

            return (
                <div className="p-4 pb-32 space-y-4 h-full overflow-y-auto">
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('profile')} className="w-full p-4 flex justify-between items-center font-bold"><span className="flex items-center gap-2"><User size={18}/> Profil</span>{openSection==='profile'?<ChevronLeft className="-rotate-90"/>:<ChevronLeft className="rotate-0"/>}</button>
                        {openSection === 'profile' && (
                            <div className="p-4 pt-0 space-y-3 border-t border-black/10">
                                <div>
                                    <label className="text-xs opacity-70 block mb-1 font-bold">{t('displayNameHint')}</label>
                                    <input value={nameDraft} onChange={(e)=>setNameDraft(e.target.value)} placeholder={t('nameExample')} className="w-full p-3 rounded-lg bg-black/30 border border-white/10 outline-none" />
                                </div>
                                <div className="text-xs opacity-70">{t('friendCodeLabel')}: <span className="font-bold">{shareCode || '-'}</span></div>
                                <button onClick={() => onSaveDisplayName(nameDraft)} className="w-full p-3 rounded-lg bg-blue-600/30 border border-blue-500 font-bold">{t('saveName')}</button>
                                <button onClick={onOpenFriends} className={`w-full p-3 rounded-lg font-bold ${themeClasses.button}`}>
                                    <span className="flex items-center justify-center gap-2"><Users size={16}/> {t('manageFriends')}</span>
                                </button>
                            </div>
                        )}
                    </div>
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('appearance')} className="w-full p-4 flex justify-between items-center font-bold"><span className="flex items-center gap-2"><Layout size={18}/> {t('appearance')}</span>{openSection==='appearance'?<ChevronLeft className="-rotate-90"/>:<ChevronLeft className="rotate-0"/>}</button>
                        {openSection === 'appearance' && (
                            <div className="p-4 pt-0 space-y-4 border-t border-black/10">
                                
                                <div className="mt-4 grid grid-cols-2 gap-2">
                                    <button onClick={() => setTheme('light')} className={`p-3 rounded-lg border-2 font-bold ${theme === 'light' ? 'border-blue-500 bg-blue-500/10' : 'border-transparent opacity-80'}`}>{t('light')}</button>
                                    <button onClick={() => setTheme('dark')} className={`p-3 rounded-lg border-2 font-bold ${theme === 'dark' ? 'border-slate-600 bg-slate-600/20' : 'border-transparent opacity-80'}`}>{t('dark')}</button>
                                    <button onClick={() => setTheme('vibrant')} className={`p-3 rounded-lg border-2 font-bold ${theme === 'vibrant' ? 'border-pink-500 bg-pink-500/10' : 'border-transparent opacity-80'}`}>{t('vibrant')}</button>
                                    <button onClick={() => setTheme('custom')} className={`p-3 rounded-lg border-2 font-bold ${theme === 'custom' ? 'border-emerald-500 bg-emerald-500/10' : 'border-transparent opacity-80'}`}>{t('custom')}</button>
                                </div>

                                <div><label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('font')}</label><select value={currentFont} onChange={(e) => setCurrentFont(e.target.value)} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}>{fonts.map(f => <option key={f.id} value={f.id}>{f.name}</option>)}</select></div>
                                <div><label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('fontSize')}: {Math.round(fontScale * 100)}%</label><input type="range" min="0.7" max="1.5" step="0.05" value={fontScale} onChange={(e) => setFontScale(parseFloat(e.target.value))} className="w-full accent-blue-500"/></div>
                                {theme === 'custom' && (
                                    <button onClick={openCustomThemeWizard} className="w-full p-3 rounded-lg border text-sm font-bold bg-emerald-500/10 text-emerald-400">
                                        {t('customizeTheme')}
                                    </button>
                                )}

                                <div className="rounded-xl border border-white/10 bg-black/20 p-3 space-y-2">
                                    <div className="text-xs font-bold uppercase text-slate-400">{t('aiDesign')}</div>
                                    <textarea
                                        value={aiDesignPrompt}
                                        onChange={(e) => setAiDesignPrompt(e.target.value)}
                                        placeholder={t('aiDesignPlaceholder')}
                                        rows="3"
                                        className="w-full p-2 rounded-lg text-xs bg-black/30 border border-white/10 outline-none text-slate-100"
                                    />
                                    <div className="text-[10px] text-slate-400">{t('aiDesignHint')}</div>
                                    <button
                                        onClick={() => onApplyAiDesign(aiDesignPrompt)}
                                        className={`w-full p-2 rounded-lg text-xs font-bold ${themeClasses.button}`}
                                    >
                                        {t('aiDesignApply')}
                                    </button>
                                </div>

                                <button
                                    onClick={onOpenVisualEditor}
                                    className={`w-full p-3 rounded-lg border text-sm font-bold ${themeClasses.button}`}
                                >
                                    üß© {getSettingsText(settingsEditorLang, 'visualEditor')}
                                </button>
                            </div>
                        )}
                    </div>
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('calendarManagement')} className="w-full p-4 flex justify-between items-center font-bold"><span className="flex items-center gap-2"><Users size={18}/> {t('manageCalendars')}</span>{openSection==='calendarManagement'?<ChevronLeft className="-rotate-90"/>:<ChevronLeft className="rotate-0"/>}</button>
                        {openSection === 'calendarManagement' && (
                            <div className="p-4 pt-0 space-y-4 border-t border-black/10">
                                <div>
                                    <label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('selectCalendar')}</label>
                                    <select
                                        value={manageCalendarId}
                                        onChange={(e) => {
                                            const nextId = e.target.value;
                                            setManageCalendarId(nextId);
                                            if (nextId) setActiveCalendarId(nextId);
                                        }}
                                        className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}
                                    >
                                        <option value="">{t('selectCalendarPlaceholder')}</option>
                                        {(calendars || []).filter(cal => cal.id !== 'all').map(cal => (
                                            <option key={cal.id} value={cal.id}>{cal.name}</option>
                                        ))}
                                    </select>
                                </div>
                                <div className="grid grid-cols-3 gap-2">
                                    <button
                                        onClick={onOpenCalendarManager}
                                        className={`p-3 rounded-lg flex flex-col items-center gap-1 text-[11px] font-bold ${themeClasses.listItem}`}
                                        title={t('calendarCreateButton')}
                                    >
                                        <FolderPlus size={16}/>
                                        {t('calendarCreateButton')}
                                    </button>
                                    <button
                                        onClick={() => selectedCalendar && onOpenCalendarSettings(selectedCalendar)}
                                        disabled={!selectedCalendar}
                                        className={`p-3 rounded-lg flex flex-col items-center gap-1 text-[11px] font-bold ${selectedCalendar ? themeClasses.listItem : 'opacity-40 bg-black/10 cursor-not-allowed'}`}
                                        title={t('shareCalendar')}
                                    >
                                        <Share2 size={16}/>
                                        {t('shareCalendar')}
                                    </button>
                                    <button
                                        onClick={onExportCalendarICS}
                                        disabled={!selectedCalendar}
                                        className={`p-3 rounded-lg flex flex-col items-center gap-1 text-[11px] font-bold ${selectedCalendar ? themeClasses.listItem : 'opacity-40 bg-black/10 cursor-not-allowed'}`}
                                        title={t('exportIcsTitle')}
                                    >
                                        <Download size={16}/>
                                        {t('exportIcsTitle')}
                                    </button>
                                </div>
                                {selectedCalendar && (
                                    <div className="space-y-3">
                                        <div className="flex items-center gap-3 p-3 rounded-lg bg-black/10">
                                            <div className="w-3 h-3 rounded-full" style={{ backgroundColor: selectedCalendar.color }} />
                                            <div className="flex-1">
                                                <div className="font-bold">{calendarNameDraft || selectedCalendar.name}</div>
                                                {selectedCalendar.description && <div className="text-xs opacity-60">{selectedCalendar.description}</div>}
                                            </div>
                                            <span className="text-xs opacity-60">{isCalendarOwner ? t('calendarOwner') : t('calendarMember')}</span>
                                        </div>
                                        <div>
                                            <label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('calendarNamePlaceholder')}</label>
                                            <div className="flex gap-2">
                                                <input
                                                    value={calendarNameDraft}
                                                    onChange={(e) => setCalendarNameDraft(e.target.value)}
                                                    disabled={!isCalendarOwner}
                                                    className={`flex-1 p-2 rounded-lg ${themeClasses.input}`}
                                                />
                                                <button
                                                    onClick={handleCalendarNameSave}
                                                    disabled={!isCalendarOwner || !calendarNameDraft.trim() || calendarNameDraft.trim() === selectedCalendar.name}
                                                    className={`px-3 rounded-lg text-sm font-bold ${isCalendarOwner ? themeClasses.button : 'opacity-40 bg-black/10 cursor-not-allowed'}`}
                                                >
                                                    {t('save')}
                                                </button>
                                            </div>
                                            {!isCalendarOwner && (
                                                <div className="text-xs opacity-60 mt-1">{t('onlyOwnerCanChangeSettings')}</div>
                                            )}
                                        </div>
                                        {!isCalendarOwner && (
                                            <div className="text-xs opacity-60">{t('onlyOwnerCanManageMembers')}</div>
                                        )}
                                        <div>
                                            <label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('calendarMembers')}</label>
                                            <div className="space-y-2">
                                                {memberFriends.length === 0 && (
                                                    <div className="text-xs opacity-60">{t('calendarNoMembers')}</div>
                                                )}
                                                {memberFriends.map(friend => (
                                                    <div key={friend.id} className="flex items-center gap-2 p-2 rounded bg-black/10 text-sm">
                                                        <div className="w-7 h-7 rounded-full bg-blue-500 flex items-center justify-center text-white">
                                                            <User size={14}/>
                                                        </div>
                                                        <span className="flex-1">{friend.name || friend.shareCode}</span>
                                                        {isCalendarOwner && (
                                                            <button onClick={() => handleRemoveMember(friend.id)} className="text-xs px-2 py-1 rounded bg-red-500/20 text-red-400">
                                                                {t('remove')}
                                                            </button>
                                                        )}
                                                    </div>
                                                ))}
                                                {hasOnlyOwnerMember && (
                                                    <div className="text-xs opacity-60">{t('calendarOnlyOwner')}</div>
                                                )}
                                            </div>
                                        </div>
                                        {isCalendarOwner && (
                                            <div>
                                                <label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('addMembers')}</label>
                                                {availableFriends.length === 0 ? (
                                                    <div className="text-xs opacity-60">{t('noFriends')}</div>
                                                ) : (
                                                    <div className="space-y-2">
                                                        {availableFriends.map(friend => (
                                                            <div
                                                                key={friend.id}
                                                                onClick={() => toggleFriendSelection(friend.id)}
                                                                className={`flex items-center gap-2 p-2 rounded cursor-pointer transition-all ${friendSelections.includes(friend.id) ? 'bg-blue-500/30 border border-blue-500' : 'bg-black/10 hover:bg-black/20'}`}
                                                            >
                                                                <div className={`w-4 h-4 rounded border flex items-center justify-center ${friendSelections.includes(friend.id) ? 'bg-blue-500 border-blue-500' : 'border-gray-400'}`}>
                                                                    {friendSelections.includes(friend.id) && <Check size={10} className="text-white"/>}
                                                                </div>
                                                                <div className="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center text-white">
                                                                    <User size={12}/>
                                                                </div>
                                                                <span className="text-sm flex-1">{friend.name || friend.shareCode}</span>
                                                            </div>
                                                        ))}
                                                        {manageCalendarError && (
                                                            <div className="text-xs text-red-400">{manageCalendarError}</div>
                                                        )}
                                                        <button onClick={handleAddMembers} className="w-full py-2 rounded bg-blue-600 text-white text-sm font-bold">
                                                            {t('addMembers')}
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('holidaySettings')} className="w-full p-4 flex justify-between items-center font-bold"><span className="flex items-center gap-2"><Globe size={18}/> {t('holidaySettings')}</span>{openSection==='holidaySettings'?<ChevronLeft className="-rotate-90"/>:<ChevronLeft className="rotate-0"/>}</button>
                        {openSection === 'holidaySettings' && (
                            <div className="p-4 pt-0 space-y-4 border-t border-black/10">
                                <div className="text-xs opacity-60">{t('holidaySettingsHint')}</div>
                                <div>
                                    <label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('holidayCountryLabel')}</label>
                                    <input
                                        value={holidayFilter}
                                        onChange={(e) => setHolidayFilter(e.target.value)}
                                        placeholder={t('holidayCountrySearch')}
                                        className={`w-full p-3 rounded-lg outline-none mb-2 ${themeClasses.input}`}
                                    />
                                    <select
                                        value={holidayPref?.countryCode || ''}
                                        onChange={(e) => {
                                            const code = e.target.value;
                                            const selected = (holidayCountries || []).find(item => item.code === code);
                                            setHolidayPref(prev => ({
                                                ...prev,
                                                countryCode: code,
                                                countryName: selected?.name || code,
                                                regionCode: '',
                                                regionName: ''
                                            }));
                                        }}
                                        className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}
                                    >
                                        <option value="">{holidayCountriesLoading ? t('holidaySyncing') : t('holidayCountrySearch')}</option>
                                        {filteredHolidayCountries.map(item => (
                                            <option key={item.code} value={item.code}>{item.name} ({item.code})</option>
                                        ))}
                                    </select>
                                    {holidayCountriesError && (
                                        <div className="text-xs text-orange-400 mt-2">{holidayCountriesError}</div>
                                    )}
                                </div>
                                <div>
                                    <label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('holidayRegionLabel')}</label>
                                    <select
                                        value={holidayPref?.regionCode || ''}
                                        onChange={(e) => {
                                            const code = e.target.value;
                                            const selected = holidayRegions.find(item => item.code === code);
                                            setHolidayPref(prev => ({
                                                ...prev,
                                                regionCode: code,
                                                regionName: selected?.name || ''
                                            }));
                                        }}
                                        className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}
                                        disabled={holidayRegions.length === 0}
                                    >
                                        <option value="">{t('holidayRegionHint')}</option>
                                        {holidayRegions.map(item => (
                                            <option key={item.code} value={item.code}>{item.name}</option>
                                        ))}
                                    </select>
                                    <div className="text-xs opacity-60 mt-1">{t('holidayRegionHint')}</div>
                                </div>
                                <div>
                                    <label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('holidayCalendarLabel')}</label>
                                    <select
                                        value={holidayPref?.calendarId || ''}
                                        onChange={(e) => {
                                            const calId = e.target.value;
                                            setHolidayPref(prev => ({ ...prev, calendarId: calId || null }));
                                        }}
                                        className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}
                                    >
                                        <option value="">{t('selectCalendarPlaceholder')}</option>
                                        {holidayCalendarOptions.map(cal => (
                                            <option key={cal.id} value={cal.id}>{cal.name}</option>
                                        ))}
                                    </select>
                                    <div className="text-xs opacity-60 mt-1">{t('holidayCalendarHint')}</div>
                                </div>
                                <div className="flex items-center justify-between text-xs opacity-70">
                                    <span>{t('holidayLastSync')}: {lastSyncLabel}</span>
                                </div>
                                <button
                                    onClick={onSyncHolidays}
                                    disabled={holidaySyncing}
                                    className={`w-full p-3 rounded-lg font-bold ${holidaySyncing ? 'bg-slate-600 text-slate-200' : themeClasses.button}`}
                                >
                                    {holidaySyncing ? t('holidaySyncing') : t('holidaySyncButton')}
                                </button>
                            </div>
                        )}
                    </div>
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('language')} className="w-full p-4 flex justify-between items-center font-bold"><span className="flex items-center gap-2"><Globe size={18}/> {t('appLanguage')}</span>{openSection==='language'?<ChevronLeft className="-rotate-90"/>:<ChevronLeft className="rotate-0"/>}</button>
                        {openSection === 'language' && (
                            <div className="p-4 pt-0 space-y-3 border-t border-black/10">
                                <label className="text-xs opacity-60 block mb-2 font-bold uppercase">{t('appLanguage')}</label>
                                <select value={lang} onChange={(e) => setLang(e.target.value)} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}>
                                    {SETTINGS_LANG_OPTIONS.map(opt => (
                                        <option key={opt.id} value={opt.id}>{opt.label}</option>
                                    ))}
                                </select>
                                <div className="text-xs opacity-60">{t('appLanguageHint')}</div>
                            </div>
                        )}
                    </div>
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('shifts')} className="w-full p-4 flex justify-between items-center font-bold"><span className="flex items-center gap-2"><Clock size={18}/> {t('manageShifts')}</span>{openSection==='shifts'?<ChevronLeft className="-rotate-90"/>:<ChevronLeft className="rotate-0"/>}</button>
                        {openSection === 'shifts' && (
                            <div className="p-4 pt-0 border-t border-black/10">
                                <div className="mt-4">
                                    <select value={editingShiftId} onChange={(e) => { const sId = e.target.value; setEditingShiftId(sId); if (sId === 'new') setEditForm({ name: '', start: '', end: '', color: '#3b82f6' }); else { const s = shifts.find(x => x.id === sId); if(s) setEditForm({...s}); } }} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}><option value="">-- {t('selectShift')} --</option><option value="new">+ {t('newShift')}</option>{shifts.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}</select>
                                </div>
                                {editingShiftId && (
                                    <div className="mt-4 space-y-3 bg-black/5 p-3 rounded-lg">
                                        <input value={editForm.name} onChange={e => setEditForm({...editForm, name: e.target.value})} className={`w-full p-2 rounded-md ${themeClasses.input}`} />
                                        <div className="grid grid-cols-2 gap-2"><input type="time" value={editForm.start} onChange={e => setEditForm({...editForm, start: e.target.value})} className={`w-full p-2 rounded-md ${themeClasses.input}`}/><input type="time" value={editForm.end} onChange={e => setEditForm({...editForm, end: e.target.value})} className={`w-full p-2 rounded-md ${themeClasses.input}`}/></div>
                                        <div className="flex items-center gap-2"><input type="color" value={editForm.color} onChange={e => setEditForm({...editForm, color: e.target.value})} className="h-10 w-10 rounded border-none"/></div>
                                        <div className="flex gap-2 pt-2">{editingShiftId !== 'new' && <button onClick={() => { deleteShift(editingShiftId); setEditingShiftId(''); }} className="p-3 bg-red-500/20 text-red-500 rounded-lg"><Trash2 size={18}/></button>}<button onClick={async () => { const newShift = { ...editForm, id: editingShiftId === 'new' ? crypto.randomUUID() : editingShiftId }; await saveShiftConfig(newShift); setEditingShiftId(''); }} className={`flex-1 p-3 rounded-lg font-bold ${themeClasses.button}`}>{t('save')}</button></div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                    {/* PWA Install */}
                    {(!isPwaInstalled || pwaInstallPrompt) && (
                        <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                            <div className="p-4">
                                <div className="flex items-center gap-3 mb-2">
                                    <Download size={18}/>
                                    <span className="font-bold">{t('pwaInstall')}</span>
                                </div>
                                <div className="text-xs opacity-60 mb-3">{t('pwaInstallHint')}</div>
                                {pwaInstallPrompt ? (
                                    <button 
                                        onClick={installPwa}
                                        className="w-full p-3 bg-blue-600 text-white rounded-lg font-bold text-sm flex items-center justify-center gap-2"
                                    >
                                        <Download size={16}/> {t('pwaInstall')}
                                    </button>
                                ) : (
                                    <div className="text-xs opacity-50 bg-white/5 p-3 rounded-lg">
                                        {/iPhone|iPad|iPod/.test(navigator.userAgent) ? t('pwaInstallIosHint') : t('pwaInstallHint')}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                    {isPwaInstalled && (
                        <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                            <div className="p-4 flex items-center gap-3">
                                <Download size={18} className="text-green-400"/>
                                <span className="text-sm font-bold text-green-400">{t('pwaInstalled')}</span>
                            </div>
                        </div>
                    )}

                    {/* Notification Settings */}
                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}>
                        <button onClick={() => toggle('notifications')} className={`w-full p-4 flex items-center justify-between ${themeClasses.listItem}`}>
                            <div className="flex items-center gap-3"><Bell size={18}/><span className="font-bold">{t('notificationSettings')}</span></div>
                            <div className="flex items-center gap-2">
                                {notificationsSupported && fcmToken ? (
                                    <span className="text-xs text-green-400 flex items-center gap-1"><div className="w-2 h-2 rounded-full bg-green-500"></div> {t('notificationEnabled')}</span>
                                ) : (
                                    <span className="text-xs text-gray-500">{t('notificationDisabled')}</span>
                                )}
                                <ChevronRight size={16} className={`transition-transform ${openSection === 'notifications' ? 'rotate-90' : ''}`}/>
                            </div>
                        </button>
                        {openSection === 'notifications' && (
                            <div className="p-4 space-y-3">
                                {notificationsSupported && !fcmToken && (
                                    <button 
                                        onClick={async () => {
                                            const granted = await requestNotificationPermission();
                                            if (!granted) alert(t('notificationPermissionDenied'));
                                        }}
                                        className="w-full p-3 bg-blue-600 text-white rounded-lg font-bold text-sm"
                                    >
                                        <Bell size={16} className="inline mr-2"/> {t('notificationEnableBtn')}
                                    </button>
                                
                                <div className={`p-3 rounded-lg ${themeClasses.listItem}`}>
                                    <div className="text-xs font-bold mb-2">FCM VAPID Key</div>
                                    <input
                                        value={vapidKey}
                                        onChange={(e) => setVapidKey(e.target.value)}
                                        placeholder="VAPID Public Key (Firebase Console ‚Üí Cloud Messaging ‚Üí Web Push certificates)"
                                        className={`w-full px-3 py-2 rounded-lg border text-xs outline-none ${themeClasses.input}`}
                                    />
                                    <div className="flex gap-2 mt-2">
                                        <button
                                            onClick={() => {
                                                const v = (vapidKey || '').trim();
                                                localStorage.setItem('timeroster_fcm_vapid_key', v);
                                                alert('VAPID Key gespeichert ‚úì');
                                            }}
                                            className="flex-1 px-3 py-2 rounded-lg bg-white/10 text-white text-xs font-bold"
                                        >
                                            <Save size={14} className="inline mr-1"/> Speichern
                                        </button>
                                        <button
                                            onClick={async () => {
                                                const permissionOk = await requestNotificationPermission();
                                                if (!permissionOk) return alert(t('notificationPermissionDenied'));
                                                const v = (localStorage.getItem('timeroster_fcm_vapid_key') || '').trim();
                                                if (!v) return alert('Bitte VAPID Public Key speichern.');
                                                try {
                                                    const ok = await onRegisterFcm?.();
                                                    if (ok) alert('Push aktiviert ‚úì');
                                                    else alert('Push konnte nicht aktiviert werden (Token).');
                                                } catch (e) {
                                                    console.error(e);
                                                    alert('Push konnte nicht aktiviert werden.');
                                                }
                                            }}
                                            className="flex-1 px-3 py-2 rounded-lg bg-blue-600 text-white text-xs font-bold"
                                        >
                                            <Bell size={14} className="inline mr-1"/> Push aktivieren
                                        </button>
                                    </div>
                                    {fcmToken && fcmToken !== 'local-notifications-active' && (
                                        <div className="mt-2 text-[10px] opacity-60 break-all">
                                            Token: {String(fcmToken).slice(0, 24)}‚Ä¶
                                        </div>
                                    )}
                                    <div className="mt-2 text-[10px] opacity-60">
                                        Push-Text ist absichtlich neutral: <b>‚ÄûKalender aktualisiert‚Äú</b>
                                    </div>
                                </div>

)}
                                {!notificationsSupported && (
                                    <div className="text-xs text-amber-400 bg-amber-400/10 p-3 rounded-lg">{t('notificationNotSupported')}</div>
                                )}
                                <label className={`flex items-center justify-between p-3 rounded-lg cursor-pointer ${themeClasses.listItem}`}>
                                    <div className="flex items-center gap-2">
                                        <MessageCircle size={14}/>
                                        <span className="text-sm">{t('notificationChatMessages')}</span>
                                    </div>
                                    <input 
                                        type="checkbox" 
                                        checked={notificationPrefs?.chatMessages !== false} 
                                        onChange={(e) => saveNotificationPrefs({...notificationPrefs, chatMessages: e.target.checked})}
                                        className="w-4 h-4 rounded"
                                    />
                                </label>
                                <label className={`flex items-center justify-between p-3 rounded-lg cursor-pointer ${themeClasses.listItem}`}>
                                    <div className="flex items-center gap-2">
                                        <Calendar size={14}/>
                                        <span className="text-sm">{t('notificationCalendarEvents')}</span>
                                    </div>
                                    <input 
                                        type="checkbox" 
                                        checked={notificationPrefs?.calendarEvents !== false} 
                                        onChange={(e) => saveNotificationPrefs({...notificationPrefs, calendarEvents: e.target.checked})}
                                        className="w-4 h-4 rounded"
                                    />
                                </label>
                                <label className={`flex items-center justify-between p-3 rounded-lg cursor-pointer ${themeClasses.listItem}`}>
                                    <div className="flex items-center gap-2">
                                        <UserPlus size={14}/>
                                        <span className="text-sm">{t('notificationFriendRequests')}</span>
                                    </div>
                                    <input 
                                        type="checkbox" 
                                        checked={notificationPrefs?.friendRequests !== false} 
                                        onChange={(e) => saveNotificationPrefs({...notificationPrefs, friendRequests: e.target.checked})}
                                        className="w-4 h-4 rounded"
                                    />
                                </label>
                                {fcmToken && (
                                    <div className="text-[10px] text-gray-500 mt-2 break-all">Token: {fcmToken.substring(0, 20)}...</div>
                                )}
                            </div>
                        )}
                    </div>

                    <div className={`rounded-xl overflow-hidden ${themeClasses.card}`}><button onClick={() => signOut(auth)} className="w-full p-4 flex items-center justify-center gap-2 text-red-400 font-bold"><LogOut size={18}/> Logout</button></div>
                </div>
            );
        };

        const EventDetailModal = ({ event, onClose, onSave, onDelete, themeClasses, isComic, user, onUpdateParticipantStatus, taskTimeEntries, activeTaskTimers, startTaskTimer, stopTaskTimer, deleteTaskTimeEntry }) => {
            const currentUserId = user?.uid || null;
            if (!event) return null;
            const [isEditing, setIsEditing] = useState(false);
            const [formData, setFormData] = useState({ ...event });
            const [tasks, setTasks] = useState(event.tasks || []);
            const [newTaskTitle, setNewTaskTitle] = useState('');
            const [newTaskDueDate, setNewTaskDueDate] = useState('');
            const [newTaskResponsible, setNewTaskResponsible] = useState('');
            const [newTaskStatus, setNewTaskStatus] = useState('open');
            const [newTaskPriority, setNewTaskPriority] = useState('normal');
            const [newTaskReminder, setNewTaskReminder] = useState('');
            const [newSubtaskText, setNewSubtaskText] = useState({});
            const [showSaveTemplate, setShowSaveTemplate] = useState(false);
            const [templateName, setTemplateName] = useState('');
            
            const handleSave = () => { 
                onSave({ ...formData, tasks, id: event.id }); 
                setIsEditing(false); 
            }

            
            const saveAsTemplate = async () => {
                if (!templateName.trim()) {
                    alert(t('pleaseEnterTemplateName'));
                    return;
                }
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'users', user.uid, 'eventTemplates'), {
                        name: templateName,
                        category: formData.category,
                        title: formData.title,
                        duration: formData.duration,
                        location: formData.location,
                        repeat: formData.repeat,
                        createdAt: serverTimestamp()
                    });
                    setTemplateName('');
                    setShowSaveTemplate(false);
                    alert(t('templateCreated'));
                } catch (e) {
                    console.error("Save template error", e);
                    alert(t('templateSaveError'));
                }
            };
            
            const addTask = () => {
                if (!newTaskTitle.trim()) return;
                const newTask = {
                    id: `task_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
                    title: newTaskTitle,
                    dueDate: newTaskDueDate,
                    responsible: newTaskResponsible,
                    status: newTaskStatus,
                    priority: newTaskPriority,
                    reminder: newTaskReminder,
                    checklist: []
                };
                setTasks([...tasks, newTask]);
                setNewTaskTitle('');
                setNewTaskDueDate('');
                setNewTaskResponsible('');
                setNewTaskStatus('open');
                setNewTaskPriority('normal');
                setNewTaskReminder('');
            };
            
            const deleteTask = (taskId) => {
                setTasks(tasks.filter(t => t.id !== taskId));
            };
            
            const updateTask = (taskId, updates) => {
                setTasks(tasks.map(t => t.id === taskId ? { ...t, ...updates } : t));
            };
            
            const addSubtask = (taskId) => {
                const text = newSubtaskText[taskId];
                if (!text || !text.trim()) return;
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;
                const newSubtask = {
                    id: `subtask_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
                    text: text,
                    completed: false
                };
                updateTask(taskId, { checklist: [...(task.checklist || []), newSubtask] });
                setNewSubtaskText({ ...newSubtaskText, [taskId]: '' });
            };
            
            const toggleSubtask = (taskId, subtaskId) => {
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;
                const updatedChecklist = task.checklist.map(s => 
                    s.id === subtaskId ? { ...s, completed: !s.completed } : s
                );
                updateTask(taskId, { checklist: updatedChecklist });
            };
            
            const deleteSubtask = (taskId, subtaskId) => {
                const task = tasks.find(t => t.id === taskId);
                if (!task) return;
                updateTask(taskId, { checklist: task.checklist.filter(s => s.id !== subtaskId) });
            };
            
            // Get current user's participant status
            const currentUserParticipant = user?.uid ? (event.participants || []).find(p => p.userId === user.uid) : null;
            const currentUserStatus = currentUserParticipant?.status || 'pending';
            
            const handleResponseStatusChange = (newStatus) => {
                // Validate status value
                const validStatuses = ['accepted', 'maybe', 'declined', 'pending'];
                if (!validStatuses.includes(newStatus)) {
                    console.error('Invalid status value:', newStatus);
                    return;
                }
                
                if (onUpdateParticipantStatus && user) {
                    onUpdateParticipantStatus(event.id, user.uid, newStatus);
                }
            };
            const isPending = event.status === 'pending';
            const isCreatedByOther = event.createdBy && event.createdBy !== currentUserId;

            return (
                <div className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className={`w-full max-w-md rounded-2xl p-6 max-h-[90vh] overflow-y-auto ${isComic?'bg-[#f4e4bc] border-4 border-[#8b5a2b] text-[#4a3b2a]':'bg-slate-900 border border-slate-700'}`}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold">{isEditing ? t('editEvent') : t('eventDetails')}</h2>
                            <div className="flex gap-2">
                                {!isEditing && <button onClick={() => setShowSaveTemplate(true)} className="p-2 bg-purple-500/20 text-purple-400 rounded-lg" title={t('templates')}><FileText size={18}/></button>}
                                {!isEditing && <button onClick={() => setIsEditing(true)} className="p-2 bg-blue-500/20 text-blue-400 rounded-lg"><Pencil size={18}/></button>}
                                <button onClick={onClose}><X /></button>
                            </div>
                        </div>
                        
                        {/* Save as Template Modal */}
                        {showSaveTemplate && (
                            <div className="mb-4 p-4 rounded-xl bg-purple-500/10 border border-purple-500/30">
                                <h3 className="text-sm font-bold mb-2">{t('templates')}</h3>
                                <input 
                                    value={templateName}
                                    onChange={e => setTemplateName(e.target.value)}
                                    placeholder={t('enterTemplateName')}
                                    className={`w-full p-2 rounded-lg outline-none mb-2 ${themeClasses.input}`}
                                />
                                <div className="flex gap-2">
                                    <button onClick={saveAsTemplate} className="flex-1 p-2 rounded-lg bg-purple-500/20 text-purple-400 font-bold text-sm hover:bg-purple-500/30">
                                        {t('save')}
                                    </button>
                                    <button onClick={() => {setShowSaveTemplate(false); setTemplateName('');}} className={`flex-1 p-2 rounded-lg border font-bold text-sm ${themeClasses.surfaceBtn}`}>
                                        {t('cancel')}
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {isEditing ? (
                            <div className="space-y-4">
                                <div>
                                    <label className="text-xs opacity-70 block mb-1 font-bold">{t('category')}</label>
                                    <div className="grid grid-cols-5 gap-2">{CATEGORIES.map(cat => <button key={cat.id} onClick={() => setFormData({...formData, category: cat.id})} className={`p-2 rounded-lg flex flex-col items-center gap-1 transition-all ${formData.category === cat.id ? 'bg-blue-600/30 border border-blue-500' : 'opacity-60'}`}><span className="text-xl">{cat.icon}</span><span className="text-[9px]">{t(cat.id)}</span></button>)}</div>
                                </div>
                                <input value={formData.title} onChange={e => setFormData({...formData, title: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`} />
                                <div className="grid grid-cols-2 gap-2"><input type="date" value={formData.date} onChange={e => setFormData({...formData, date: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}/><input type="time" value={formData.time} onChange={e => setFormData({...formData, time: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}/></div>
                                <div>
                                    <label className="text-xs opacity-70 block mb-1 font-bold">{t('repeat')}</label>
                                    <select value={formData.repeat || 'none'} onChange={e => setFormData({...formData, repeat: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}>
                                        <option value="none">{t('repeatNone')}</option>
                                        <option value="daily">{t('repeatDaily')}</option>
                                        <option value="weekly">{t('repeatWeekly')}</option>
                                        <option value="monthly">{t('repeatMonthly')}</option>
                                        <option value="yearly">{t('repeatYearly')}</option>
                                    </select>
                                </div>
                                <input value={formData.location || ''} onChange={e => setFormData({...formData, location: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`} placeholder={t('location')}/>
                                
                                
                                {/* Time Planning in Edit Mode */}
                                <div className="pt-3 border-t border-slate-700/50">
                                    <label className="text-xs opacity-70 block mb-2 font-bold">{t('timePlanning')}</label>
                                    <div className="grid grid-cols-3 gap-2">
                                        <div>
                                            <label className="text-[10px] opacity-60 block mb-1">{t('durationShort')}</label>
                                            <input 
                                                type="number" 
                                                value={formData.duration || 60} 
                                                onChange={e => setFormData({...formData, duration: parseInt(e.target.value) || 60})} 
                                                className={`w-full p-2 text-sm rounded-lg outline-none ${themeClasses.input}`}
                                                min="15"
                                                step="15"
                                            />
                                        </div>
                                        <div>
                                            <label className="text-[10px] opacity-60 block mb-1">{t('travelShort')}</label>
                                            <input 
                                                type="number" 
                                                value={formData.travelTime || 0} 
                                                onChange={e => setFormData({...formData, travelTime: parseInt(e.target.value) || 0})} 
                                                className={`w-full p-2 text-sm rounded-lg outline-none ${themeClasses.input}`}
                                                min="0"
                                                step="5"
                                            />
                                        </div>
                                        <div>
                                            <label className="text-[10px] opacity-60 block mb-1">{t('bufferShort')}</label>
                                            <input 
                                                type="number" 
                                                value={formData.bufferTime || 0} 
                                                onChange={e => setFormData({...formData, bufferTime: parseInt(e.target.value) || 0})} 
                                                className={`w-full p-2 text-sm rounded-lg outline-none ${themeClasses.input}`}
                                                min="0"
                                                step="5"
                                            />
                                        </div>
                                    </div>
                                </div>

                                <div className="flex gap-2 pt-2"><button onClick={() => onDelete(event.id)} className="p-3 bg-red-500/20 text-red-500 rounded-lg"><Trash2 size={18}/></button><button onClick={handleSave} className={`flex-1 p-3 rounded-lg font-bold ${themeClasses.button}`}>{t('save')}</button></div>
                            </div>
                        ) : (
                            <div className="space-y-4">
                                <div className="flex items-center gap-4 p-4 bg-black/10 rounded-xl">
                                    <div className="text-3xl">{CATEGORIES.find(c => c.id === event.category)?.icon}</div>
                                    <div><h3 className="font-bold text-lg">{t(event.category)}</h3><p className="opacity-80 text-sm">{event.title}</p></div>
                                </div>
                                <div className="flex items-center gap-2 opacity-70"><Clock size={16}/> {(event._occDate || event.date)} um {event.time}</div>
                                {event._occDate && event._occDate !== event.date && <div className="text-xs opacity-60">Basisdatum: {event.date} (Serie)</div>}
                                {(event.repeat && event.repeat !== 'none') && (
                                    <div className="flex items-center gap-2 opacity-70">
                                        <Repeat size={16}/> {t('repeat')}: {t(event.repeat === 'daily' ? 'repeatDaily' : event.repeat === 'weekly' ? 'repeatWeekly' : event.repeat === 'monthly' ? 'repeatMonthly' : 'repeatYearly')}
                                    </div>
                                )}

                                {event.location && <div className="flex items-center gap-2 opacity-70"><MapPin size={16}/> {event.location}</div>}
                                
                                {/* Time Planning Info */}
                                {(event.duration || event.travelTime || event.bufferTime) && (
                                    <div className="mt-3 p-3 rounded-lg bg-blue-500/10">
                                    <div className="text-xs font-bold opacity-70 mb-2">{t('timePlanning')}</div>
                                        <div className="space-y-1 text-sm">
                                            {event.duration && <div>{t('durationLabel')}: {event.duration} {t('minutesLabel')}</div>}
                                            {event.travelTime > 0 && <div>üöó {t('travelTimeLabel')}: {event.travelTime} {t('minutesLabel')}</div>}
                                            {event.bufferTime > 0 && <div>‚è∏Ô∏è {t('bufferTimeLabel')}: {event.bufferTime} {t('minutesLabel')}</div>}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Smart Reminder Info */}
                                {event.smartReminder && (
                                    <div className="mt-3 p-3 rounded-lg bg-purple-500/10">
                                    <div className="text-xs font-bold opacity-70 mb-2">{t('smartReminder')}</div>
                                        <div className="text-sm">
                                            {event.reminderType === 'fixed' && `${event.reminderMinutes} ${t('minutesBefore')}`}
                                            {event.reminderType === 'workHours' && t('workHoursReminderOption')}
                                            {event.reminderType === 'location' && t('locationReminderOption')}
                                            {event.reminderType === 'pattern' && t('patternReminderOption')}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Invitees Section */}
                                {event.participants && event.participants.length > 0 && (
                                    <div className="mt-4 pt-4 border-t border-slate-700/50">
                                        <h3 className="text-sm font-bold opacity-70 mb-3 uppercase">{t('invitees')}</h3>
                                        <div className="space-y-2">
                                            {event.participants.map((participant, idx) => {
                                                const isOrganizer = participant.userId === event.createdBy;
                                                const isCurrentUser = participant.userId === currentUserId;
                                                const canOrganizerUpdateParticipant = event.createdBy === currentUserId && !isOrganizer && participant.userId;
                                                const statusColors = {
                                                    accepted: 'text-green-400 bg-green-500/10',
                                                    declined: 'text-red-400 bg-red-500/10',
                                                    maybe: 'text-yellow-400 bg-yellow-500/10',
                                                    pending: 'text-gray-400 bg-gray-500/10'
                                                };
                                                const statusLabels = {
                                                    accepted: t('going'),
                                                    declined: t('declined'),
                                                    maybe: t('maybe'),
                                                    pending: t('noResponse')
                                                };
                                                
                                                return (
                                                    <div key={participant.userId || participant.email || `participant-${idx}`} className={`flex items-center justify-between p-3 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                                        <div className="flex items-center gap-2 flex-1">
                                                            <div className="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white text-xs font-bold">
                                                                {(participant.userName || participant.email || 'U').charAt(0).toUpperCase()}
                                                            </div>
                                                            <div className="flex flex-col flex-1">
                                                                <span className="text-sm font-semibold">
                                                                    {participant.userName || participant.email || 'Unknown'}
                                                                    {isOrganizer && <span className="ml-2 text-xs opacity-60">({t('organizer')})</span>}
                                                                </span>
                                                                {participant.email && participant.userName && (
                                                                    <span className="text-xs opacity-60">{participant.email}</span>
                                                                )}
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-2">
                                                            {isCurrentUser && !isOrganizer ? (
                                                                <select 
                                                                    value={currentUserStatus}
                                                                    onChange={(e) => handleResponseStatusChange(e.target.value)}
                                                                    className={`text-xs px-2 py-1 rounded ${statusColors[currentUserStatus] || statusColors.pending} outline-none cursor-pointer`}
                                                                >
                                                                    <option value="accepted">{t('going')}</option>
                                                                    <option value="maybe">{t('maybe')}</option>
                                                                    <option value="declined">{t('declined')}</option>
                                                                </select>
                                                            ) : canOrganizerUpdateParticipant ? (
                                                                <select 
                                                                    value={participant.status || 'pending'}
                                                                    onChange={(e) => onUpdateParticipantStatus(event.id, participant.userId, e.target.value)}
                                                                    className={`text-xs px-2 py-1 rounded ${statusColors[participant.status] || statusColors.pending} outline-none cursor-pointer`}
                                                                >
                                                                    <option value="accepted">{t('going')}</option>
                                                                    <option value="maybe">{t('maybe')}</option>
                                                                    <option value="declined">{t('declined')}</option>
                                                                    <option value="pending">{t('noResponse')}</option>
                                                                </select>
                                                            ) : (
                                                                <span className={`text-xs px-2 py-1 rounded ${statusColors[participant.status] || statusColors.pending}`}>
                                                                    {statusLabels[participant.status] || statusLabels.pending}
                                                                </span>
                                                            )}
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Tasks Section */}
                                <div className="mt-4 pt-4 border-t border-slate-700/50">
                                    <h3 className="text-sm font-bold opacity-70 mb-3 uppercase">{t('tasks')}</h3>
                                    
                                    {/* Task List */}
                                    {tasks.length === 0 ? (
                                        <div className="text-sm opacity-60 text-center py-2">{t('noTasks')}</div>
                                    ) : (
                                        <div className="space-y-3 mb-4">
                                            {tasks.map((task) => {
                                                const taskTime = getTaskTimeStatus(task.id, taskTimeEntries);
                                                const taskEntries = taskTime.entries;
                                                const taskTimeLabel = taskTime.label;
                                                const statusColors = {
                                                    open: 'text-blue-400 bg-blue-500/10',
                                                    inProgress: 'text-yellow-400 bg-yellow-500/10',
                                                    completed: 'text-green-400 bg-green-500/10'
                                                };
                                                const priorityColors = {
                                                    high: 'border-red-500',
                                                    normal: 'border-slate-700',
                                                    low: 'border-gray-600'
                                                };
                                                
                                                return (
                                                    <div key={task.id} className={`p-3 rounded-lg border-2 ${priorityColors[task.priority] || priorityColors.normal} ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                                        <div className="flex items-start justify-between mb-2">
                                                            <div className="flex-1">
                                                                <div className="font-semibold text-sm">{task.title}</div>
                                                                {task.dueDate && (
                                                                    <div className="text-xs opacity-60 mt-1">
                                                                        <Clock size={12} className="inline mr-1" />
                                                                        {task.dueDate}
                                                                    </div>
                                                                )}
                                                                {task.responsible && (
                                                                    <div className="text-xs opacity-60 mt-1">
                                                                        <User size={12} className="inline mr-1" />
                                                                        {task.responsible}
                                                                    </div>
                                                                )}
                                                                {task.reminder && (
                                                                    <div className="text-xs opacity-60 mt-1">
                                                                        <Bell size={12} className="inline mr-1" />
                                                                        {task.reminder}
                                                                    </div>
                                                                )}
                                                                {(taskEntries.length > 0 || activeTaskTimers[task.id]) && (
                                                                    <div className="text-xs opacity-60 mt-1 flex items-center gap-2">
                                                                        <Clock size={12} className="inline mr-1" />
                                                                        {t('timeTracked')}: {taskTimeLabel}
                                                                    </div>
                                                                )}
                                                            </div>
                                                            <div className="flex items-center gap-2">
                                                                <button 
                                                                    onClick={() => deleteTask(task.id)}
                                                                    className="text-red-400 hover:text-red-300 p-1"
                                                                >
                                                                    <Trash2 size={14} />
                                                                </button>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* Task Status and Priority */}
                                                        <div className="flex gap-2 mb-2">
                                                            <select 
                                                                value={task.status}
                                                                onChange={(e) => updateTask(task.id, { status: e.target.value })}
                                                                className={`text-xs px-2 py-1 rounded ${statusColors[task.status] || statusColors.open} outline-none cursor-pointer`}
                                                            >
                                                                <option value="open">{t('statusOpen')}</option>
                                                                <option value="inProgress">{t('statusInProgress')}</option>
                                                                <option value="completed">{t('statusCompleted')}</option>
                                                            </select>
                                                            <select 
                                                                value={task.priority}
                                                                onChange={(e) => updateTask(task.id, { priority: e.target.value })}
                                                                className="text-xs px-2 py-1 rounded bg-black/20 outline-none cursor-pointer"
                                                            >
                                                                <option value="high">{t('priorityHigh')}</option>
                                                                <option value="normal">{t('priorityNormal')}</option>
                                                                <option value="low">{t('priorityLow')}</option>
                                                            </select>
                                                        </div>

                                                        {/* Task Time Tracking */}
                                                        <div className="mb-2">
                                                            {activeTaskTimers[task.id] ? (
                                                                <button
                                                                    onClick={() => stopTaskTimer(task.id)}
                                                                    className="w-full p-2 rounded-lg bg-red-500/20 text-red-400 font-bold flex items-center justify-center gap-2 hover:bg-red-500/30 text-xs"
                                                                >
                                                                    <Pause size={14}/> {t('stopTimer')}
                                                                </button>
                                                            ) : (
                                                                <button
                                                                    onClick={() => startTaskTimer(task.id)}
                                                                    className="w-full p-2 rounded-lg bg-green-500/20 text-green-400 font-bold flex items-center justify-center gap-2 hover:bg-green-500/30 text-xs"
                                                                >
                                                                    <Timer size={14}/> {t('startTimer')}
                                                                </button>
                                                            )}
                                                            {activeTaskTimers[task.id] && (
                                                                <div className="mt-1 text-center text-xs opacity-70">
                                                                    <span className="animate-pulse">‚óè </span>{t('timerRunning')}
                                                                </div>
                                                            )}
                                                        </div>
                                                        
                                                        {/* Checklist */}
                                                        {task.checklist && task.checklist.length > 0 && (
                                                            <div className="mt-2 space-y-1">
                                                                {task.checklist.map((item) => (
                                                                    <div key={item.id} className="flex items-center gap-2 text-xs">
                                                                        <input 
                                                                            type="checkbox" 
                                                                            checked={item.completed}
                                                                            onChange={() => toggleSubtask(task.id, item.id)}
                                                                            className="cursor-pointer"
                                                                        />
                                                                        <span className={item.completed ? 'line-through opacity-50' : ''}>{item.text}</span>
                                                                        <button 
                                                                            onClick={() => deleteSubtask(task.id, item.id)}
                                                                            className="text-red-400 hover:text-red-300 ml-auto"
                                                                        >
                                                                            <X size={12} />
                                                                        </button>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}

                                                        {taskEntries.length > 0 ? (
                                                            <div className="mt-2 space-y-2">
                                                                <div className="text-[10px] font-bold opacity-70">{t('timeEntries')}</div>
                                                                {taskEntries.map(entry => {
                                                                    const hours = Math.floor(entry.duration / 3600);
                                                                    const minutes = Math.floor((entry.duration % 3600) / 60);
                                                                    const timeStr = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
                                                                    const dateStr = entry.startTime ? new Date(entry.startTime).toLocaleDateString('de-DE', { 
                                                                        day: '2-digit', 
                                                                        month: '2-digit',
                                                                        hour: '2-digit',
                                                                        minute: '2-digit'
                                                                    }) : '';
                                                                    
                                                                    return (
                                                                        <div key={entry.id} className={`flex items-center justify-between p-2 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                                                            <div className="flex items-center gap-2">
                                                                                <Clock size={12} className="opacity-60"/>
                                                                                <span className="text-xs">{timeStr}</span>
                                                                                <span className="text-[10px] opacity-60">{dateStr}</span>
                                                                            </div>
                                                                            <button
                                                                                onClick={() => deleteTaskTimeEntry(entry.id)}
                                                                                className="text-red-400 hover:text-red-300 p-1"
                                                                                title={t('delete')}
                                                                            >
                                                                                <Trash2 size={12}/>
                                                                            </button>
                                                                        </div>
                                                                    );
                                                                })}
                                                                
                                                                <div className="p-2 rounded-lg bg-blue-500/10 flex items-center justify-between">
                                                                    <span className="text-[10px] font-bold">{t('totalTime')}:</span>
                                                                    <span className="text-[10px] font-bold">{taskTimeLabel}</span>
                                                                </div>
                                                            </div>
                                                        ) : (
                                                            <div className="text-[10px] opacity-60 text-center py-1">{t('noTimeEntries')}</div>
                                                        )}
                                                        
                                                        {/* Add Subtask */}
                                                        <div className="mt-2 flex gap-1">
                                                            <input 
                                                                type="text"
                                                                value={newSubtaskText[task.id] || ''}
                                                                onChange={(e) => setNewSubtaskText({ ...newSubtaskText, [task.id]: e.target.value })}
                                                                onKeyPress={(e) => e.key === 'Enter' && addSubtask(task.id)}
                                                                placeholder={t('addSubtask')}
                                                                className={`flex-1 px-2 py-1 text-xs rounded outline-none ${themeClasses.input}`}
                                                            />
                                                            <button 
                                                                onClick={() => addSubtask(task.id)}
                                                                className="px-2 py-1 bg-blue-500/20 text-blue-400 rounded text-xs"
                                                            >
                                                                <Plus size={14} />
                                                            </button>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                    
                                    {/* Add New Task Form */}
                                    <div className={`p-3 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/10'} space-y-2`}>
                                        <input 
                                            type="text"
                                            value={newTaskTitle}
                                            onChange={(e) => setNewTaskTitle(e.target.value)}
                                            placeholder={t('taskTitle')}
                                            className={`w-full px-2 py-2 text-sm rounded outline-none ${themeClasses.input}`}
                                        />
                                        <div className="grid grid-cols-2 gap-2">
                                            <input 
                                                type="date"
                                                value={newTaskDueDate}
                                                onChange={(e) => setNewTaskDueDate(e.target.value)}
                                                placeholder={t('dueDate')}
                                                className={`px-2 py-1 text-xs rounded outline-none ${themeClasses.input}`}
                                            />
                                            <input 
                                                type="datetime-local"
                                                value={newTaskReminder}
                                                onChange={(e) => setNewTaskReminder(e.target.value)}
                                                placeholder={t('taskReminder')}
                                                className={`px-2 py-1 text-xs rounded outline-none ${themeClasses.input}`}
                                            />
                                        </div>
                                        <select 
                                            value={newTaskResponsible}
                                            onChange={(e) => setNewTaskResponsible(e.target.value)}
                                            className={`w-full px-2 py-1 text-xs rounded outline-none ${themeClasses.select}`}
                                        >
                                            <option value="">{t('unassigned')}</option>
                                            {(event.participants || []).map((p, idx) => (
                                                <option key={p.userId || idx} value={p.userName || p.email}>
                                                    {p.userName || p.email}
                                                </option>
                                            ))}
                                        </select>
                                        <div className="flex gap-2">
                                            <select 
                                                value={newTaskStatus}
                                                onChange={(e) => setNewTaskStatus(e.target.value)}
                                                className={`flex-1 px-2 py-1 text-xs rounded outline-none ${themeClasses.select}`}
                                            >
                                                <option value="open">{t('statusOpen')}</option>
                                                <option value="inProgress">{t('statusInProgress')}</option>
                                                <option value="completed">{t('statusCompleted')}</option>
                                            </select>
                                            <select 
                                                value={newTaskPriority}
                                                onChange={(e) => setNewTaskPriority(e.target.value)}
                                                className={`flex-1 px-2 py-1 text-xs rounded outline-none ${themeClasses.select}`}
                                            >
                                                <option value="high">{t('priorityHigh')}</option>
                                                <option value="normal">{t('priorityNormal')}</option>
                                                <option value="low">{t('priorityLow')}</option>
                                            </select>
                                        </div>
                                        <button 
                                            onClick={addTask}
                                            className={`w-full py-2 rounded-lg font-bold text-sm ${themeClasses.button}`}
                                        >
                                            <Plus size={16} className="inline mr-1" /> {t('addTask')}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Availability Overview Modal - Shows free/busy status of connected contacts
        const AvailabilityOverviewModal = ({ show, onClose, selectedDate, themeClasses, isComic, user, friends, allEvents }) => {
            if (!show) return null;
            
            const [selectedContacts, setSelectedContacts] = useState([]);
            const [viewDate, setViewDate] = useState(selectedDate);
            
            const hours = Array.from({ length: 24 }, (_, i) => i);
            const dateStr = formatDate(viewDate);
            
            const toggleContact = (friendId) => {
                if (selectedContacts.includes(friendId)) {
                    setSelectedContacts(selectedContacts.filter(id => id !== friendId));
                } else {
                    setSelectedContacts([...selectedContacts, friendId]);
                }
            };
            
            const isContactBusy = (friendId, hour) => {
                // Check if friend has events at this hour
                const friendEvents = allEvents.filter(ev => {
                    if (!ev.participants) return false;
                    const hasParticipant = ev.participants.find(p => p.userId === friendId && p.status === 'accepted');
                    if (!hasParticipant) return false;
                    
                    // Check if event is on this date and at this hour
                    const evDate = ev._occDate || ev.date;
                    if (evDate !== dateStr) return false;
                    
                    // Parse time to get event start and end in decimal hours
                    const timeParts = (ev.time || '00:00').split(':');
                    const evStartHour = parseInt(timeParts[0]);
                    const evStartMinute = parseInt(timeParts[1] || '0');
                    const evStartDecimal = evStartHour + (evStartMinute / 60);
                    
                    const duration = ev.duration || 60;
                    const evEndDecimal = evStartDecimal + (duration / 60);
                    
                    // Check if the given hour overlaps with the event time
                    return hour >= Math.floor(evStartDecimal) && hour < Math.ceil(evEndDecimal);
                });
                
                return friendEvents.length > 0;
            };
            
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className={`w-full max-w-4xl rounded-2xl p-6 max-h-[90vh] overflow-y-auto ${isComic?'bg-[#f4e4bc] border-4 border-[#8b5a2b] text-[#4a3b2a]':'bg-slate-900 border border-slate-700 text-white'}`}>
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-xl font-bold">üìÖ Verf√ºgbarkeits-√úbersicht</h2>
                            <button onClick={onClose} className="p-2 opacity-70 hover:opacity-100">
                                <X size={24}/>
                            </button>
                        </div>
                        
                        {/* Date selector */}
                        <div className="flex items-center justify-between mb-6 p-3 rounded-lg bg-black/10">
                            <button 
                                onClick={() => {
                                    const prev = new Date(viewDate);
                                    prev.setDate(prev.getDate() - 1);
                                    setViewDate(prev);
                                }}
                                className="p-2"
                            >
                                <ChevronLeft size={20}/>
                            </button>
                            <div className="font-bold">
                                {viewDate.toLocaleDateString(getCurrentLocale(), { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}
                            </div>
                            <button 
                                onClick={() => {
                                    const next = new Date(viewDate);
                                    next.setDate(next.getDate() + 1);
                                    setViewDate(next);
                                }}
                                className="p-2"
                            >
                                <ChevronRight size={20}/>
                            </button>
                        </div>
                        
                        {/* Contact selection */}
                        <div className="mb-6">
                            <div className="text-sm font-bold opacity-70 mb-2">Kontakte ausw√§hlen:</div>
                            <div className="flex flex-wrap gap-2">
                                {friends && friends.map(friend => (
                                    <button
                                        key={friend.id}
                                        onClick={() => toggleContact(friend.id)}
                                        className={`px-3 py-2 rounded-lg text-sm font-semibold transition-all ${
                                            selectedContacts.includes(friend.id)
                                                ? 'bg-blue-500 text-white'
                                                : 'bg-black/20 opacity-60'
                                        }`}
                                    >
                                        {friend.name || friend.shareCode}
                                    </button>
                                ))}
                                {(!friends || friends.length === 0) && (
                                    <div className="text-sm opacity-60">Keine Freunde verf√ºgbar. F√ºge Freunde hinzu, um deren Verf√ºgbarkeit zu sehen.</div>
                                )}
                            </div>
                        </div>
                        
                        {/* Availability grid */}
                        {selectedContacts.length > 0 && (
                            <div className="overflow-x-auto">
                                <table className="w-full text-sm">
                                    <thead>
                                        <tr className={`${isComic ? 'bg-[#8b5a2b]/20' : 'bg-black/20'}`}>
                                            <th className="p-2 text-left font-bold">Zeit</th>
                                            {selectedContacts.map(contactId => {
                                                const contact = friends.find(f => f.id === contactId);
                                                return (
                                                    <th key={contactId} className="p-2 text-center font-bold">
                                                        {contact?.name || contact?.shareCode || 'Unbekannt'}
                                                    </th>
                                                );
                                            })}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {hours.map(hour => {
                                            const hourStr = String(hour).padStart(2, '0') + ':00';
                                            return (
                                                <tr key={hour} className="border-b border-slate-700/30">
                                                    <td className="p-2 font-mono opacity-70">{hourStr}</td>
                                                    {selectedContacts.map(contactId => {
                                                        const busy = isContactBusy(contactId, hour);
                                                        return (
                                                            <td key={contactId} className="p-2 text-center">
                                                                <div className={`inline-block px-3 py-1 rounded text-xs font-bold ${
                                                                    busy 
                                                                        ? 'bg-red-500/20 text-red-400' 
                                                                        : 'bg-green-500/20 text-green-400'
                                                                }`}>
                                                                    {busy ? 'üî¥ Belegt' : 'üü¢ Frei'}
                                                                </div>
                                                            </td>
                                                        );
                                                    })}
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            </div>
                        )}
                        
                        {selectedContacts.length === 0 && friends && friends.length > 0 && (
                            <div className="text-center py-8 opacity-60">
                                W√§hle Kontakte aus, um deren Verf√ºgbarkeit zu sehen
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const EventModal = ({ show, onClose, onSave, selectedDate, themeClasses, isComic, user, viewingFriendId, viewingFriendName, currentUserName }) => {
            if (!show) return null;
            const [formData, setFormData] = useState({ 
                title: '', 
                date: formatDate(selectedDate), 
                time: '12:00', 
                category: 'personal', 
                repeat: 'none', 
                location: '', 
                duration: 60, // Duration in minutes
                travelTime: 0, // Travel time before event in minutes
                bufferTime: 0, // Buffer time after event in minutes
                smartReminder: false, // Enable smart reminders
                reminderType: 'fixed', // 'fixed', 'workHours', 'location', 'pattern'
                reminderMinutes: 15, // Minutes before event for fixed reminders
            });
            const defaultMode = viewingFriendId ? 'request' : 'self';
            const [createMode, setCreateMode] = useState(defaultMode);
            const [invitees, setInvitees] = useState([]);
            const [friends, setFriends] = useState([]);
            const [templates, setTemplates] = useState([]);
            const [showTemplateSection, setShowTemplateSection] = useState(false);
            const [templateName, setTemplateName] = useState('');
            
            // Fetch event templates
            useEffect(() => {
                if (!user || !show) return;
                const unsub = onSnapshot(collection(db, 'artifacts', appId, 'users', user.uid, 'eventTemplates'), (snap) => {
                    const tmps = [];
                    snap.forEach(doc => {
                        tmps.push({ id: doc.id, ...doc.data() });
                    });
                    setTemplates(tmps);
                }, err => console.error("Templates Error", err));
                return () => unsub();
            }, [user, show]);
            
            // Fetch friends list for invitations
            useEffect(() => {
                if (!user || !show) return;
                const unsub = onSnapshot(collection(db, 'artifacts', appId, 'users', user.uid, 'friends'), (snap) => {
                    const fris = [];
                    snap.forEach(doc => {
                        const d = doc.data();
                        if (d.status === 'accepted') fris.push({ id: doc.id, ...d });
                    });
                    setFriends(fris);
                }, err => console.error("Friends Error", err));
                return () => unsub();
            }, [user, show]);
            
            const addFriendAsInvitee = (friendId, friendName) => {
                if (!invitees.find(inv => inv.userId === friendId)) {
                    setInvitees([...invitees, { userId: friendId, userName: friendName, status: 'pending' }]);
                }
            };
            
            const removeInvitee = (index) => {
                setInvitees(invitees.filter((_, i) => i !== index));
            };
            
            const loadTemplate = (template) => {
                setFormData({
                    ...formData,
                    title: template.title || '',
                    category: template.category || 'personal',
                    location: template.location || '',
                    duration: template.duration || 60,
                    travelTime: template.travelTime || 0,
                    bufferTime: template.bufferTime || 0,
                    smartReminder: template.smartReminder || false,
                    reminderType: template.reminderType || 'fixed',
                    reminderMinutes: template.reminderMinutes || 15
                });
            };
            
            const saveAsTemplate = async () => {
                if (!templateName.trim()) {
                    alert(t('templateNameRequired'));
                    return;
                }
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'users', user.uid, 'eventTemplates'), {
                        name: templateName,
                        title: formData.title,
                        category: formData.category,
                        location: formData.location,
                        duration: formData.duration,
                        travelTime: formData.travelTime,
                        bufferTime: formData.bufferTime,
                        smartReminder: formData.smartReminder,
                        reminderType: formData.reminderType,
                        reminderMinutes: formData.reminderMinutes,
                        createdAt: serverTimestamp()
                    });
                    setTemplateName('');
                    setShowTemplateSection(false);
                    alert(t('templateSaveSuccess'));
                } catch (e) {
                    console.error("Save template error", e);
                    alert(t('templateSaveError'));
                }
            };
            
            const deleteTemplate = async (templateId) => {
                if (!confirm(t('templateDeleteConfirm'))) return;
                try {
                    await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'eventTemplates', templateId));
                } catch (e) {
                    console.error("Delete template error", e);
                    alert(t('templateDeleteError'));
                }
            };
            
            const handleSave = () => {
                const { timezone, ...cleanData } = formData;
                onSave({ ...cleanData, invitees }, createMode);
            };
            
            return (
                <div className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className={`w-full max-w-md rounded-2xl p-6 max-h-[90vh] overflow-y-auto ${isComic?'bg-[#f4e4bc] border-4 border-[#8b5a2b] text-[#4a3b2a]':'bg-slate-900 border border-slate-700'}`}>
                        <h2 className="text-xl font-bold mb-4">{t('newEvent')}</h2>
                        {viewingFriendId && (
                            <div className="mb-3 p-3 rounded-xl border border-slate-700/60 bg-black/20">
                                <div className="text-xs font-bold opacity-80 mb-2">Erstellen</div>
                                <div className="space-y-2">
                                    <label className="flex items-center gap-2 text-sm">
                                        <input type="radio" name="createMode" checked={createMode==='self'} onChange={()=>setCreateMode('self')} />
                                        <span>Nur f√ºr mich</span>
                                    </label>
                                    <label className="flex items-center gap-2 text-sm">
                                        <input type="radio" name="createMode" checked={createMode==='request'} onChange={()=>setCreateMode('request')} />
                                        <span>Als Anfrage an <span className="font-bold">{viewingFriendName || 'Freund'}</span> (im Freund-Kalender nach Best√§tigung)</span>
                                    </label>
                                    <label className="flex items-center gap-2 text-sm">
                                        <input type="radio" name="createMode" checked={createMode==='self_and_request'} onChange={()=>setCreateMode('self_and_request')} />
                                        <span>F√ºr mich + Anfrage an <span className="font-bold">{viewingFriendName || 'Freund'}</span></span>
                                    </label>
                                </div>
                            </div>
                        )}
                        <div className="space-y-4">
                            <div>
                                <label className="text-xs opacity-70 block mb-1 font-bold">{t('category')}</label>
                                <div className="grid grid-cols-5 gap-2">{CATEGORIES.map(cat => <button key={cat.id} onClick={() => setFormData({...formData, category: cat.id})} className={`p-2 rounded-lg flex flex-col items-center gap-1 transition-all ${formData.category === cat.id ? 'bg-blue-600/30 border border-blue-500' : 'opacity-60'}`}><span className="text-xl">{cat.icon}</span><span className="text-[9px]">{t(cat.id)}</span></button>)}</div>
                            </div>
                            
                            {/* Templates Section */}
                            {templates.length > 0 && (
                                <div className="p-3 rounded-lg bg-purple-500/10 border border-purple-500/30">
                                    <details>
                                        <summary className="text-xs font-bold cursor-pointer mb-2">{t('templates')}</summary>
                                        <div className="space-y-2 mt-2">
                                            {templates.map(template => (
                                                <div key={template.id} className="flex items-center justify-between gap-2">
                                                    <button
                                                        type="button"
                                                        onClick={() => loadTemplate(template)}
                                                        className="flex-1 text-left p-2 rounded bg-black/20 hover:bg-black/30 text-sm"
                                                    >
                                                        {template.name}
                                                    </button>
                                                    <button
                                                        type="button"
                                                        onClick={() => deleteTemplate(template.id)}
                                                        className="p-2 text-red-400 hover:text-red-300"
                                                    >
                                                        <Trash2 size={14}/>
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    </details>
                                </div>
                            )}
                            
                            <input value={formData.title} onChange={e => setFormData({...formData, title: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`} placeholder={t('title')}/>
                            <div className="grid grid-cols-2 gap-2"><input type="date" value={formData.date} onChange={e => setFormData({...formData, date: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}/><input type="time" value={formData.time} onChange={e => setFormData({...formData, time: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}/></div>
                            <div>
                                <label className="text-xs opacity-70 block mb-1 font-bold">{t('repeat')}</label>
                                <select value={formData.repeat || 'none'} onChange={e => setFormData({...formData, repeat: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.select}`}>
                                    <option value="none">{t('repeatNone')}</option>
                                    <option value="daily">{t('repeatDaily')}</option>
                                    <option value="weekly">{t('repeatWeekly')}</option>
                                    <option value="monthly">{t('repeatMonthly')}</option>
                                    <option value="yearly">{t('repeatYearly')}</option>
                                </select>
                            </div>
                            <input value={formData.location || ''} onChange={e => setFormData({...formData, location: e.target.value})} className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`} placeholder={t('location')}/>
                            
                            {/* Duration and Time Management Section */}
                            <div className="pt-4 border-t border-slate-700/50">
                                <label className="text-xs opacity-70 block mb-3 font-bold uppercase">{t('timePlanning')}</label>
                                
                                <div className="space-y-3">
                                    {/* Duration */}
                                    <div>
                                        <label className="text-xs opacity-70 block mb-1">{t('durationMinutes')}</label>
                                        <input 
                                            type="number" 
                                            value={formData.duration || 60} 
                                            onChange={e => setFormData({...formData, duration: parseInt(e.target.value) || 60})} 
                                            className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}
                                            min="15"
                                            step="15"
                                        />
                                    </div>
                                    
                                    {/* Travel Time */}
                                    <div>
                                        <label className="text-xs opacity-70 block mb-1">{t('travelTimeBefore')}</label>
                                        <input 
                                            type="number" 
                                            value={formData.travelTime || 0} 
                                            onChange={e => setFormData({...formData, travelTime: parseInt(e.target.value) || 0})} 
                                            className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}
                                            min="0"
                                            step="5"
                                        />
                                        <div className="text-[10px] opacity-60 mt-1">{t('travelTimeHint')}</div>
                                    </div>
                                    
                                    {/* Buffer Time */}
                                    <div>
                                        <label className="text-xs opacity-70 block mb-1">{t('bufferTimeAfter')}</label>
                                        <input 
                                            type="number" 
                                            value={formData.bufferTime || 0} 
                                            onChange={e => setFormData({...formData, bufferTime: parseInt(e.target.value) || 0})} 
                                            className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}
                                            min="0"
                                            step="5"
                                        />
                                        <div className="text-[10px] opacity-60 mt-1">{t('bufferTimeHint')}</div>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Smart Reminders Section */}
                            <div className="pt-4 border-t border-slate-700/50">
                                <label className="text-xs opacity-70 block mb-3 font-bold uppercase">{t('smartReminders')}</label>
                                
                                <div className="space-y-3">
                                    {/* Smart Reminder Toggle */}
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input 
                                            type="checkbox" 
                                            checked={formData.smartReminder || false}
                                            onChange={e => setFormData({...formData, smartReminder: e.target.checked})}
                                            className="w-4 h-4"
                                        />
                                        <span className="text-sm">{t('enableSmartReminder')}</span>
                                    </label>
                                    
                                    {formData.smartReminder && (
                                        <div className="space-y-3 pl-6">
                                            {/* Reminder Type */}
                                            <div>
                                        <label className="text-xs opacity-70 block mb-1">{t('reminderType')}</label>
                                                <select 
                                                    value={formData.reminderType || 'fixed'} 
                                                    onChange={e => setFormData({...formData, reminderType: e.target.value})} 
                                                    className={`w-full p-2 text-sm rounded-lg outline-none ${themeClasses.select}`}
                                                >
                                            <option value="fixed">{t('fixedReminderOption')}</option>
                                            <option value="workHours">{t('workHoursReminderOption')}</option>
                                            <option value="location">{t('locationReminderOption')}</option>
                                            <option value="pattern">{t('patternReminderOption')}</option>
                                        </select>
                                    </div>
                                            
                                            {/* Fixed Reminder Time */}
                                            {formData.reminderType === 'fixed' && (
                                                <div>
                                            <label className="text-xs opacity-70 block mb-1">{t('minutesBefore')}</label>
                                                    <select 
                                                        value={formData.reminderMinutes || 15} 
                                                        onChange={e => setFormData({...formData, reminderMinutes: parseInt(e.target.value)})} 
                                                        className={`w-full p-2 text-sm rounded-lg outline-none ${themeClasses.select}`}
                                                    >
                                                    <option value="5">5 {t('minutesLabel')}</option>
                                                    <option value="15">15 {t('minutesLabel')}</option>
                                                    <option value="30">30 {t('minutesLabel')}</option>
                                                    <option value="60">1 {t('hourLabel')}</option>
                                                    <option value="120">2 {t('hoursLabel')}</option>
                                                    <option value="1440">1 {t('dayLabel')}</option>
                                                </select>
                                            </div>
                                        )}
                                            
                                            {formData.reminderType === 'workHours' && (
                                            <div className="text-xs opacity-60 p-2 bg-blue-500/10 rounded">
                                                {t('workHoursReminderHint')}
                                            </div>
                                        )}
                                            
                                            {formData.reminderType === 'location' && (
                                            <div className="text-xs opacity-60 p-2 bg-blue-500/10 rounded">
                                                {t('locationReminderHint')}
                                            </div>
                                        )}
                                            
                                            {formData.reminderType === 'pattern' && (
                                            <div className="text-xs opacity-60 p-2 bg-blue-500/10 rounded">
                                                {t('patternReminderHint')}
                                            </div>
                                        )}
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            {/* Event Templates Section */}
                            <div className="pt-4 border-t border-slate-700/50">
                                <div className="flex items-center justify-between mb-3">
                                    <label className="text-xs opacity-70 font-bold uppercase">{t('eventTemplates')}</label>
                                    <button
                                        type="button"
                                        onClick={() => setShowTemplateSection(!showTemplateSection)}
                                        className="text-xs px-2 py-1 rounded bg-blue-500/20 text-blue-400"
                                    >
                                        {showTemplateSection ? t('hide') : t('saveAsTemplate')}
                                    </button>
                                </div>
                                
                                {/* Load from template */}
                                {templates.length > 0 && (
                                    <div className="mb-3">
                                        <div className="text-xs opacity-60 mb-2">{t('loadTemplate')}</div>
                                        <div className="space-y-2">
                                            {templates.map(tmpl => (
                                                <div key={tmpl.id} className={`flex items-center justify-between p-2 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                                    <button
                                                        type="button"
                                                        onClick={() => loadTemplate(tmpl)}
                                                        className="flex-1 text-left"
                                                    >
                                                        <div className="text-sm font-semibold">{tmpl.name}</div>
                                                        <div className="text-xs opacity-60">{tmpl.title || t('noDescription')}</div>
                                                    </button>
                                                    <button
                                                        type="button"
                                                        onClick={() => deleteTemplate(tmpl.id)}
                                                        className="text-red-400 p-1 ml-2"
                                                    >
                                                        <Trash2 size={14}/>
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Save as template */}
                                {showTemplateSection && (
                                    <div className="space-y-2 p-3 rounded-lg bg-blue-500/10">
                                        <input
                                            type="text"
                                            value={templateName}
                                            onChange={e => setTemplateName(e.target.value)}
                                            placeholder={t('templateNamePlaceholder')}
                                            className={`w-full p-2 text-sm rounded-lg outline-none ${themeClasses.input}`}
                                        />
                                        <button
                                            type="button"
                                            onClick={saveAsTemplate}
                                            className="w-full py-2 rounded-lg bg-blue-500 text-white font-bold text-sm"
                                        >
                                            {t('saveTemplate')}
                                        </button>
                                        <div className="text-[10px] opacity-60">
                                            {t('templateSaveHint')}
                                        </div>
                                    </div>
                                )}
                            </div>
                            
                            {/* Invitees Section */}
                            {!viewingFriendId && (
                                <div className="pt-4 border-t border-slate-700/50">
                                    <label className="text-xs opacity-70 block mb-3 font-bold uppercase">{t('inviteParticipants')}</label>
                                    
                                    {/* Friends quick-add */}
                                    {friends.length > 0 && (
                                        <div className="mb-3">
                                            <div className="text-xs opacity-60 mb-2">{t('myFriends')}</div>
                                            <div className="flex flex-wrap gap-2">
                                                {friends.map(friend => (
                                                    <button
                                                        key={friend.id}
                                                        type="button"
                                                        onClick={() => addFriendAsInvitee(friend.id, friend.name || friend.shareCode)}
                                                        disabled={invitees.find(inv => inv.userId === friend.id)}
                                                        className={`text-xs px-2 py-1 rounded ${invitees.find(inv => inv.userId === friend.id) ? 'bg-blue-500/50 opacity-50 cursor-not-allowed' : 'bg-blue-500/20 text-blue-400 hover:bg-blue-500/30'}`}
                                                    >
                                                        + {friend.name || friend.shareCode}
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                    
                                    {/* Invitees list */}
                                    {invitees.length > 0 && (
                                        <div className="space-y-2">
                                            {invitees.map((inv, idx) => (
                                                <div key={inv.userId || inv.email || `inv-${idx}`} className={`flex items-center justify-between p-2 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                                    <div className="flex items-center gap-2 flex-1">
                                                        <div className="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center text-white text-xs">
                                                            {(inv.userName || inv.name || inv.email || 'U').charAt(0).toUpperCase()}
                                                        </div>
                                                        <div className="flex flex-col">
                                                            <span className="text-xs font-semibold">{inv.userName || inv.name || inv.email}</span>
                                                            {inv.email && (inv.userName || inv.name) && <span className="text-[10px] opacity-60">{inv.email}</span>}
                                                        </div>
                                                    </div>
                                                    <button
                                                        type="button"
                                                        onClick={() => removeInvitee(idx)}
                                                        className="text-red-400 p-1"
                                                    >
                                                        <X size={14}/>
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            )}

                            <div className="flex gap-3 mt-4"><button onClick={onClose} className="flex-1 py-3 rounded-xl font-bold opacity-70 bg-slate-800">{t('cancel')}</button><button onClick={handleSave} className={`flex-1 py-3 rounded-xl font-bold ${themeClasses.button}`}>{t('save')}</button></div>
                        </div>
                    </div>
                </div>
            );
        };

        const DayOptionsModal = ({ show, onClose, onAssignShift, onCreateEvent, onClearShift, selectedDate, shifts, themeClasses, isComic, viewingFriend, disableShiftInteractions }) => {
            if (!show) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className={`w-full max-w-md rounded-2xl p-6 ${isComic?'bg-[#f4e4bc] border-4 border-[#8b5a2b] text-[#4a3b2a]':'bg-slate-900 border border-slate-700'}`}>
                        <div className="flex justify-between items-center mb-6"><h2 className="text-xl font-bold">{t('dayOptions')}</h2><button onClick={onClose}><X /></button></div>
                        <div className="space-y-4">
                            {!viewingFriend && !disableShiftInteractions && (
                                <>
                                    <div className="grid grid-cols-2 gap-2">{shifts.map(s => <button key={s.id} onClick={() => { onAssignShift(formatDate(selectedDate), s.id); onClose(); }} className="p-3 rounded-lg flex items-center justify-center gap-2 font-bold text-sm" style={{ backgroundColor: s.color + '40', border: `1px solid ${s.color}`, color: isComic?'#4a3b2a':'white' }}><div className="w-3 h-3 rounded-full" style={{ backgroundColor: s.color }}></div> {s.name}</button>)}</div>
                                    <button onClick={() => { onClearShift(formatDate(selectedDate)); onClose(); }} className="w-full py-3 bg-red-500/10 text-red-400 border border-red-500/30 rounded-xl font-bold flex items-center justify-center gap-2"><Trash2 size={18}/> {t('clearShift')}</button>
                                </>
                            )}
                            <button onClick={() => { onClose(); onCreateEvent(); }} className={`w-full py-4 rounded-xl font-bold flex items-center justify-center gap-2 ${themeClasses.button}`}><Plus size={20}/> {t('createEvent')}</button>
                        </div>
                    </div>
                </div>
            )
        };



        const WeatherLocationModal = ({ show, onClose, currentPref, onSave }) => {
            const [mode, setMode] = useState(currentPref?.mode || "geo"); // geo | manual
            const [queryText, setQueryText] = useState("");
            const [results, setResults] = useState([]);
            const [loading, setLoading] = useState(false);
            const [err, setErr] = useState("");

            useEffect(() => {
                if (!show) return;
                setMode(currentPref?.mode || "geo");
                setResults([]);
                setErr("");
                setQueryText(currentPref?.manual?.label || "");
            }, [show]);

            const doSearch = async () => {
                const q = (queryText || "").trim();
                if (!q) return;
                if (!navigator.onLine) { setErr("Offline ‚Äì Suche nicht verf√ºgbar."); return; }
                setErr("");
                setLoading(true);
                try {
                    const res = await fetch(buildGeocodeUrl(q));
                    if (!res.ok) throw new Error("HTTP " + res.status);
                    const data = await res.json();
                    const list = (data?.results || []).map(r => ({
                        label: [r.name, r.admin1, r.country].filter(Boolean).join(", "),
                        lat: r.latitude,
                        lon: r.longitude
                    }));
                    setResults(list);
                    if (list.length === 0) setErr("Keine Treffer gefunden.");
                } catch (e) {
                    console.error(e);
                    setErr("Suche aktuell nicht verf√ºgbar.");
                } finally {
                    setLoading(false);
                }
            };

            const choose = (place) => {
                onSave({ mode: "manual", manual: place });
            };

            const saveGeo = () => {
                onSave({ mode: "geo", manual: currentPref?.manual || null });
            };

            if (!show) return null;
            return (
                <div className="fixed inset-0 z-[90] flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className="w-full max-w-md rounded-2xl p-6 bg-slate-900 border border-slate-700">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-bold">Wetter-Ort ausw√§hlen</h2>
                            <button onClick={onClose}><X /></button>
                        </div>

                        <div className="grid grid-cols-2 gap-2 mb-4">
                            <button
                                onClick={() => setMode("geo")}
                                className={`p-3 rounded-xl font-bold border ${mode === "geo" ? "bg-blue-600/20 border-blue-500/30 text-blue-200" : "bg-white/5 border-slate-700 text-slate-200"}`}
                            >
                                Standort automatisch
                            </button>
                            <button
                                onClick={() => setMode("manual")}
                                className={`p-3 rounded-xl font-bold border ${mode === "manual" ? "bg-blue-600/20 border-blue-500/30 text-blue-200" : "bg-white/5 border-slate-700 text-slate-200"}`}
                            >
                                Manuell
                            </button>
                        </div>

                        {mode === "geo" ? (
                            <div className="rounded-xl border border-slate-700 bg-slate-950 p-4">
                                <div className="text-sm font-bold mb-1">Automatischer Standort</div>
                                <div className="text-xs text-slate-400 mb-3">
                                    Nutzt GPS/Browser-Standort. Falls blockiert: Fallback Z√ºrich.
                                </div>
                                <button onClick={saveGeo} className="w-full py-3 rounded-xl bg-blue-600 hover:bg-blue-700 text-white font-bold">
                                    Speichern
                                </button>
                            </div>
                        ) : (
                            <div className="rounded-xl border border-slate-700 bg-slate-950 p-4">
                                <div className="text-sm font-bold mb-1">Manueller Ort</div>
                                <div className="text-xs text-slate-400 mb-3">
                                    Suche nach Stadt/Region und w√§hle einen Treffer.
                                </div>

                                <div className="flex gap-2">
                                    <input
                                        value={queryText}
                                        onChange={(e) => setQueryText(e.target.value)}
                                        placeholder={t('citySearchPlaceholder')}
                                        className="flex-1 p-3 rounded-xl bg-slate-900 border border-slate-700 text-white outline-none focus:border-blue-500"
                                    />
                                    <button onClick={doSearch} className="px-4 rounded-xl bg-white/5 hover:bg-white/10 border border-slate-700 font-bold text-sm">
                                        {loading ? "‚Ä¶" : "Suche"}
                                    </button>
                                </div>

                                {err && <div className="mt-3 text-xs text-red-300 bg-red-500/10 border border-red-500/20 p-2 rounded-lg">{err}</div>}

                                <div className="mt-3 space-y-2 max-h-56 overflow-y-auto">
                                    {results.map((r, idx) => (
                                        <button key={idx} onClick={() => choose(r)} className="w-full text-left p-3 rounded-xl bg-white/5 hover:bg-white/10 border border-slate-700">
                                            <div className="font-bold">{r.label}</div>
                                            <div className="text-xs text-slate-400">Lat {r.lat.toFixed(4)} ¬∑ Lon {r.lon.toFixed(4)}</div>
                                        </button>
                                    ))}
                                </div>

                                {currentPref?.manual?.label && (
                                    <div className="mt-4 text-xs text-slate-400">
                                        Aktuell gespeichert: <span className="text-slate-200 font-bold">{currentPref.manual.label}</span>
                                    </div>
                                )}
                            </div>
                        )}

                        <div className="mt-4 text-[11px] text-slate-500">
                            Tipp: F√ºr konsistente Ergebnisse (ohne Standortfreigabe) Manuell verwenden.
                        </div>
                    </div>
                </div>
            );
        };

        // --- 7-DAY WEATHER FORECAST MODAL ---
        const WeatherForecastModal = ({ show, onClose, forecastData, weatherLocation }) => {
            if (!show || !forecastData) return null;

            const formatDateShort = (dateStr) => {
                const d = new Date(dateStr);
                const days = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
                const months = ['Jan', 'Feb', 'M√§r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
                return `${days[d.getDay()]}, ${d.getDate()}. ${months[d.getMonth()]}`;
            };

            return (
                <div className="fixed inset-0 z-[90] flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className="w-full max-w-2xl rounded-2xl p-6 bg-slate-900 border border-slate-700 max-h-[90vh] overflow-y-auto">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-bold">7-Tage-Wettervorhersage</h2>
                            <button onClick={onClose}><X /></button>
                        </div>

                        {weatherLocation && (
                            <div className="text-sm text-slate-400 mb-4">
                                üìç {weatherLocation}
                            </div>
                        )}

                        <div className="space-y-3">
                            {forecastData.time?.slice(0, 7).map((dateStr, idx) => (
                                <div key={dateStr} className="p-4 rounded-xl bg-slate-950 border border-slate-700 flex items-center justify-between gap-4">
                                    <div className="flex items-center gap-4 min-w-0 flex-1">
                                        <div className="text-3xl">
                                            {getWeatherMeta(forecastData.weather_code[idx]).icon}
                                        </div>
                                        <div className="min-w-0 flex-1">
                                            <div className="font-bold text-sm">{formatDateShort(dateStr)}</div>
                                            <div className="text-xs text-slate-400">{getWeatherMeta(forecastData.weather_code[idx]).label}</div>
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-3 gap-3 text-center shrink-0">
                                        <div>
                                            <div className="text-xs text-slate-400">Max</div>
                                            {isValidTemperature(forecastData.temperature_2m_max?.[idx]) && (
                                                <div className="font-bold text-orange-400">{Math.round(forecastData.temperature_2m_max[idx])}¬∞</div>
                                            )}
                                        </div>
                                        <div>
                                            <div className="text-xs text-slate-400">Min</div>
                                            {isValidTemperature(forecastData.temperature_2m_min?.[idx]) && (
                                                <div className="font-bold text-blue-400">{Math.round(forecastData.temperature_2m_min[idx])}¬∞</div>
                                            )}
                                        </div>
                                        <div>
                                            <div className="text-xs text-slate-400">üíß</div>
                                            <div className="font-bold text-sky-400">{Math.round(forecastData.precipitation_sum[idx])}mm</div>
                                        </div>
                                    </div>
                                    
                                    <div className="text-right shrink-0">
                                        <div className="text-xs text-slate-400">Wind</div>
                                        <div className="font-bold text-sm">{Math.round(forecastData.wind_speed_10m_max[idx])} km/h</div>
                                    </div>
                                </div>
                            ))}
                        </div>

                        <div className="mt-4 text-[11px] text-slate-500 text-center">
                            Datenquelle: Open-Meteo API
                        </div>
                    </div>
                </div>
            );
        };

        // --- PREMIUM GATE MODAL FOR SECRET NACHRICHTEN ---
        const PremiumGateModal = ({ show, onClose, onUnlock }) => {
            const [codeInput, setCodeInput] = useState('');
            const [error, setError] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (codeInput.trim().toLowerCase() === 'happymeal94') {
                    try {
                        if (!safeStorageSet('timeroster_secret_premium_unlocked', 'true')) {
                            console.warn('Storage blocked: cannot save unlock state.');
                        }
                    } catch (e) {
                        console.error('Failed to save unlock state', e);
                    }
                    onUnlock();
                    onClose();
                    setCodeInput('');
                    setError('');
                } else {
                    setError('Falscher Code. Bitte versuche es erneut.');
                }
            };

            if (!show) return null;

            return (
                <div className="fixed inset-0 z-[90] flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm p-4 text-white">
                    <div className="w-full max-w-md rounded-2xl p-6 bg-slate-900 border border-slate-700">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-bold">üîí Premium Freischalten</h2>
                            <button onClick={onClose}><X /></button>
                        </div>

                        <div className="mb-6">
                            <div className="text-sm mb-4">
                                Der Zugriff auf Premium.
                            </div>
                            <div className="p-4 rounded-xl bg-gradient-to-br from-amber-500/20 to-orange-500/20 border border-amber-500/30">
                                <div className="font-bold mb-2 text-amber-300">‚ú® Premium Features:</div>
                                <ul className="text-sm space-y-1 text-amber-100">
                                    <li>‚Ä¢ 1</li>
                                    <li>‚Ä¢ 2</li>
                                    <li>‚Ä¢ 3</li>
                                    <li>‚Ä¢ 4</li>
                                </ul>
                            </div>
                        </div>

                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div>
                                <label className="block text-sm font-bold mb-2">Code-Wort eingeben:</label>
                                <input
                                    type="text"
                                    value={codeInput}
                                    onChange={(e) => { setCodeInput(e.target.value); setError(''); }}
                                    placeholder={t('premiumCodePlaceholder')}
                                    className="w-full p-3 rounded-xl bg-slate-950 border border-slate-700 text-white outline-none focus:border-blue-500"
                                    autoFocus
                                />
                            </div>

                            {error && (
                                <div className="text-sm text-red-300 bg-red-500/10 border border-red-500/20 p-3 rounded-lg">
                                    {error}
                                </div>
                            )}

                            <button
                                type="submit"
                                className="w-full py-3 rounded-xl bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-bold"
                            >
                                Freischalten
                            </button>
                        </form>

                        <div className="mt-4 text-xs text-slate-500 text-center">
                            Hinweis: Der Code wird nur einmal ben√∂tigt.
                        </div>
                    </div>
                </div>
            );
        };

        // --- CALENDAR MANAGEMENT MODALS ---
        
        const CalendarManagerModal = ({ show, onClose, calendars, createCalendar, themeClasses, currentUserId, friends }) => {
            const [name, setName] = useState('');
            const [description, setDescription] = useState('');
            const [color, setColor] = useState('#3B82F6');
            const [selectedFriends, setSelectedFriends] = useState([]);
            
            if (!show) return null;
            
            const handleCreate = async () => {
                if (!name.trim()) {
                    alert(t('pleaseEnterName'));
                    return;
                }
                
                await createCalendar({ name, description, color, selectedFriends });
                setName('');
                setDescription('');
                setColor('#3B82F6');
                setSelectedFriends([]);
                onClose();
            };
            
            const toggleFriend = (friendId) => {
                setSelectedFriends(prev => 
                    prev.includes(friendId) 
                        ? prev.filter(id => id !== friendId)
                        : [...prev, friendId]
                );
            };
            
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70">
                    <div className={`w-full max-w-lg rounded-2xl p-6 max-h-[90vh] overflow-y-auto ${themeClasses.card}`}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold">{t('manageCalendars')}</h2>
                            <button onClick={onClose} className="p-2 rounded-lg hover:bg-white/5">
                                <X size={20}/>
                            </button>
                        </div>
                        
                        <div className="space-y-4 mb-6">
                            <div>
                                <label className="block text-sm font-bold mb-2">{t('newCalendarLabel')}</label>
                                <input 
                                    type="text" 
                                    value={name}
                                    onChange={(e) => setName(e.target.value)}
                                    placeholder={t('calendarNamePlaceholder')}
                                    className={`w-full p-3 rounded-lg ${themeClasses.input}`}
                                />
                            </div>
                            
                            <div>
                                <input 
                                    type="text" 
                                    value={description}
                                    onChange={(e) => setDescription(e.target.value)}
                                    placeholder={t('calendarDescriptionPlaceholder')}
                                    className={`w-full p-3 rounded-lg ${themeClasses.input}`}
                                />
                            </div>
                            
                            <div>
                                <label className="block text-sm font-bold mb-2">{t('color')}</label>
                                <div className="flex gap-2">
                                    {['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899'].map(c => (
                                        <button
                                            key={c}
                                            onClick={() => setColor(c)}
                                            className={`w-10 h-10 rounded-full border-2 ${color === c ? 'border-white scale-110' : 'border-transparent'}`}
                                            style={{ backgroundColor: c }}
                                        />
                                    ))}
                                </div>
                            </div>
                            
                            {/* Friend Selection */}
                            {friends && friends.length > 0 && (
                                <div>
                                    <label className="block text-sm font-bold mb-2">{t('shareWithFriends')}</label>
                                    <div className="space-y-2 max-h-40 overflow-y-auto">
                                        {friends.map(friend => (
                                            <div 
                                                key={friend.id}
                                                onClick={() => toggleFriend(friend.id)}
                                                className={`flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-all ${
                                                    selectedFriends.includes(friend.id) 
                                                        ? 'bg-blue-500/30 border-2 border-blue-500' 
                                                        : 'bg-black/10 border-2 border-transparent hover:bg-black/20'
                                                }`}
                                            >
                                                <div className={`w-5 h-5 rounded border-2 flex items-center justify-center ${
                                                    selectedFriends.includes(friend.id)
                                                        ? 'bg-blue-500 border-blue-500'
                                                        : 'border-gray-400'
                                                }`}>
                                                    {selectedFriends.includes(friend.id) && (
                                                        <Check size={14} className="text-white"/>
                                                    )}
                                                </div>
                                                <div className="flex items-center gap-2 flex-1">
                                                    <div className="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white">
                                                        <User size={16}/>
                                                    </div>
                                                    <div className="flex flex-col">
                                                        <span className="font-bold text-sm">{friend.name || friend.shareCode}</span>
                                                        <span className="text-xs opacity-60 font-mono">{friend.shareCode}</span>
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    {selectedFriends.length > 0 && (
                                        <div className="text-xs opacity-60 mt-2">
                                            <Users className="inline mr-1" size={12}/>
                                            {selectedFriends.length} {selectedFriends.length === 1 ? t('friend') : t('friends')} {t('selected')}
                                        </div>
                                    )}
                                </div>
                            )}
                            
                            {friends && friends.length === 0 && (
                                <div className="text-xs opacity-60 p-3 rounded-lg bg-black/10">
                                    {t('noFriends')}
                                </div>
                            )}
                            
                            <button 
                                onClick={handleCreate}
                                className={`w-full py-3 rounded-lg font-bold ${themeClasses.button}`}
                            >
                                <FolderPlus className="inline mr-2" size={18}/>
                                {t('calendarCreateButton')}
                            </button>
                        </div>
                        
                        <div>
                            <h3 className="text-sm font-bold mb-3 opacity-70">{t('myCalendars')}</h3>
                            <div className="space-y-2">
                                {calendars.map(cal => (
                                    <div key={cal.id} className="flex items-center gap-3 p-3 rounded-lg bg-black/20">
                                        <div 
                                            className="w-4 h-4 rounded-full" 
                                            style={{ backgroundColor: cal.color }}
                                        />
                                        <div className="flex-1">
                                            <div className="font-bold">{cal.name}</div>
                                            {cal.description && <div className="text-xs opacity-60">{cal.description}</div>}
                                            {cal.members && cal.members.length > 1 && (
                                                <div className="text-xs opacity-60 mt-1">
                                                    <Users className="inline mr-1" size={10}/>
                                                    {cal.members.length} {cal.members.length === 1 ? t('member') : t('members')}
                                                </div>
                                            )}
                                        </div>
                                        <div className="text-xs opacity-60">
                                            {cal.ownerId === currentUserId ? t('calendarOwner') : (cal.roles && cal.roles[currentUserId] || t('calendarMember'))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const VisualSettingsModal = ({ show, onClose, theme, setTheme, currentFont, setCurrentFont, fontScale, setFontScale, settingsEditorLang, setSettingsEditorLang, showMigrationNotice, customTheme }) => {
            const [step, setStep] = useState(0);
            if (!show) return null;
            const previewThemeLabel = { light: t('light'), dark: t('dark'), vibrant: t('vibrant'), custom: t('custom') };
            const steps = [
                { key: 'theme', label: getSettingsText(settingsEditorLang, 'stepTheme') },
                { key: 'font', label: getSettingsText(settingsEditorLang, 'stepFont') },
                { key: 'language', label: getSettingsText(settingsEditorLang, 'stepLanguage') }
            ];

            const nextStep = () => setStep(prev => Math.min(prev + 1, steps.length - 1));
            const prevStep = () => setStep(prev => Math.max(prev - 1, 0));

            return (
                <div className="fixed inset-0 z-[80] flex items-end sm:items-center justify-center bg-black/70 backdrop-blur-sm p-4 text-white">
                    <div className="w-full max-w-3xl rounded-2xl p-6 bg-slate-900 border border-slate-700">
                        <div className="flex justify-between items-center mb-4">
                            <div>
                                <div className="text-sm uppercase tracking-wide text-slate-400">{getSettingsText(settingsEditorLang, 'guidedSetup')}</div>
                                <h2 className="text-lg font-bold">{getSettingsText(settingsEditorLang, 'visualEditor')}</h2>
                            </div>
                            <button onClick={onClose}><X /></button>
                        </div>

                        {showMigrationNotice && (
                            <div className="mb-4 text-xs text-amber-200 bg-amber-500/10 border border-amber-500/30 rounded-lg p-2">
                                {getSettingsText(settingsEditorLang, 'migrationNotice')}
                            </div>
                        )}

                        <div className="grid md:grid-cols-[1.1fr_0.9fr] gap-4">
                            <div className="space-y-4">
                                <div className="flex gap-2 text-xs font-bold uppercase">
                                    {steps.map((s, idx) => (
                                        <span key={s.key} className={`px-2 py-1 rounded ${idx === step ? 'bg-blue-600 text-white' : 'bg-slate-800 text-slate-400'}`}>
                                            {s.label}
                                        </span>
                                    ))}
                                </div>

                                {steps[step].key === 'theme' && (
                                    <div className="grid grid-cols-2 gap-3">
                                        {['light', 'dark', 'vibrant', 'custom'].map(opt => (
                                            <button
                                                key={opt}
                                                onClick={() => setTheme(opt)}
                                                className={`p-3 rounded-lg border font-bold ${theme === opt ? 'border-blue-500 bg-blue-500/10' : 'border-slate-700 text-slate-300'}`}
                                            >
                                                {previewThemeLabel[opt] || opt}
                                            </button>
                                        ))}
                                    </div>
                                )}

                                {steps[step].key === 'font' && (
                                    <div className="space-y-3">
                                        <label className="text-xs font-bold uppercase text-slate-400">{t('font')}</label>
                                        <select value={currentFont} onChange={(e) => setCurrentFont(e.target.value)} className="w-full p-3 rounded-lg bg-slate-800 border border-slate-700 text-white">
                                            {Object.keys(FONT_LABEL_KEYS).map(id => (
                                                <option key={id} value={id}>{t(FONT_LABEL_KEYS[id])}</option>
                                            ))}
                                        </select>
                                        <div>
                                            <label className="text-xs font-bold uppercase text-slate-400">{t('fontSize')}: {Math.round(fontScale * 100)}%</label>
                                            <input type="range" min="0.8" max="1.3" step="0.05" value={fontScale} onChange={(e) => setFontScale(parseFloat(e.target.value))} className="w-full accent-blue-500"/>
                                        </div>
                                    </div>
                                )}

                                {steps[step].key === 'language' && (
                                    <div className="space-y-3">
                                        <label className="text-xs font-bold uppercase text-slate-400">{getSettingsText(settingsEditorLang, 'languageLabel')}</label>
                                        <select value={settingsEditorLang} onChange={(e) => setSettingsEditorLang(e.target.value)} className="w-full p-3 rounded-lg bg-slate-800 border border-slate-700 text-white">
                                            {SETTINGS_LANG_OPTIONS.map(opt => (
                                                <option key={opt.id} value={opt.id}>{opt.label}</option>
                                            ))}
                                        </select>
                                        <div className="text-xs text-slate-400">{getSettingsText(settingsEditorLang, 'languageHint')}</div>
                                    </div>
                                )}
                            </div>

                            <div className="rounded-xl border border-slate-700 bg-slate-950 p-4">
                                <div className="text-xs uppercase text-slate-500 mb-2">{getSettingsText(settingsEditorLang, 'preview')}</div>
                                <div className={`rounded-xl p-4 ${theme === 'light' ? 'bg-slate-50 text-slate-900' : theme === 'dark' ? 'bg-black text-white' : theme === 'vibrant' ? 'bg-gradient-to-br from-pink-500 via-purple-500 to-orange-400 text-white' : theme === 'custom' ? 'text-white' : 'bg-slate-50 text-slate-900'} ${currentFont}`} style={{ fontSize: `${fontScale}em`, ...(theme === 'custom' ? { backgroundColor: customTheme.bg, color: customTheme.text } : {}) }}>
                                    <div className="text-sm font-bold mb-2">{t('calendar')}</div>
                                    <div className="text-xs opacity-70 mb-3">{getSettingsText(settingsEditorLang, 'guidedSetup')}</div>
                                    <button className="px-3 py-2 rounded-lg text-xs font-bold bg-blue-600 text-white">{getSettingsText(settingsEditorLang, 'apply')}</button>
                                </div>
                            </div>
                        </div>

                        <div className="mt-6 flex gap-2">
                            <button onClick={prevStep} disabled={step === 0} className="px-4 py-2 rounded-lg text-sm bg-slate-800 text-slate-200 disabled:opacity-40">
                                {getSettingsText(settingsEditorLang, 'back')}
                            </button>
                            <button onClick={nextStep} disabled={step === steps.length - 1} className="px-4 py-2 rounded-lg text-sm bg-blue-600 text-white disabled:opacity-40">
                                {getSettingsText(settingsEditorLang, 'next')}
                            </button>
                            <button onClick={onClose} className="ml-auto px-4 py-2 rounded-lg text-sm border border-slate-700 text-slate-300">
                                {getSettingsText(settingsEditorLang, 'cancel')}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const CustomThemeWizard = ({ show, onClose, customTheme, setCustomTheme }) => {
            const [step, setStep] = useState(0);
            if (!show) return null;
            const steps = [
                { key: 'bg', label: t('wizardBg') },
                { key: 'accent', label: t('wizardAccent') },
                { key: 'text', label: t('wizardText') }
            ];

            const handleColorChange = (key, value) => {
                setCustomTheme(prev => ({ ...prev, [key]: value }));
            };

            return (
                <div className="fixed inset-0 z-[85] flex items-end sm:items-center justify-center bg-black/70 backdrop-blur-sm p-4 text-white">
                    <div className="w-full max-w-md rounded-2xl p-6 bg-slate-900 border border-slate-700">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-bold">{t('customizeTheme')}</h2>
                            <button onClick={onClose}><X /></button>
                        </div>
                        <div className="space-y-4">
                            <div className="text-xs uppercase text-slate-400">{steps[step].label}</div>
                            <input
                                type="color"
                                value={customTheme[steps[step].key]}
                                onChange={(e) => handleColorChange(steps[step].key, e.target.value)}
                                className="w-full h-12 rounded-lg border border-slate-700 bg-black"
                            />
                            <div className="rounded-xl p-4 border border-slate-700" style={{ backgroundColor: customTheme.bg, color: customTheme.text }}>
                                <div className="text-xs opacity-70 mb-2">Vorschau</div>
                                <button className="px-3 py-1 rounded-lg text-xs font-bold" style={{ backgroundColor: customTheme.accent, color: customTheme.text }}>Akzent</button>
                            </div>
                        </div>
                        <div className="mt-4 flex gap-2">
                            <button onClick={() => setStep(Math.max(step - 1, 0))} disabled={step === 0} className="px-3 py-2 rounded-lg text-sm bg-slate-800 text-slate-200 disabled:opacity-40">{t('wizardBack')}</button>
                            <button onClick={() => setStep(Math.min(step + 1, steps.length - 1))} disabled={step === steps.length - 1} className="px-3 py-2 rounded-lg text-sm bg-blue-600 text-white disabled:opacity-40">{t('wizardNext')}</button>
                            <button onClick={onClose} className="ml-auto px-3 py-2 rounded-lg text-sm border border-slate-700">{t('wizardFinish')}</button>
                        </div>
                    </div>
                </div>
            );
        };
        
        const HEX_COLOR_PATTERN = /#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})/;
        const MIN_FONT_SCALE = 0.7;
        const MAX_FONT_SCALE = 1.5;

        const parseAiDesignPrompt = (prompt) => {
            const trimmed = (prompt || '').trim();
            if (!trimmed) return null;
            const result = {};
            const lower = trimmed.toLowerCase();
            const colorMatches = trimmed.match(new RegExp(HEX_COLOR_PATTERN.source, 'g')) || [];
            const parseNumber = (value) => {
                const match = value.match(/(\d+(?:[\.,]\d+)?)/);
                if (!match) return null;
                return parseFloat(match[1].replace(',', '.'));
            };

            const bgMatch = trimmed.match(new RegExp(`(?:bg|background|hintergrund|dunkel|schwarz)\\s*[:=]?\\s*(${HEX_COLOR_PATTERN.source})`, 'i'));
            if (bgMatch) result.bg = bgMatch[1];
            if (!result.bg && lower.includes('dunkel')) result.bg = '#0b0f19';
            if (!result.bg && lower.includes('hell')) result.bg = '#f8fafc';

            const accentMatch = trimmed.match(new RegExp(`(?:akzent|accent|prim√§r|primary)\\s*[:=]?\\s*(${HEX_COLOR_PATTERN.source})`, 'i'));
            if (accentMatch) result.accent = accentMatch[1];

            const textMatch = trimmed.match(new RegExp(`(?:text|schriftfarbe|textfarbe)\\s*[:=]?\\s*(${HEX_COLOR_PATTERN.source})`, 'i'));
            if (textMatch) result.text = textMatch[1];

            if (!result.bg && colorMatches[0]) result.bg = colorMatches[0];
            if (!result.accent && colorMatches[1]) result.accent = colorMatches[1];
            if (!result.text && colorMatches[2]) result.text = colorMatches[2];

            if (lower.includes('elegant')) result.font = 'font-playfair';
            else if (lower.includes('antik')) result.font = 'font-cinzel';
            else if (lower.includes('modern')) result.font = 'font-inter';
            else if (lower.includes('lesbar')) result.font = 'font-merriweather';
            else if (lower.includes('stark')) result.font = 'font-oswald';

            const fontMatch = trimmed.match(/(?:font|schrift)\s*[:=]?\s*(inter|cinzel|playfair|merriweather|oswald)/i);
            if (fontMatch) result.font = `font-${fontMatch[1].toLowerCase()}`;

            const sizeMatch = trimmed.match(/(?:gr√∂√üe|size|font size|schriftgr√∂√üe)\s*[:=]?\s*([\d.,]+)%?/i);
            if (sizeMatch) {
                const parsedSize = parseNumber(sizeMatch[1]);
                result.fontScale = parsedSize ? parsedSize / 100 : null;
            }

            if (lower.includes('klein')) result.fontScale = 0.9;
            if (lower.includes('gro√ü') || lower.includes('gross')) result.fontScale = 1.2;

            return result;
        };

        const applyAiDesign = ({ prompt, setTheme, setCustomTheme, setCurrentFont, setFontScale }) => {
            const parsed = parseAiDesignPrompt(prompt);
            if (!parsed) return false;
            setTheme('custom');
            setCustomTheme(prev => ({
                ...prev,
                ...(parsed.bg ? { bg: parsed.bg } : {}),
                ...(parsed.accent ? { accent: parsed.accent } : {}),
                ...(parsed.text ? { text: parsed.text } : {})
            }));
            if (parsed.font) setCurrentFont(parsed.font);
            if (parsed.fontScale) setFontScale(Math.min(MAX_FONT_SCALE, Math.max(MIN_FONT_SCALE, parsed.fontScale)));
            return true;
        };

        const CalendarSettingsModal = ({ show, onClose, calendar, makePublic, getPublicLink, getSubscriptionLink, updateCalendar, themeClasses, friends, shareCalendarWithUser, currentUserId }) => {
            const [showCopySuccess, setShowCopySuccess] = useState(false);
            const [showFriendSelector, setShowFriendSelector] = useState(false);
            const [selectedNewFriends, setSelectedNewFriends] = useState([]);
            
            if (!show || !calendar) return null;
            
            const copyToClipboard = (text) => {
                navigator.clipboard.writeText(text).then(() => {
                    setShowCopySuccess(true);
                    setTimeout(() => setShowCopySuccess(false), 2000);
                });
            };
            
            const publicLink = getPublicLink(calendar.id);
            const subscriptionLink = getSubscriptionLink(calendar.id);
            
            // Get friends who are not already members
            const availableFriends = (friends || []).filter(f => 
                !calendar.members || !calendar.members.includes(f.id)
            );
            
            // Get friends who are already members (excluding owner)
            const sharedWithFriends = (friends || []).filter(f => 
                calendar.members && calendar.members.includes(f.id)
            );
            
            const isOwner = calendar.ownerId === currentUserId;
            
            const handleShareWithFriends = async () => {
                if (selectedNewFriends.length === 0) return;
                
                for (const friendId of selectedNewFriends) {
                    await shareCalendarWithUser(calendar.id, friendId, 'viewer');
                }
                
                setSelectedNewFriends([]);
                setShowFriendSelector(false);
            };
            
            const toggleFriend = (friendId) => {
                setSelectedNewFriends(prev => 
                    prev.includes(friendId) 
                        ? prev.filter(id => id !== friendId)
                        : [...prev, friendId]
                );
            };
            
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70">
                    <div className={`w-full max-w-lg rounded-2xl p-6 max-h-[90vh] overflow-y-auto ${themeClasses.card}`}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold">{t('shareCalendar')}</h2>
                            <button onClick={onClose} className="p-2 rounded-lg hover:bg-white/5">
                                <X size={20}/>
                            </button>
                        </div>
                        
                        <div className="mb-4">
                            <div className="flex items-center gap-3 p-3 rounded-lg bg-black/20">
                                <div 
                                    className="w-4 h-4 rounded-full" 
                                    style={{ backgroundColor: calendar.color }}
                                />
                                <div>
                                    <div className="font-bold">{calendar.name}</div>
                                    {calendar.description && <div className="text-xs opacity-60">{calendar.description}</div>}
                                </div>
                            </div>
                        </div>
                        
                        <div className="space-y-4">
                            {/* Friend Sharing Section */}
                            {isOwner && friends && friends.length > 0 && (
                                <div>
                                    <div className="flex items-center justify-between mb-2">
                                        <label className="block text-sm font-bold">{t('shareWithFriends')}</label>
                                        {availableFriends.length > 0 && (
                                            <button
                                                onClick={() => setShowFriendSelector(!showFriendSelector)}
                                                className="text-xs px-2 py-1 rounded bg-blue-500/20 text-blue-400"
                                            >
                                                {showFriendSelector ? t('cancel') : t('add')}
                                            </button>
                                        )}
                                    </div>
                                    
                                    {/* Shared with friends list */}
                                    {sharedWithFriends.length > 0 && (
                                        <div className="space-y-1 mb-2">
                                            {sharedWithFriends.map(friend => (
                                                <div key={friend.id} className="flex items-center gap-2 p-2 rounded bg-black/10 text-sm">
                                                    <div className="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center text-white">
                                                        <User size={12}/>
                                                    </div>
                                                    <span className="flex-1">{friend.name || friend.shareCode}</span>
                                                    <span className="text-xs opacity-60">{t('calendarMember')}</span>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    
                                    {/* Friend selector */}
                                    {showFriendSelector && availableFriends.length > 0 && (
                                        <div className="space-y-2 p-3 rounded-lg bg-black/20 border border-blue-500/20">
                                            <div className="text-xs opacity-70 mb-2">{t('selectFriends')}</div>
                                            <div className="space-y-1 max-h-40 overflow-y-auto">
                                                {availableFriends.map(friend => (
                                                    <div 
                                                        key={friend.id}
                                                        onClick={() => toggleFriend(friend.id)}
                                                        className={`flex items-center gap-2 p-2 rounded cursor-pointer transition-all ${
                                                            selectedNewFriends.includes(friend.id) 
                                                                ? 'bg-blue-500/30 border border-blue-500' 
                                                                : 'bg-black/10 hover:bg-black/20'
                                                        }`}
                                                    >
                                                        <div className={`w-4 h-4 rounded border flex items-center justify-center ${
                                                            selectedNewFriends.includes(friend.id)
                                                                ? 'bg-blue-500 border-blue-500'
                                                                : 'border-gray-400'
                                                        }`}>
                                                            {selectedNewFriends.includes(friend.id) && (
                                                                <Check size={10} className="text-white"/>
                                                            )}
                                                        </div>
                                                        <div className="w-6 h-6 rounded-full bg-blue-500 flex items-center justify-center text-white">
                                                            <User size={12}/>
                                                        </div>
                                                        <span className="text-sm flex-1">{friend.name || friend.shareCode}</span>
                                                    </div>
                                                ))}
                                            </div>
                                            {selectedNewFriends.length > 0 && (
                                                <button
                                                    onClick={handleShareWithFriends}
                                                    className="w-full py-2 rounded bg-blue-600 text-white text-sm font-bold mt-2"
                                                >
                                                    {t('shareCalendar')} ({selectedNewFriends.length})
                                                </button>
                                            )}
                                        </div>
                                    )}
                                    
                                    {sharedWithFriends.length === 0 && !showFriendSelector && (
                                        <div className="text-xs opacity-60 p-2">
                                            {availableFriends.length > 0 ? t('selectFriends') : t('noFriends')}
                                        </div>
                                    )}
                                </div>
                            )}
                            
                            {/* Public Sharing Section */}
                            <div className="flex items-center justify-between p-3 rounded-lg bg-black/10">
                                <div>
                                    <div className="font-bold">{t('publicSharing')}</div>
                                    <div className="text-xs opacity-60">{t('publicSharingHint')}</div>
                                </div>
                                <button 
                                    onClick={() => makePublic(calendar.id, !calendar.isPublic)}
                                    className={`px-4 py-2 rounded-lg font-bold ${calendar.isPublic ? 'bg-green-600' : 'bg-gray-600'}`}
                                >
                                    {calendar.isPublic ? t('toggleOn') : t('toggleOff')}
                                </button>
                            </div>
                            
                            {calendar.isPublic && (
                                <>
                                    <div>
                                        <label className="block text-sm font-bold mb-2">{t('publicLinkLabel')}</label>
                                        <div className="flex gap-2">
                                            <input 
                                                type="text" 
                                                value={publicLink || ''}
                                                readOnly
                                                className={`flex-1 p-3 rounded-lg ${themeClasses.input}`}
                                            />
                                            <button 
                                                onClick={() => copyToClipboard(publicLink)}
                                                className={`px-4 py-3 rounded-lg ${themeClasses.button}`}
                                                title={t('copyLinkTitle')}
                                            >
                                                {showCopySuccess ? <Check size={18}/> : <Copy size={18}/>}
                                            </button>
                                        </div>
                                        <div className="text-xs opacity-60 mt-1">
                                            <Globe className="inline mr-1" size={12}/>
                                            {t('readOnlyAccess')}
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-bold mb-2">{t('subscriptionLinkLabel')}</label>
                                        <div className="flex gap-2">
                                            <input 
                                                type="text" 
                                                value={subscriptionLink || ''}
                                                readOnly
                                                className={`flex-1 p-3 rounded-lg ${themeClasses.input}`}
                                            />
                                            <button 
                                                onClick={() => copyToClipboard(subscriptionLink)}
                                                className={`px-4 py-3 rounded-lg ${themeClasses.button}`}
                                                title={t('copyLinkTitle')}
                                            >
                                                {showCopySuccess ? <Check size={18}/> : <Copy size={18}/>}
                                            </button>
                                        </div>
                                        <div className="text-xs opacity-60 mt-1">
                                            <Link2 className="inline mr-1" size={12}/>
                                            {t('subscriptionLinkHint')}
                                        </div>
                                    </div>
                                </>
                            )}
                            
                            <div className="text-xs opacity-60 p-3 rounded-lg bg-blue-500/10 border border-blue-500/20">
                                <AlertCircle className="inline mr-1" size={14}/>
                                {t('subscriptionLinkInfo')}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Statistics Modal Component
        const StatisticsModal = ({ show, onClose, events, tasks, taskTimeEntries, themeClasses, isComic }) => {
            if (!show) return null;
            
            const [viewMode, setViewMode] = useState('overview'); // overview, daily, weekly, monthly
            
            // Calculate statistics
            const stats = useMemo(() => {
                const completedTasks = tasks.filter(t => t.completed).length;
                const totalTasks = tasks.length;
                
                // Calculate total tracked time
                let totalTrackedSeconds = 0;
                Object.values(taskTimeEntries).forEach(entries => {
                    entries.forEach(entry => {
                        totalTrackedSeconds += entry.duration || 0;
                    });
                });
                const totalTrackedHours = (totalTrackedSeconds / 3600).toFixed(1);
                
                // Category breakdown
                const categoryStats = {};
                events.forEach(event => {
                    const cat = event.category || 'personal';
                    if (!categoryStats[cat]) {
                        categoryStats[cat] = { count: 0, totalMinutes: 0 };
                    }
                    categoryStats[cat].count++;
                    categoryStats[cat].totalMinutes += event.duration || 60;
                });
                
                // Calculate daily totals for last 7 days
                const dailyStats = [];
                for (let i = 6; i >= 0; i--) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    const dateStr = formatDate(date);
                    const dayEvents = events.filter(e => e.date === dateStr || e._occDate === dateStr);
                    const dayTimeEntries = Object.values(taskTimeEntries).flat().filter(entry => {
                        if (!entry.startTime) return false;
                        const entryDate = formatDate(new Date(entry.startTime));
                        return entryDate === dateStr;
                    });
                    const dayTrackedMinutes = dayTimeEntries.reduce((sum, e) => sum + (e.duration || 0) / 60, 0);
                    
                    dailyStats.push({
                        date: dateStr,
                        label: date.toLocaleDateString('de-DE', { weekday: 'short', day: 'numeric', month: 'numeric' }),
                        events: dayEvents.length,
                        trackedMinutes: Math.round(dayTrackedMinutes)
                    });
                }
                
                return {
                    completedTasks,
                    totalTasks,
                    totalTrackedHours,
                    totalEvents: events.length,
                    categoryStats,
                    dailyStats
                };
            }, [events, tasks, taskTimeEntries]);
            
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className={`w-full max-w-2xl rounded-2xl p-6 max-h-[90vh] overflow-y-auto ${isComic?'bg-[#f4e4bc] border-4 border-[#8b5a2b] text-[#4a3b2a]':'bg-slate-900 border border-slate-700 text-white'}`}>
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-2xl font-bold flex items-center gap-2">
                                <PieChart size={24}/> {t('statistics')}
                            </h2>
                            <button onClick={onClose} className="p-2 opacity-70 hover:opacity-100">
                                <X size={24}/>
                            </button>
                        </div>
                        
                        {/* Overview Cards */}
                        <div className="grid grid-cols-2 gap-4 mb-6">
                            <div className={`p-4 rounded-xl ${isComic ? 'bg-[#fdf6e3]' : 'bg-blue-500/10'}`}>
                                <div className="text-3xl font-bold text-blue-400">{stats.totalEvents}</div>
                                <div className="text-sm opacity-70 mt-1">{t('totalEvents')}</div>
                            </div>
                            <div className={`p-4 rounded-xl ${isComic ? 'bg-[#fdf6e3]' : 'bg-green-500/10'}`}>
                                <div className="text-3xl font-bold text-green-400">{stats.totalTrackedHours}h</div>
                                <div className="text-sm opacity-70 mt-1">{t('hoursTracked')}</div>
                            </div>
                            <div className={`p-4 rounded-xl ${isComic ? 'bg-[#fdf6e3]' : 'bg-purple-500/10'}`}>
                                <div className="text-3xl font-bold text-purple-400">{stats.completedTasks}</div>
                                <div className="text-sm opacity-70 mt-1">{t('tasksCompleted')}</div>
                            </div>
                            <div className={`p-4 rounded-xl ${isComic ? 'bg-[#fdf6e3]' : 'bg-orange-500/10'}`}>
                                <div className="text-3xl font-bold text-orange-400">{stats.totalTasks}</div>
                                <div className="text-sm opacity-70 mt-1">{t('allTasks')}</div>
                            </div>
                        </div>
                        
                        {/* Category Breakdown */}
                        <div className="mb-6">
                            <h3 className="text-lg font-bold mb-3 flex items-center gap-2">
                                <TrendingUp size={18}/> {t('categoryStats')}
                            </h3>
                            <div className="space-y-2">
                                {Object.entries(stats.categoryStats).map(([catId, data]) => {
                                    const category = CATEGORIES.find(c => c.id === catId);
                                    const totalMinutes = Object.values(stats.categoryStats).reduce((sum, c) => sum + c.totalMinutes, 0);
                                    const percentage = totalMinutes > 0 ? Math.round((data.totalMinutes / totalMinutes) * 100) : 0;
                                    
                                    return (
                                        <div key={catId} className={`p-3 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                            <div className="flex items-center justify-between mb-2">
                                                <div className="flex items-center gap-2">
                                                    <span className="text-xl">{category?.icon}</span>
                                                    <span className="font-semibold">{t(catId)}</span>
                                                </div>
                                                <div className="text-sm opacity-70">
                                                    {data.count} {t('eventsLabel')} ¬∑ {Math.round(data.totalMinutes / 60)}h
                                                </div>
                                            </div>
                                            <div className="h-2 bg-black/10 rounded-full overflow-hidden">
                                                <div 
                                                    className="h-full bg-blue-500"
                                                    style={{ width: `${percentage}%` }}
                                                />
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                        
                        {/* Daily Activity Chart */}
                        <div className="mb-6">
                            <h3 className="text-lg font-bold mb-3 flex items-center gap-2">
                                <Activity size={18}/> {t('dailyStats')} (7 {t('rangeWeek')})
                            </h3>
                            <div className="space-y-2">
                                {stats.dailyStats.map(day => {
                                    const maxTracked = Math.max(...stats.dailyStats.map(d => d.trackedMinutes), 1);
                                    const heightPercent = (day.trackedMinutes / maxTracked) * 100;
                                    
                                    return (
                                        <div key={day.date} className="flex items-center gap-3">
                                            <div className="text-xs opacity-70 w-20">{day.label}</div>
                                            <div className="flex-1 flex items-center gap-2">
                                                <div className="flex-1 h-8 bg-black/10 rounded-lg overflow-hidden relative">
                                                    <div 
                                                        className="h-full bg-gradient-to-r from-blue-500 to-purple-500 rounded-lg"
                                                        style={{ width: `${heightPercent}%` }}
                                                    />
                                                </div>
                                                <div className="text-sm font-semibold w-16 text-right">
                                                    {day.trackedMinutes > 0 ? `${Math.round(day.trackedMinutes)}m` : '-'}
                                                </div>
                                            </div>
                                            <div className="text-xs opacity-60 w-16 text-right">
                                                {day.events} {t('eventsLabel')}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                        
                        {stats.totalEvents === 0 && stats.totalTasks === 0 && (
                            <div className="text-center py-12 opacity-60">
                                <PieChart size={48} className="mx-auto mb-3 opacity-40"/>
                                <div>{t('noStatsData')}</div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        
        // --- Messages View (Calendar-linked contact list) ---
        const MessagesView = ({ user, themeClasses, calendars, activeCalendarId, friends, onOpenChat }) => {
            const acceptedFriends = useMemo(() => (friends || []).filter(f => f.status === 'accepted'), [friends]);
            const acceptedMap = useMemo(() => {
                const m = new Map();
                acceptedFriends.forEach(f => m.set(f.id, f));
                return m;
            }, [acceptedFriends]);

            const activeCalendar = useMemo(() => {
                if (!calendars || calendars.length === 0) return null;
                if (!activeCalendarId || activeCalendarId === 'all') return calendars[0] || null;
                return calendars.find(c => c.id === activeCalendarId) || calendars[0] || null;
            }, [calendars, activeCalendarId]);

            const memberIds = useMemo(() => {
                const ids = (activeCalendar?.members || []).filter(Boolean);
                // Unique
                return Array.from(new Set(ids));
            }, [activeCalendar]);

            const memberItems = useMemo(() => {
                if (!user) return [];
                return memberIds
                    .filter(uid => uid && uid !== user.uid)
                    .map(uid => {
                        const fr = acceptedMap.get(uid);
                        const role = (activeCalendar?.roles && activeCalendar.roles[uid]) ? activeCalendar.roles[uid] : 'member';
                        return {
                            uid,
                            name: fr?.name || (uid.slice(0, 6) + '‚Ä¶'),
                            role,
                            isFriend: !!fr
                        };
                    })
                    .sort((a, b) => (a.isFriend === b.isFriend ? a.name.localeCompare(b.name) : (a.isFriend ? -1 : 1)));
            }, [memberIds, acceptedMap, user, activeCalendar]);

            const friendItems = useMemo(() => {
                if (!user) return [];
                return acceptedFriends
                    .filter(f => f.id && f.id !== user.uid)
                    .map(f => ({ uid: f.id, name: f.name || (f.id.slice(0,6)+'‚Ä¶') }))
                    .sort((a,b) => a.name.localeCompare(b.name));
            }, [acceptedFriends, user]);

            if (!user) return null;

            return (
                <div className="h-full overflow-y-auto px-4 py-6 space-y-6">
                    <div className={`p-5 rounded-2xl ${themeClasses.card}`}>
                        <div className="flex items-center justify-between gap-3">
                            <div className="min-w-0">
                                <div className="text-sm font-bold">Message</div>
                                <div className="text-xs opacity-70">
                                    {activeCalendar ? `Kalender: ${activeCalendar.name || activeCalendar.id}` : 'Kein Kalender'}
                                </div>
                            </div>
                            <div className="flex items-center gap-2 opacity-80">
                                <Users size={16}/>
                                <span className="text-xs">{memberItems.length}</span>
                            </div>
                        </div>
                        <div className="mt-4 text-xs opacity-70">
                            √ñffne direkt den Secret-Chat mit einem Kalender-Mitglied.
                        </div>
                    </div>

                    <div className={`p-4 rounded-2xl ${themeClasses.card}`}>
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <Users size={16}/>
                                <span className="font-bold text-sm">Kalender-Mitglieder</span>
                            </div>
                            <span className="text-xs opacity-70">{memberItems.length}</span>
                        </div>

                        {memberItems.length === 0 ? (
                            <div className="mt-3 text-xs opacity-70">Keine weiteren Mitglieder gefunden.</div>
                        ) : (
                            <div className="mt-3 space-y-2">
                                {memberItems.map(m => (
                                    <div key={m.uid} className={`flex items-center justify-between p-3 rounded-xl ${themeClasses.listItem}`}>
                                        <div className="min-w-0">
                                            <div className="text-sm font-semibold truncate flex items-center gap-2">
                                                <span className="truncate">{m.name}</span>
                                                {m.isFriend && <span className="text-[10px] px-2 py-0.5 rounded-full bg-emerald-500/20 text-emerald-300">Friend</span>}
                                            </div>
                                            <div className="text-[11px] opacity-60 truncate">{m.role}</div>
                                        </div>
                                        <button
                                            onClick={() => onOpenChat(m.uid, m.name)}
                                            className="px-3 py-2 rounded-xl bg-blue-600 text-white text-xs font-bold active:scale-95"
                                            title="Chat √∂ffnen"
                                        >
                                            <MessageCircle size={14} className="inline mr-1"/> Chat
                                        </button>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    <div className={`p-4 rounded-2xl ${themeClasses.card}`}>
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <UserCheck size={16}/>
                                <span className="font-bold text-sm">Freunde (akzeptiert)</span>
                            </div>
                            <span className="text-xs opacity-70">{friendItems.length}</span>
                        </div>

                        {friendItems.length === 0 ? (
                            <div className="mt-3 text-xs opacity-70">Noch keine Freunde akzeptiert.</div>
                        ) : (
                            <div className="mt-3 space-y-2">
                                {friendItems.map(f => (
                                    <div key={f.uid} className={`flex items-center justify-between p-3 rounded-xl ${themeClasses.listItem}`}>
                                        <div className="min-w-0">
                                            <div className="text-sm font-semibold truncate">{f.name}</div>
                                            <div className="text-[11px] opacity-60 truncate">Friend</div>
                                        </div>
                                        <button
                                            onClick={() => onOpenChat(f.uid, f.name)}
                                            className="px-3 py-2 rounded-xl bg-blue-600 text-white text-xs font-bold active:scale-95"
                                            title="Chat √∂ffnen"
                                        >
                                            <MessageCircle size={14} className="inline mr-1"/> Chat
                                        </button>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

function TimeRosterApp() {
            const [user, setUser] = useState(null);
            const [authChecked, setAuthChecked] = useState(false);
            const [view, setView] = useState('auth');
            const viewHistoryRef = useRef(['auth']);
            const viewRef = useRef(view);
            const userRef = useRef(user);
            const isHandlingBackRef = useRef(false);
            const [events, setEvents] = useState([]);
            const [friends, setFriends] = useState([]);
            const [shifts, setShifts] = useState(DEFAULT_SHIFTS);
            const [schedule, setSchedule] = useState({});
            const [calendarEvents, setCalendarEvents] = useState({});
            const [calendarShifts, setCalendarShifts] = useState({});
            const [calendarSchedule, setCalendarSchedule] = useState({});
            const [shareCode, setShareCode] = useState('');
            const [displayName, setDisplayName] = useState('');
            const [uiError, setUiError] = useState('');
            const [calendarEventListRange, setCalendarEventListRange] = useState('week');
            const unreadTotalsRef = useRef({});
            
            // Weather (dashboard)
            const [weather, setWeather] = useState(null); // { temperature, wind, code, time, lat, lon }
            const [weatherLocation, setWeatherLocation] = useState('');
            const [weatherLoading, setWeatherLoading] = useState(false);
            const [weatherError, setWeatherError] = useState('');
            
            // Holidays
            const [holidayCountries, setHolidayCountries] = useState([]);
            const [holidayCountriesLoading, setHolidayCountriesLoading] = useState(false);
            const [holidayCountriesError, setHolidayCountriesError] = useState('');
            const [holidayPref, setHolidayPref] = useState(DEFAULT_HOLIDAY_PREF);
            const [holidaySyncing, setHolidaySyncing] = useState(false);
            const [holidayLastSync, setHolidayLastSync] = useState(null);
            const [holidayFilter, setHolidayFilter] = useState('');

            const [weatherPref, setWeatherPref] = useState({ mode: "geo", manual: null });
            const [showWeatherSettings, setShowWeatherSettings] = useState(false);
            const [showWeatherForecast, setShowWeatherForecast] = useState(false);
            const [forecastData, setForecastData] = useState(null);
            const [forecastLoading, setForecastLoading] = useState(false);
            const [showVisualSettingsEditor, setShowVisualSettingsEditor] = useState(false);
            const [settingsEditorLang, setSettingsEditorLang] = useState('de');
            const [customTheme, setCustomTheme] = useState({ bg: '#0f172a', accent: '#2563eb', text: '#f8fafc' });
            const [showCustomThemeWizard, setShowCustomThemeWizard] = useState(false);
            const [purgedTimezoneData, setPurgedTimezoneData] = useState(false);
            const [showSettingsMigrationNotice, setShowSettingsMigrationNotice] = useState(false);

            const todayStr = formatDate(new Date());
            const dailyQuote = useMemo(() => getLocalizedQuote(todayStr, user?.uid || "anon"), [todayStr, user?.uid, lang]);

            // Upcoming events filter (Dashboard)
            const [upcomingRange, setUpcomingRange] = useState('week'); // week | month | year

            const upcomingWindowEnd = useMemo(() => {
                const base = new Date();
                base.setHours(0,0,0,0);
                const end = new Date(base);
                if (upcomingRange === 'month') end.setMonth(end.getMonth() + 1);
                else if (upcomingRange === 'year') end.setFullYear(end.getFullYear() + 1);
                else end.setDate(end.getDate() + 7);
                return end;
            }, [upcomingRange]);

            const upcomingItems = useMemo(() => {
                const start = new Date();
                start.setHours(0,0,0,0);
                const end = new Date(upcomingWindowEnd);
                const items = [];
                for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                    const dateStr = formatDate(d);
                    const dayList = getEventsForDate(dateStr, events);
                    for (const ev of dayList) {
                        items.push({
                            ...ev,
                            _occDate: dateStr,
                            _key: `${ev.id || 'ev'}_${dateStr}`
                        });
                    }
                }
                // Sort by occurrence date + time
                items.sort((a,b) => (a._occDate + ' ' + (a.time||'')).localeCompare(b._occDate + ' ' + (b.time||'')));
                // Keep it pragmatic: show max 50
                return items.slice(0, 50);
            }, [events, upcomingWindowEnd]);




            const [theme, setTheme] = useState('light');
            const [currentFont, setCurrentFont] = useState('font-inter');
            const [fontScale, setFontScale] = useState(1);
            const [lang, setLang] = useState('de');
            
            // New productivity features state
            const [tasks, setTasks] = useState([]);
            const [taskTimeEntries, setTaskTimeEntries] = useState({});
            const [activeTaskTimers, setActiveTaskTimers] = useState({});
            const [showTaskManager, setShowTaskManager] = useState(false);
            const [showStatistics, setShowStatistics] = useState(false);
            const [selectedTask, setSelectedTask] = useState(null);
            
            // UI preferences persistence (per user)
            useEffect(() => {
                if (!user) return;
                try {
                    const raw = safeStorageGet(getUiPrefKey(user.uid));
                    if (!raw) return;
                    const pref = JSON.parse(raw);
                    if (pref?.theme) setTheme(pref.theme);
                    if (pref?.currentFont) setCurrentFont(pref.currentFont);
                    if (typeof pref?.fontScale === "number") setFontScale(pref.fontScale);
                    if (pref?.lang) {
                        setLang(pref.lang);
                        setCurrentLang(pref.lang);
                    }
                    if (pref?.calendarViewMode) setCalendarViewMode(pref.calendarViewMode);
                    if (pref?.settingsEditorLang) setSettingsEditorLang(pref.settingsEditorLang);
                    if (pref?.customTheme) setCustomTheme(pref.customTheme);
                    if (pref?.uiPrefsVersion !== CURRENT_UI_PREFS_VERSION) {
                        setShowSettingsMigrationNotice(true);
                    }
                    if (pref?.timezonePurged) {
                        setPurgedTimezoneData(true);
                    }
                } catch (e) { /* ignore */ }
            }, [user?.uid]);

            useEffect(() => {
                if (!user) return;
                try {
                    const raw = safeStorageGet(getHolidayPrefKey(user.uid));
                    if (raw) {
                        const pref = JSON.parse(raw);
                        if (pref?.countryCode) setHolidayPref(prev => ({ ...prev, ...pref }));
                    }
                } catch (e) { /* ignore */ }
                try {
                    const rawSync = safeStorageGet(getHolidaySyncKey(user.uid));
                    if (rawSync) {
                        const parsed = JSON.parse(rawSync);
                        if (parsed?.ts) setHolidayLastSync(parsed.ts);
                    }
                } catch (e) { /* ignore */ }
            }, [user?.uid]);

            useEffect(() => {
                if (!user) return;
                try {
                    safeStorageSet(getHolidayPrefKey(user.uid), JSON.stringify(holidayPref));
                } catch (e) { /* ignore */ }
            }, [user?.uid, holidayPref]);

            useEffect(() => {
                if (!user) return;
                try {
                    setCurrentLang(lang);
                    if (!safeStorageSet(getUiPrefKey(user.uid), JSON.stringify({ theme, currentFont, fontScale, lang, calendarViewMode, settingsEditorLang, uiPrefsVersion: CURRENT_UI_PREFS_VERSION, customTheme, timezonePurged: purgedTimezoneData }))) {
                        console.warn('Storage blocked: cannot save UI preferences.');
                    }
                } catch (e) { /* ignore */ }
            }, [user?.uid, theme, currentFont, fontScale, lang, calendarViewMode, settingsEditorLang, customTheme, purgedTimezoneData]);

            useEffect(() => {
                if (!uiError) return;
                const timer = setTimeout(() => setUiError(''), 4500);
                return () => clearTimeout(timer);
            }, [uiError]);

            useEffect(() => {
                if (!user) return;
                if (!activeCalendarId || activeCalendarId === 'all') return;
                if (activeCalendarId === safeStorageGet('timeroster_last_calendar')) return;
                safeStorageSet('timeroster_last_calendar', activeCalendarId);
            }, [user, activeCalendarId]);

            useEffect(() => {
                if (!user) return;
                const loadCountries = async () => {
                    setHolidayCountriesLoading(true);
                    setHolidayCountriesError('');
                    const countries = await fetchHolidayCountries();
                    if (!countries.length) {
                        setHolidayCountriesError(t('holidayCountriesError'));
                        setHolidayCountries(sortHolidayCountries(getHolidayFallbackCountries()));
                    } else {
                        setHolidayCountries(countries);
                    }
                    setHolidayCountriesLoading(false);
                };
                loadCountries();
            }, [user, lang]);

            useEffect(() => {
                if (!activeCalendarId || activeCalendarId === 'all') return;
                setHolidayPref(prev => ({ ...prev, calendarId: prev.calendarId || activeCalendarId }));
            }, [activeCalendarId]);


            const [showSecret, setShowSecret] = useState(false);
            const [secretInitialOpen, setSecretInitialOpen] = useState(null);

            const [secretPremiumUnlocked, setSecretPremiumUnlocked] = useState(() => safeStorageGet('timeroster_secret_premium_unlocked') === 'true');
            const [showPremiumGate, setShowPremiumGate] = useState(false);
            const [selectedDate, setSelectedDate] = useState(new Date());
            const [showEventModal, setShowEventModal] = useState(false);
            const [showDayOptions, setShowDayOptions] = useState(false);
            const [selectedEvent, setSelectedEvent] = useState(null);
            const [viewingUserId, setViewingUserId] = useState(null); 
            const [viewingFriendName, setViewingFriendName] = useState(null);
            const [pendingEventRequests, setPendingEventRequests] = useState([]);
            const [showAvailabilityOverview, setShowAvailabilityOverview] = useState(false);
            
            // Benachrichtigungen
            const [unreadMessageCount, setUnreadMessageCount] = useState(0);
            const [lastUnreadUpdate, setLastUnreadUpdate] = useState(null);
            const [fcmToken, setFcmToken] = useState(null);
            const [notificationsSupported, setNotificationsSupported] = useState(false);
            
            // PWA Install Prompt
            const [pwaInstallPrompt, setPwaInstallPrompt] = useState(null);
            const [isPwaInstalled, setIsPwaInstalled] = useState(false);
            
            // Multi-calendar support
            const [calendars, setCalendars] = useState([]); // List of calendars user has access to
            const [activeCalendarId, setActiveCalendarId] = useState(null); // Currently selected calendar
            const [showCalendarManager, setShowCalendarManager] = useState(false);
            const [showCalendarSettings, setShowCalendarSettings] = useState(false);
            const [selectedCalendarForSettings, setSelectedCalendarForSettings] = useState(null);
            
            // Calendar view mode: month | week | day
            const [calendarViewMode, setCalendarViewMode] = useState('month');
            
            // Search state
            const [searchQuery, setSearchQuery] = useState('');
            const [showSearch, setShowSearch] = useState(false);

            // Search results - optimized for performance
            const searchResults = useMemo(() => {
                if (!searchQuery.trim()) return [];
                const query = searchQuery.toLowerCase();
                const results = [];
                const seenKeys = new Set();
                
                // First pass: Search non-recurring events directly
                for (const ev of events) {
                    const titleMatch = ev.title.toLowerCase().includes(query);
                    const dateMatch = ev.date?.includes(query);
                    const categoryMatch = t(ev.category).toLowerCase().includes(query);
                    
                    if (titleMatch || categoryMatch) {
                        // For non-recurring or title/category matches, add all occurrences in range
                        const startDate = new Date();
                        startDate.setFullYear(startDate.getFullYear() - 1);
                        const endDate = new Date();
                        endDate.setFullYear(endDate.getFullYear() + 1); // Reduced to 2 years total
                        
                        for (let d = new Date(startDate); d <= endDate && results.length < 50; d.setDate(d.getDate() + 1)) {
                            const dateStr = formatDate(d);
                            if (matchesRecurrence(ev, dateStr)) {
                                const key = `${ev.id || 'ev'}_${dateStr}`;
                                if (!seenKeys.has(key)) {
                                    seenKeys.add(key);
                                    results.push({
                                        ...ev,
                                        _occDate: dateStr,
                                        _key: key
                                    });
                                }
                            }
                        }
                    } else if (dateMatch && ev.date === query) {
                        // Direct date match
                        const key = `${ev.id || 'ev'}_${ev.date}`;
                        if (!seenKeys.has(key)) {
                            seenKeys.add(key);
                            results.push({
                                ...ev,
                                _occDate: ev.date,
                                _key: key
                            });
                        }
                    }
                    
                    if (results.length >= 50) break;
                }
                
                return results.slice(0, 50);
            }, [searchQuery, events]); 

            useEffect(() => {
                const unsubscribe = onAuthStateChanged(auth, (u) => {
                    setUser(u); setAuthChecked(true); 
                    if(u) {
                        viewHistoryRef.current = ['dashboard'];
                        setView('dashboard');
                        // Profile Init
                        const profileRef = doc(db, 'artifacts', appId, 'users', u.uid, 'profile', 'main');
                        getDoc(profileRef).then(async (snap) => {
                            if (snap.exists()) {
                                const data = snap.data() || {};
                                const sc = data.shareCode || generateCode();
                                const nm = (data.name || '').trim() || getUserName(u);
                                setShareCode(sc);
                                setDisplayName(nm);
                                // Ensure public profile exists / stays in sync
                                await setDoc(doc(db, 'artifacts', appId, 'public_profiles', sc), { userId: u.uid, name: nm }, { merge: true });
                                if (!data.shareCode || !data.name) {
                                    await setDoc(profileRef, { shareCode: sc, name: nm }, { merge: true });
                                }
                            } else {
                                const newCode = generateCode();
                                const userName = getUserName(u);
                                setShareCode(newCode);
                                setDisplayName(userName);
                                await setDoc(profileRef, { shareCode: newCode, name: userName });
                                await setDoc(doc(db, 'artifacts', appId, 'public_profiles', newCode), { userId: u.uid, name: userName });
                            }
                        }).catch(e => console.log("Profile init error (silent)", e));
                    } else {
                        viewHistoryRef.current = ['auth'];
                        setView('auth');
                    }
                });
                return () => unsubscribe();
            }, []);

            // PWA Install Prompt Handler
            useEffect(() => {
                // Check if already installed as PWA
                if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
                    setIsPwaInstalled(true);
                }
                
                const handleBeforeInstall = (e) => {
                    e.preventDefault();
                    setPwaInstallPrompt(e);
                    console.log('PWA install prompt captured');
                };
                
                window.addEventListener('beforeinstallprompt', handleBeforeInstall);
                
                window.addEventListener('appinstalled', () => {
                    setIsPwaInstalled(true);
                    setPwaInstallPrompt(null);
                    console.log('PWA installed');
                });
                
                return () => window.removeEventListener('beforeinstallprompt', handleBeforeInstall);
            }, []);
            
            const installPwa = async () => {
                if (!pwaInstallPrompt) return;
                pwaInstallPrompt.prompt();
                const result = await pwaInstallPrompt.userChoice;
                if (result.outcome === 'accepted') {
                    setIsPwaInstalled(true);
                }
                setPwaInstallPrompt(null);
            };

            useEffect(() => {
                viewRef.current = view;
            }, [view]);

            useEffect(() => {
                userRef.current = user;
            }, [user]);

            useEffect(() => {
                if (!view) return;
                const history = viewHistoryRef.current;
                if (history[history.length - 1] !== view) {
                    history.push(view);
                    if (!isHandlingBackRef.current) {
                        window.history.pushState(null, '', window.location.href);
                    }
                }
                isHandlingBackRef.current = false;
            }, [view]);

            useEffect(() => {
                const handleBack = () => {
                    const history = viewHistoryRef.current;
                    if (history.length > 1) {
                        history.pop();
                        isHandlingBackRef.current = true;
                        setView(history[history.length - 1]);
                        return;
                    }
                    if (userRef.current && viewRef.current !== 'dashboard') {
                        viewHistoryRef.current = ['dashboard'];
                        isHandlingBackRef.current = true;
                        setView('dashboard');
                        return;
                    }
                    window.history.pushState(null, '', window.location.href);
                };
                window.history.pushState(null, '', window.location.href);
                window.addEventListener('popstate', handleBack);
                return () => window.removeEventListener('popstate', handleBack);
            }, []);

            useEffect(() => {
                if(!user) return;
                // Load pending event requests for this user
                const q = query(collection(db, 'artifacts', appId, 'users', user.uid, 'pending_events'), where('status', '==', 'pending'));
                const unsub = onSnapshot(q, (snap) => {
                    setPendingEventRequests(snap.docs.map(d => ({ id: d.id, ...d.data() })));
                }, err => console.error("Pending events error", err));
                return () => unsub();
            }, [user]);

            useEffect(() => {
                if (!user || purgedTimezoneData) return;
                const purgeTimezone = async () => {
                    const source = activeCalendarId
                        ? collection(db, 'artifacts', appId, 'calendars', activeCalendarId, 'events')
                        : collection(db, 'artifacts', appId, 'users', user.uid, 'events');
                    const snap = await getDocs(source);
                    const batch = writeBatch(db);
                    let updated = false;
                    snap.forEach(docSnap => {
                        const data = docSnap.data();
                        if (data?.timezone) {
                            batch.update(docSnap.ref, { timezone: deleteField() });
                            updated = true;
                        }
                    });
                    if (updated) {
                        batch.commit();
                    }
                    setPurgedTimezoneData(true);
                };
                purgeTimezone().catch((e) => console.error("Timezone purge error", e));
            }, [user, activeCalendarId, purgedTimezoneData]);
            
            // Initialize Firebase Cloud Messaging for push notifications
            // --- NOTIFICATION SYSTEM (works as single HTML file) ---
            const notificationPrefsKey = 'timeroster_notification_prefs';
            const getNotificationPrefs = () => {
                try {
                    const raw = localStorage.getItem(notificationPrefsKey);
                    if (raw) return JSON.parse(raw);
                } catch {}
                return { chatMessages: true, calendarEvents: true, friendRequests: true };
            };
            const [notificationPrefs, setNotificationPrefs] = useState(getNotificationPrefs);
            const saveNotificationPrefs = (prefs) => {
                setNotificationPrefs(prefs);
                try { localStorage.setItem(notificationPrefsKey, JSON.stringify(prefs)); } catch {}
            };

            // Store which notifications we've already shown (to avoid duplicates)
            const shownNotificationsRef = useRef(new Set());
            
            // In-app toast notifications state
            const [toastQueue, setToastQueue] = useState([]);
            const addToast = (title, body) => {
                const id = Date.now() + Math.random();
                setToastQueue(prev => [...prev.slice(-4), { id, title, body }]);
                setTimeout(() => setToastQueue(prev => prev.filter(t => t.id !== id)), 5000);
            };

            const showLocalNotification = (title, body, tag = '') => {
                // Always show in-app toast
                addToast(title, body);
                
                // Also try Browser Notification API (works without service worker)
                try {
                    if ('Notification' in window && Notification.permission === 'granted') {
                        const n = new Notification(title, {
                            body,
                            icon: 'https://cdn-icons-png.flaticon.com/128/2693/2693507.png',
                            tag: tag || `tr-${Date.now()}`,
                            badge: 'https://cdn-icons-png.flaticon.com/128/2693/2693507.png',
                            vibrate: [200, 100, 200],
                            requireInteraction: false,
                            silent: false
                        });
                        setTimeout(() => n.close(), 5000);
                    }
                } catch (err) {
                    console.warn('Browser Notification error (non-critical):', err);
                }
            };

            // Request notification permission (called from button or auto)
            const requestNotificationPermission = async () => {
                try {
                    if (!('Notification' in window)) {
                        console.log('Notification API not available');
                        setNotificationsSupported(false);
                        return false;
                    }
                    
                    const permission = await Notification.requestPermission();
                    if (permission === 'granted') {
                        setNotificationsSupported(true);
                        // local permission granted; push token will be registered separately
                        setFcmToken(prev => prev);

                        
                        // Store flag in user profile
                        if (user) {
                            const profileRef = doc(db, 'artifacts', appId, 'users', user.uid, 'profile', 'main');
                            await setDoc(profileRef, { 
                                notificationsEnabled: true, 
                                notificationsEnabledAt: serverTimestamp() 
                            }, { merge: true });
                        }
                        
                        // Show a test notification
                        showLocalNotification('TimeRoster', t('notificationEnabled') + ' ‚úì');
                        return true;
                    } else {
                        console.log('Notification permission:', permission);
                        return false;
                    }
                } catch (err) {
                    console.error('Permission request error:', err);
                    return false;
                }
            };


            const registerFcmToken = async () => {
                try {
                    if (!user) return false;
                    if (!messaging) return false;
                    if (!('serviceWorker' in navigator)) return false;
                    if (!('Notification' in window)) return false;
                    if (Notification.permission !== 'granted') return false;

                    const vapidKey = getVapidKey();
                    if (!vapidKey) {
                        console.warn('No VAPID key set.');
                        return false;
                    }

                    const registration = await navigator.serviceWorker.ready;
                    const token = await getToken(messaging, { vapidKey, serviceWorkerRegistration: registration });
                    if (!token) return false;

                    setFcmToken(token);
                    await setDoc(
                        doc(db, 'artifacts', appId, 'users', user.uid, 'fcm_tokens', token),
                        { token, updatedAt: serverTimestamp(), ua: navigator.userAgent },
                        { merge: true }
                    );

                    return true;
                } catch (e) {
                    console.error('registerFcmToken error', e);
                    return false;
                }
            };

            // Initialize notifications on user login
            useEffect(() => {
                if (!user) return;
                
                const initializeNotifications = async () => {
                    try {
                        const IS_ANDROID_ASSET = (location.protocol === 'file:');
                        if (IS_ANDROID_ASSET) {
                            console.log("Android WebView detected ‚Üí native FCM path.");
                            const nativeToken = localStorage.getItem("native_fcm_token");
                            if (nativeToken) {
                                setFcmToken(nativeToken);
                                setNotificationsSupported(true);
                            }
                            return;
                        }
                        
                        // Check if Notification API is available
                        if (!('Notification' in window)) {
                            console.log('Notification API not supported');
                            setNotificationsSupported(false);
                            return;
                        }
                        
                        // Mark as supported (even without service worker)
                        setNotificationsSupported(true);
                        
                        // If permission already granted, activate
                        if (Notification.permission === 'granted') {
                            // local permission granted; push token will be registered separately
                        setFcmToken(prev => prev);

                        }
                        
                        // Try to register service worker and get FCM token (optional, best-effort)
                        // GitHub Pages / Web-PWA: we register ./sw.js globally (see <head>).
                        // Here we only "best-effort" grab the current registration to avoid collisions.
                        if ('serviceWorker' in navigator) {
                            try {
                                const registration =
                                    (await navigator.serviceWorker.getRegistration('./')) ||
                                    (await navigator.serviceWorker.getRegistration()) ||
                                    null;
                                if (registration) {
                                    console.log('Service Worker ready:', registration.scope);
                                }
                                // Register FCM token (requires VAPID key in Settings)
                                if (messaging && registration && Notification.permission === 'granted') {
                                    const vapidKey = getVapidKey();
                                    if (vapidKey) {
                                        try {
                                            const token = await getToken(messaging, { vapidKey, serviceWorkerRegistration: registration });
                                            if (token) {
                                                setFcmToken(token);
                                                // Persist token under the user so Cloud Functions can send pushes
                                                await setDoc(
                                                    doc(db, 'artifacts', appId, 'users', user.uid, 'fcm_tokens', token),
                                                    { token, updatedAt: serverTimestamp(), ua: navigator.userAgent },
                                                    { merge: true }
                                                );
                                            }
                                        } catch (tokErr) {
                                            console.warn('FCM token error:', tokErr?.message || tokErr);
                                        }
                                    } else {
                                        console.warn('Missing VAPID key ‚Äì push is not enabled yet.');
                                    }

                                    // Foreground listener (neutral)
                                    try {
                                        onMessage(messaging, async () => {
                                            try {
                                                const reg2 =
                                                    (await navigator.serviceWorker.getRegistration('./')) ||
                                                    (await navigator.serviceWorker.getRegistration()) ||
                                                    null;
                                                if (reg2 && Notification.permission === 'granted') {
                                                    await reg2.showNotification('Kalender aktualisiert', {
                                                        body: 'Es gibt neue Updates.',
                                                        tag: 'timeroster-update',
                                                        data: { url: APP_URL }
                                                    });
                                                }
                                            } catch (e) {}
                                        });
                                    } catch (e) {}
                                }
                            } catch (swErr) {
                                console.warn('Service Worker check failed (non-critical, local notifications still work):', swErr.message);
                            }
                        }
                        
                    } catch (error) {
                        console.error('Error initializing notifications:', error);
                    }
                };
                
                initializeNotifications();
            }, [user]);

            // --- NOTIFICATION LISTENER: Friend Requests ---
            useEffect(() => {
                if (!user || !notificationPrefs.friendRequests) return;
                const q = query(
                    collection(db, 'artifacts', appId, 'secret_requests'),
                    where('to', '==', user.uid),
                    where('status', '==', 'pending')
                );
                const unsub = onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const data = change.doc.data();
                            const nId = `friend-req-${change.doc.id}`;
                            if (!shownNotificationsRef.current.has(nId)) {
                                shownNotificationsRef.current.add(nId);
                                showLocalNotification(
                                    t('notificationFriendRequest'),
                                    `${data.fromName || t('guest')} ${t('notificationFriendRequestBody')}`,
                                    nId
                                );
                            }
                        }
                    });
                });
                return () => unsub();
            }, [user, notificationPrefs.friendRequests]);

            // --- NOTIFICATION LISTENER: Calendar Event Invites (pending_events) ---
            useEffect(() => {
                if (!user || !notificationPrefs.calendarEvents) return;
                const q = query(
                    collection(db, 'artifacts', appId, 'users', user.uid, 'pending_events'),
                    where('status', '==', 'pending')
                );
                const unsub = onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const data = change.doc.data();
                            const nId = `event-invite-${change.doc.id}`;
                            if (!shownNotificationsRef.current.has(nId)) {
                                shownNotificationsRef.current.add(nId);
                                showLocalNotification(
                                    t('notificationEventInvite'),
                                    `${data.fromUserName || t('guest')} ${t('notificationEventInviteBody')}: ${data.title || ''}`,
                                    nId
                                );
                            }
                        }
                    });
                });
                return () => unsub();
            }, [user, notificationPrefs.calendarEvents]);

            // --- NOTIFICATION LISTENER: Chat Messages (across all secret_chats) ---
            useEffect(() => {
                if (!user || !notificationPrefs.chatMessages) return;
                // Listen to contacts to know which chats to monitor
                const contactsRef = collection(db, 'artifacts', appId, 'users', user.uid, 'secret_contacts');
                const unsub = onSnapshot(contactsRef, (contactsSnap) => {
                    const chatUnsubs = [];
                    contactsSnap.docs.forEach((contactDoc) => {
                        const contactData = contactDoc.data();
                        if (!contactData.friendId) return;
                        const chatId = [user.uid, contactData.friendId].sort().join('_');
                        const msgsRef = collection(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs');
                        const msgsQuery = query(msgsRef, orderBy('ts', 'desc'), limit(1));
                        const chatUnsub = onSnapshot(msgsQuery, (msgSnap) => {
                            msgSnap.docChanges().forEach((change) => {
                                if (change.type === 'added') {
                                    const msgData = change.doc.data();
                                    // Only notify for messages from others, not our own
                                    if (msgData.from && msgData.from !== user.uid) {
                                        const nId = `chat-msg-${change.doc.id}`;
                                        if (!shownNotificationsRef.current.has(nId)) {
                                            shownNotificationsRef.current.add(nId);
                                            // Don't notify on initial load (check timestamp)
                                            const msgTime = msgData.ts?.toMillis?.() || msgData.ts?.seconds * 1000 || 0;
                                            const now = Date.now();
                                            // Only notify if message is less than 30 seconds old
                                            if (now - msgTime < 30000) {
                                                showLocalNotification(
                                                    'Kalender aktualisiert',
                                                    'Es gibt neue Updates.',
                                                    nId
                                                );
                                            }
                                        }
                                    }
                                }
                            });
                        });
                        chatUnsubs.push(chatUnsub);
                    });
                    return () => chatUnsubs.forEach(u => u());
                });
                return () => unsub();
            }, [user, notificationPrefs.chatMessages]);

            // --- NOTIFICATION: Calendar Event Reminders (check upcoming events every minute) ---
            useEffect(() => {
                if (!user || !notificationPrefs.calendarEvents) return;
                const shownReminders = new Set();
                
                const checkUpcomingEvents = () => {
                    const now = new Date();
                    const in15min = new Date(now.getTime() + 15 * 60 * 1000);
                    const todayStr = formatDate(now);
                    
                    events.forEach(ev => {
                        if (!ev.time || !ev.date) return;
                        const reminderId = `reminder-${ev.id}-${ev.date}`;
                        if (shownReminders.has(reminderId)) return;
                        
                        const [hours, minutes] = ev.time.split(':').map(Number);
                        const eventDate = new Date(ev.date + 'T' + ev.time);
                        
                        // Check if event is within the next 15 minutes
                        if (eventDate > now && eventDate <= in15min) {
                            shownReminders.add(reminderId);
                            const minutesUntil = Math.round((eventDate - now) / 60000);
                            showLocalNotification(
                                'Kalender aktualisiert',
                                'Es gibt neue Updates.',
                                reminderId
                            );
                        }
                    });
                };
                
                checkUpcomingEvents();
                const interval = setInterval(checkUpcomingEvents, 60000); // Check every minute
                return () => clearInterval(interval);
            }, [user, events, notificationPrefs.calendarEvents]);

            // --- NOTIFICATION: Write notification queue entry to Firestore for server-side delivery ---
            const queuePushNotification = async (recipientUserId, _title, _body, data = {}) => {
                if (!recipientUserId || recipientUserId === user?.uid) return;
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'notification_queue'), {
                        recipientUserId,
                        title: 'Kalender aktualisiert',
                        body: 'Es gibt neue Updates.',
                        data: { ...data, senderId: user?.uid || '' },
                        createdAt: serverTimestamp(),
                        status: 'pending'
                    });
                } catch (err) {
                    console.warn('Failed to queue push notification:', err);
                }
            };

            // Notify all members of a calendar (neutral text) ‚Äì excludes the sender by default
            const queueCalendarUpdatedToMembers = async (calendarId, excludeUserId = user?.uid) => {
                try {
                    const cal = calendars.find(c => c.id === calendarId);
                    const members = (cal?.members || []).filter(Boolean);
                    members.filter(uid => uid && uid !== excludeUserId).forEach(uid => {
                        queuePushNotification(uid, 'Kalender aktualisiert', 'Es gibt neue Updates.', { type: 'calendar_update', calendarId });
                    });
                } catch (e) {
                    console.warn('queueCalendarUpdatedToMembers failed:', e?.message || e);
                }
            };


            
            // Track unread messages across all conversations
            useEffect(() => {
                if (!user) return;
                
                const unsubscribers = []; // Collect all listeners for cleanup
                
                const countUnreadInSnapshot = (snap) => {
                    let unreadCount = 0;
                    snap.docs.forEach(msgDoc => {
                        const msgData = msgDoc.data();
                        if (msgData.from !== user.uid && (!msgData.readBy || !msgData.readBy.includes(user.uid))) {
                            unreadCount++;
                        }
                    });
                    return unreadCount;
                };
                
                const updateTotalUnread = () => {
                    const total = Object.values(unreadTotalsRef.current).reduce((sum, count) => sum + count, 0);
                    setUnreadMessageCount(total);
                    setLastUnreadUpdate(Date.now());
                };
                
                const trackUnreadMessages = async () => {
                    try {
                        unreadTotalsRef.current = {};
                        
                        // Get all accepted friends
                        const friendsQuery = query(
                            collection(db, 'artifacts', appId, 'users', user.uid, 'friends'),
                            where('status', '==', 'accepted')
                        );
                        const friendsSnap = await getDocs(friendsQuery);
                        
                        // Track unread messages for each friend conversation
                        for (const friendDoc of friendsSnap.docs) {
                            const friendData = friendDoc.data();
                            // Legacy friends docs store the friend id as the document id.
                            const friendId = friendData.friendId || friendDoc.id;
                            if (!friendId) continue;
                            const chatId = [user.uid, friendId].sort().join('_');
                            
                            const messagesQuery = query(
                                collection(db, 'artifacts', appId, 'secret_chats', chatId, 'msgs'),
                                orderBy('ts', 'desc'),
                                limit(50)
                            );
                            
                            const unsub = onSnapshot(messagesQuery, (snap) => {
                                unreadTotalsRef.current[chatId] = countUnreadInSnapshot(snap);
                                updateTotalUnread();
                            });
                            
                            unsubscribers.push(unsub);
                        }
                        
                        // Track unread messages for group conversations
                        const groupsQuery = query(
                            collection(db, 'artifacts', appId, 'secret_groups'),
                            where('members', 'array-contains', user.uid)
                        );
                        const groupsSnap = await getDocs(groupsQuery);
                        
                        for (const groupDoc of groupsSnap.docs) {
                            const groupId = groupDoc.id;
                            
                            const messagesQuery = query(
                                collection(db, 'artifacts', appId, 'secret_groups', groupId, 'msgs'),
                                orderBy('ts', 'desc'),
                                limit(50)
                            );
                            
                            const unsub = onSnapshot(messagesQuery, (snap) => {
                                unreadTotalsRef.current[`group_${groupId}`] = countUnreadInSnapshot(snap);
                                updateTotalUnread();
                            });
                            
                            unsubscribers.push(unsub);
                        }
                        
                    } catch (error) {
                        console.error('Error tracking unread messages:', error);
                    }
                };
                
                trackUnreadMessages();
                
                // Cleanup: Unsubscribe all listeners when user changes or component unmounts
                // This prevents memory leaks and duplicate listeners
                return () => {
                    unsubscribers.forEach(unsub => unsub());
                };
            }, [user]);
            
            // Load user's calendars
            useEffect(() => {
                if (!user) return;
                
                const initializeCalendars = async () => {
                    try {
                        // Check if user has calendars collection
                        const calendarsRef = collection(db, 'artifacts', appId, 'calendars');
                        const userCalendarsQuery = query(
                            calendarsRef, 
                            where('members', 'array-contains', user.uid)
                        );
                        
                        const snapshot = await getDocs(userCalendarsQuery);
                        
                        if (snapshot.empty) {
                            // Create default calendar for user
                            const defaultCalendarId = generateCalendarId();
                            const defaultCalendar = {
                                id: defaultCalendarId,
                        name: t('calendarDefaultName'),
                        description: t('calendarDefaultDescription'),
                                color: '#3B82F6',
                                ownerId: user.uid,
                                members: [user.uid],
                                roles: {
                                    [user.uid]: 'owner'
                                },
                                isPublic: false,
                                publicToken: null,
                                subscriptionToken: null,
                                createdAt: serverTimestamp(),
                                updatedAt: serverTimestamp()
                            };
                            
                            await setDoc(doc(calendarsRef, defaultCalendarId), defaultCalendar);
                            setCalendars([{ id: defaultCalendarId, ...defaultCalendar }]);
                            setActiveCalendarId(defaultCalendarId);
                            
                            // Migrate existing events to default calendar if any exist
                            const existingEventsSnap = await getDocs(
                                collection(db, 'artifacts', appId, 'users', user.uid, 'events')
                            );
                            
                            if (!existingEventsSnap.empty) {
                                const batch = writeBatch(db);
                                existingEventsSnap.forEach(eventDoc => {
                                    const newEventRef = doc(
                                        collection(db, 'artifacts', appId, 'calendars', defaultCalendarId, 'events')
                                    );
                                    batch.set(newEventRef, eventDoc.data());
                                });
                                batch.commit();
                                console.log('Migrated existing events to default calendar');
                            }

                            const existingScheduleSnap = await getDocs(
                                collection(db, 'artifacts', appId, 'users', user.uid, 'schedule')
                            );
                            
                            if (!existingScheduleSnap.empty) {
                                const batch = writeBatch(db);
                                existingScheduleSnap.forEach(scheduleDoc => {
                                    const newScheduleRef = doc(
                                        collection(db, 'artifacts', appId, 'calendars', defaultCalendarId, 'schedule', scheduleDoc.id)
                                    );
                                    batch.set(newScheduleRef, scheduleDoc.data());
                                });
                                batch.commit();
                                console.log('Migrated existing schedule to default calendar');
                            }
                            
                            const existingShiftsSnap = await getDocs(
                                collection(db, 'artifacts', appId, 'users', user.uid, 'shifts')
                            );
                            
                            if (!existingShiftsSnap.empty) {
                                const batch = writeBatch(db);
                                existingShiftsSnap.forEach(shiftDoc => {
                                    const newShiftRef = doc(
                                        collection(db, 'artifacts', appId, 'calendars', defaultCalendarId, 'shifts', shiftDoc.id)
                                    );
                                    batch.set(newShiftRef, shiftDoc.data());
                                });
                                batch.commit();
                                console.log('Migrated existing shifts to default calendar');
                            }
                        } else {
                            const cals = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                            setCalendars(cals);
                            
                            // Set active calendar to first owned calendar or first calendar
                            const ownedCal = cals.find(c => c.ownerId === user.uid);
                            const lastCalendar = safeStorageGet('timeroster_last_calendar');
                            const restored = cals.find(c => c.id === lastCalendar);
                            setActiveCalendarId(restored ? restored.id : (ownedCal ? ownedCal.id : cals[0].id));
                        }
                    } catch (error) {
                        console.error('Error initializing calendars:', error);
                        setUiError(t('eventsLoadErrorDetails'));
                    }
                };
                
                initializeCalendars();
            }, [user]);

            // Load user's friends
            useEffect(() => {
                if (!user) return;
                const unsub = onSnapshot(
                    query(
                        collection(db, 'artifacts', appId, 'users', user.uid, 'friends'),
                        where('status', '==', 'accepted')
                    ),
                    (snap) => {
                        const friendsList = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                        setFriends(friendsList);
                    },
                    (err) => console.error("Friends loading error", err)
                );
                return () => unsub();
            }, [user]);

            useEffect(() => {
                if(!user) return;
                setUiError(''); // Clear previous errors
                
                // Use activeCalendarId for new calendar structure, or fall back to viewing friend's events
                const targetUid = viewingUserId || user.uid;
                const useCalendarStructure = !viewingUserId && activeCalendarId && activeCalendarId !== 'all';

                // Fetch friend name if viewing a friend's calendar
                if (viewingUserId) {
                    const friendRef = doc(db, 'artifacts', appId, 'users', user.uid, 'friends', viewingUserId);
                    getDoc(friendRef).then(snap => {
                        if (snap.exists()) {
                            setViewingFriendName(snap.data().name || 'Friend');
                        }
                    }).catch(e => console.log("Friend name fetch error", e));
                } else {
                    setViewingFriendName(null);
                }

                try {
                    let u1 = () => {};
                    let u2 = () => {};
                    let u3 = () => {};
                    const calendarUnsubs = [];

                    if (!viewingUserId && activeCalendarId === 'all') {
                        // Load events, shifts, schedule across all calendars
                        calendars.forEach(cal => {
                            const eventsUnsub = onSnapshot(
                                collection(db, 'artifacts', appId, 'calendars', cal.id, 'events'),
                                s => {
                                    setCalendarEvents(prev => ({ ...prev, [cal.id]: s.docs.map(d => ({ id: d.id, ...d.data() })) }));
                                },
                                e => { console.error(e); setUiError("Fehler beim Laden der Events."); }
                            );
                            const shiftsUnsub = onSnapshot(
                                collection(db, 'artifacts', appId, 'calendars', cal.id, 'shifts'),
                                s => {
                                    const shiftMap = {};
                                    s.forEach(d => { shiftMap[d.id] = { id: d.id, ...d.data() }; });
                                    setCalendarShifts(prev => ({ ...prev, [cal.id]: shiftMap }));
                                },
                                e => console.error(e)
                            );
                            const scheduleUnsub = onSnapshot(
                                collection(db, 'artifacts', appId, 'calendars', cal.id, 'schedule'),
                                s => {
                                    const sc = {};
                                    s.forEach(d => { sc[d.id] = d.data().shiftId; });
                                    setCalendarSchedule(prev => ({ ...prev, [cal.id]: sc }));
                                },
                                e => console.error(e)
                            );
                            calendarUnsubs.push(() => { eventsUnsub(); shiftsUnsub(); scheduleUnsub(); });
                        });
                        setEvents([]);
                        return () => {
                            calendarUnsubs.forEach(fn => fn());
                        };
                    }

                    // Load events from calendar structure or fallback to user events
                    u1 = useCalendarStructure 
                        ? onSnapshot(
                            collection(db, 'artifacts', appId, 'calendars', activeCalendarId, 'events'),
                            s => setEvents(s.docs.map(d => ({ id: d.id, ...d.data() }))),
                            e => { 
                                console.error(e); 
                                // Fallback to user events if calendar events fail
                                onSnapshot(
                                    collection(db, 'artifacts', appId, 'users', user.uid, 'events'),
                                    s => setEvents(s.docs.map(d => ({ id: d.id, ...d.data() }))),
                                    err => setUiError("Fehler beim Laden der Events.")
                                );
                            }
                          )
                        : onSnapshot(
                            collection(db, 'artifacts', appId, 'users', targetUid, 'events'), 
                            s => setEvents(s.docs.map(d => ({ id: d.id, ...d.data() }))),
                            e => { console.error(e); setUiError("Fehler beim Laden der Events. Datenbank pr√ºfen."); }
                          );
                    
                    const shiftSource = useCalendarStructure && activeCalendarId && activeCalendarId !== 'all'
                        ? collection(db, 'artifacts', appId, 'calendars', activeCalendarId, 'shifts')
                        : collection(db, 'artifacts', appId, 'users', targetUid, 'shifts');
                    u2 = onSnapshot(shiftSource, 
                        s => {
                            const shiftList = s.docs.map(d => ({ id: d.id, ...d.data() }));
                            setShifts(shiftList.length ? shiftList : DEFAULT_SHIFTS);
                        },
                        e => console.error(e)
                    );
                    const scheduleSource = useCalendarStructure && activeCalendarId && activeCalendarId !== 'all'
                        ? collection(db, 'artifacts', appId, 'calendars', activeCalendarId, 'schedule')
                        : collection(db, 'artifacts', appId, 'users', targetUid, 'schedule');
                    u3 = onSnapshot(scheduleSource, 
                        s => { const sc={}; s.forEach(d=>sc[d.id]=d.data().shiftId); setSchedule(sc); },
                        e => console.error(e)
                    );
                    return () => { u1(); u2(); u3(); };
                } catch (e) { setUiError(`${t('criticalError')} ${e.message}`); }
            }, [user, viewingUserId, activeCalendarId]);

            // Load tasks
            useEffect(() => {
                if (!user) return;
                const unsub = onSnapshot(
                    collection(db, 'artifacts', appId, 'users', user.uid, 'tasks'),
                    snapshot => {
                        setTasks(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
                    },
                    error => console.error('Error loading tasks:', error)
                );
                return () => unsub();
            }, [user]);

            // Load task time entries
            useEffect(() => {
                if (!user) return;
                const unsub = onSnapshot(
                    collection(db, 'artifacts', appId, 'users', user.uid, 'taskTimeEntries'),
                    snapshot => {
                        const entries = {};
                        snapshot.docs.forEach(d => {
                            const data = d.data();
                            if (!entries[data.taskId]) entries[data.taskId] = [];
                            entries[data.taskId].push({ id: d.id, ...data });
                        });
                        setTaskTimeEntries(entries);
                    },
                    error => console.error('Error loading task time entries:', error)
                );
                return () => unsub();
            }, [user]);

            // Fetch friend's name when viewing their calendar
            useEffect(() => {
                if (!viewingUserId) {
                    setViewingFriendName('');
                    return;
                }
                const fetchFriendName = async () => {
                    try {
                        // Try to get from profile first
                        const profileRef = doc(db, 'artifacts', appId, 'users', viewingUserId, 'profile', 'main');
                        const profileSnap = await getDoc(profileRef);
                        if (profileSnap.exists() && profileSnap.data().username) {
                            setViewingFriendName(profileSnap.data().username);
                            return;
                        }
                        // Try MSN profile
                        const msnProfileRef = doc(db, 'artifacts', appId, 'users', viewingUserId, 'secret_msn_profile', 'main');
                        const msnSnap = await getDoc(msnProfileRef);
                        if (msnSnap.exists() && msnSnap.data().username) {
                            setViewingFriendName(msnSnap.data().username);
                            return;
                        }
                        // Fallback to friend's shareCode
                        const friendRef = doc(db, 'artifacts', appId, 'users', user.uid, 'friends', viewingUserId);
                        const friendSnap = await getDoc(friendRef);
                        if (friendSnap.exists()) {
                            setViewingFriendName(friendSnap.data().shareCode || t('friendFallback'));
                        } else {
                            setViewingFriendName(t('friendFallback'));
                        }
                    } catch (e) {
                        console.error("Error fetching friend name", e);
                        setViewingFriendName(t('friendFallback'));
                    }
                };
                fetchFriendName();
            }, [viewingUserId, user]);

                        
            const saveDisplayName = async (newNameRaw) => {
                if (!user) return;
                const newName = (newNameRaw || '').trim();
                if (!newName) return alert(t('pleaseEnterName'));
                try {
                    const profileRef = doc(db, 'artifacts', appId, 'users', user.uid, 'profile', 'main');
                    await setDoc(profileRef, { name: newName }, { merge: true });
                    if (shareCode) {
                        await setDoc(doc(db, 'artifacts', appId, 'public_profiles', shareCode), { userId: user.uid, name: newName }, { merge: true });
                    }
                    // Update name in friends' documents (so existing friends see it too)
                    const myFriendsSnap = await getDocs(collection(db, 'artifacts', appId, 'users', user.uid, 'friends'));
                    const batch = writeBatch(db);
                    myFriendsSnap.forEach(fdoc => {
                        const fid = fdoc.id;
                        batch.set(doc(db, 'artifacts', appId, 'users', fid, 'friends', user.uid), { name: newName }, { merge: true });
                    });
                    batch.commit();
                    setDisplayName(newName);
                    alert(t('nameSaved'));
                } catch (e) {
                    console.error("saveDisplayName error", e);
                    alert(t('nameSaveError'));
                }
            };

            const addEvent = async (d, mode) => { 
                const { _occDate, _key, invitees, calendarId, ...clean } = (d || {}); 
                const eventId = crypto.randomUUID();
                const myName = ((displayName || '').trim() || getUserName(user));
                const targetFriendId = viewingUserId || null;
                const targetFriendName = viewingFriendName || t('friendFallback');
                const lastCalendarId = safeStorageGet('timeroster_last_calendar');
                const fallbackCalendarId = calendars.find(c => c.id === lastCalendarId)?.id
                    || calendars.find(c => c.ownerId === user.uid)?.id
                    || calendars[0]?.id
                    || null;
                const resolvedCalendarId = (activeCalendarId && activeCalendarId !== 'all' ? activeCalendarId : fallbackCalendarId);

                // Mode normalisieren
                const m = (mode || (targetFriendId ? 'request' : 'self'));
                const wantsSelf = (m === 'self' || m === 'self_and_request');
                const wantsRequest = (m === 'request' || m === 'self_and_request' || (invitees && invitees.length > 0));

                try {
                    if (!viewingUserId && (!resolvedCalendarId || activeCalendarId === 'all')) {
                        alert(t('selectCalendarForEvent'));
                        return;
                    }
                    // Build participants list from invitees or default behavior
                    // Note: The event creator (organizer) is always added with 'accepted' status
                    // because they are creating the event and implicitly accepting participation
                    let participants = [
                        { userId: user.uid, userName: myName, status: 'accepted' }
                    ];
                    
                    // Add invitees if provided
                    if (invitees && invitees.length > 0) {
                        invitees.forEach(inv => {
                            if (inv.userId) {
                                participants.push({ 
                                    userId: inv.userId, 
                                    userName: inv.userName, 
                                    status: inv.status || 'pending' 
                                });
                            }
                        });
                    } else if (wantsRequest && targetFriendId) {
                        // Legacy behavior: add friend as participant
                        participants.push({ userId: targetFriendId, userName: targetFriendName, status: 'pending' });
                    }

                    const eventPayload = { ...clean, participants, createdBy: user.uid, status: 'approved', sourceCalendarId: resolvedCalendarId || null, ...(resolvedCalendarId ? { calendarId: resolvedCalendarId } : {}) };
                    const getRecipientCalendarId = async (recipientId) => {
                        if (!recipientId) return null;
                        try {
                            const ownedQuery = query(
                                collection(db, 'artifacts', appId, 'calendars'),
                                where('ownerId', '==', recipientId)
                            );
                            const ownedSnap = await getDocs(ownedQuery);
                            if (!ownedSnap.empty) return ownedSnap.docs[0].id;
                            const memberQuery = query(
                                collection(db, 'artifacts', appId, 'calendars'),
                                where('members', 'array-contains', recipientId)
                            );
                            const memberSnap = await getDocs(memberQuery);
                            if (!memberSnap.empty) return memberSnap.docs[0].id;
                        } catch (e) {
                            console.warn('getRecipientCalendarId error', e);
                        }
                        return null;
                    };
                    const createPendingInvite = async (recipientId) => {
                        if (!recipientId || recipientId === user.uid) return;
                        const recipientCalendarId = await getRecipientCalendarId(recipientId);
                        const recipientPayload = {
                            ...eventPayload,
                            ...(recipientCalendarId ? { calendarId: recipientCalendarId } : {}),
                            status: 'pending'
                        };
                        if (recipientCalendarId) {
                            await setDoc(doc(db, 'artifacts', appId, 'calendars', recipientCalendarId, 'events', eventId), recipientPayload);
                        } else {
                            await setDoc(doc(db, 'artifacts', appId, 'users', recipientId, 'events', eventId), recipientPayload);
                        }
                        await addDoc(collection(db, 'artifacts', appId, 'users', recipientId, 'pending_events'), {
                            ...eventPayload,
                            eventId,
                            sourceCalendarId: resolvedCalendarId || null,
                            recipientCalendarId: recipientCalendarId || null,
                            status: 'pending',
                            fromUserId: user.uid,
                            fromUserName: myName,
                            createdAt: serverTimestamp()
                        });
                    };

                    if (wantsSelf) {
                        // Use calendar structure if activeCalendarId exists, otherwise fallback to user events
                        if (resolvedCalendarId) {
                            await setDoc(doc(db, 'artifacts', appId, 'calendars', resolvedCalendarId, 'events', eventId), eventPayload);
                        } else {
                            await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'events', eventId), eventPayload);
                        }
                    }

                    const requestRecipients = new Set();
                    if (invitees && invitees.length > 0) {
                        invitees.filter(inv => inv?.userId).forEach(inv => requestRecipients.add(inv.userId));
                    }
                    if (wantsRequest && targetFriendId) {
                        requestRecipients.add(targetFriendId);
                    }

                    if (requestRecipients.size > 0) {
                        await Promise.all([...requestRecipients].map(recipientId => createPendingInvite(recipientId)));
                        // Queue push notifications for event invites
                        [...requestRecipients].forEach(recipientId => {
                            queuePushNotification(
                                recipientId,
                                'Kalender aktualisiert',
                                'Es gibt neue Updates.',
                                { type: 'event_invite', eventId }
                            );
                        });
                        const nameList = [...requestRecipients]
                            .map(id => {
                                const inv = invitees?.find(item => item.userId === id);
                                return inv?.userName || (id === targetFriendId ? targetFriendName : t('friendFallback'));
                            })
                            .filter(Boolean)
                            .join(', ');
                        alert(`${t('eventRequestSent')} ${nameList || t('friendFallback')} ${t('requestSentSuffix')}`);
                    }
                } catch (e) {
                    console.error("addEvent error", e);
                    alert(t('eventSaveError'));
                }

                                        // Notify calendar members about changes (neutral)
                        await queueCalendarUpdatedToMembers(targetCalendarId);
setShowEventModal(false); 
            };
            
            const updateEvent = async (d) => { 
                const { id, _occDate, _key, calendarId, ...clean } = (d || {}); 
                try {
                    const lastCalendarId = safeStorageGet('timeroster_last_calendar');
                    const fallbackCalendarId = calendars.find(c => c.id === lastCalendarId)?.id
                        || calendars.find(c => c.ownerId === user.uid)?.id
                        || calendars[0]?.id
                        || null;
                    const targetCalendarId = calendarId || (activeCalendarId && activeCalendarId !== 'all' ? activeCalendarId : fallbackCalendarId);
                    if (!targetCalendarId || targetCalendarId === 'all') {
                        alert(t('selectCalendarForEvent'));
                        return;
                    }
                    if (targetCalendarId) {
                        await updateDoc(doc(db, 'artifacts', appId, 'calendars', targetCalendarId, 'events', id), { ...clean, calendarId: targetCalendarId });
                        await queueCalendarUpdatedToMembers(targetCalendarId);

                    } else {
                        await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'events', id), clean);
                    }
                } catch (e) {
                    console.error("updateEvent error", e);
                    alert(t('eventUpdateError'));
                }
                setSelectedEvent(null); 
            };
            
            const deleteEvent = async (id) => { 
                try {
                    const lastCalendarId = safeStorageGet('timeroster_last_calendar');
                    const fallbackCalendarId = calendars.find(c => c.id === lastCalendarId)?.id
                        || calendars.find(c => c.ownerId === user.uid)?.id
                        || calendars[0]?.id
                        || null;
                    const targetCalendarId = selectedEvent?.calendarId || (activeCalendarId && activeCalendarId !== 'all' ? activeCalendarId : fallbackCalendarId);
                    if (!targetCalendarId || targetCalendarId === 'all') {
                        alert(t('selectCalendarForEvent'));
                        return;
                    }
                    if (targetCalendarId) {
                        await deleteDoc(doc(db, 'artifacts', appId, 'calendars', targetCalendarId, 'events', id));
                        await queueCalendarUpdatedToMembers(targetCalendarId);

                    } else {
                        await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'events', id));
                    }
                } catch (e) {
                    console.error("deleteEvent error", e);
                    alert(t('eventDeleteError'));
                }
                setSelectedEvent(null); 
            };
            
            const approvePendingEvent = async (pendingEventId) => {
                const pendingDoc = pendingEventRequests.find(e => e.id === pendingEventId);
                if (!pendingDoc) return;
                const { id, status, fromUserId, fromUserName, createdAt, eventId, sourceCalendarId, recipientCalendarId, ...eventData } = pendingDoc;
                const lastCalendarId = safeStorageGet('timeroster_last_calendar');
                const fallbackCalendarId = calendars.find(c => c.id === lastCalendarId)?.id
                    || calendars.find(c => c.ownerId === user.uid)?.id
                    || calendars[0]?.id
                    || null;
                const targetCalendarId = recipientCalendarId
                    || eventData.calendarId
                    || (activeCalendarId && activeCalendarId !== 'all' ? activeCalendarId : fallbackCalendarId);
                
                // Update participant status for the approving user to 'accepted'
                let participants = eventData.participants || [];
                participants = participants.map(p => 
                    p.userId === user.uid ? { ...p, status: 'accepted' } : p
                );
                
                if (targetCalendarId) {
                    await setDoc(doc(db, 'artifacts', appId, 'calendars', targetCalendarId, 'events', eventId || crypto.randomUUID()), {
                        ...eventData,
                        calendarId: targetCalendarId,
                        status: 'approved',
                        participants
                    });
                } else {
                    await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'events', eventId || crypto.randomUUID()), {
                        ...eventData,
                        status: 'approved',
                        participants
                    });
                }
                await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'pending_events', pendingEventId), { status: 'approved' });
                if (fromUserId && eventId && sourceCalendarId) {
                    await updateDoc(doc(db, 'artifacts', appId, 'calendars', sourceCalendarId, 'events', eventId), {
                        status: 'approved',
                        participants
                    });
                }
            };

            const rejectPendingEvent = async (pendingEventId) => {
                const pendingDoc = pendingEventRequests.find(e => e.id === pendingEventId);
                if (pendingDoc?.eventId && pendingDoc.recipientCalendarId) {
                    await updateDoc(doc(db, 'artifacts', appId, 'calendars', pendingDoc.recipientCalendarId, 'events', pendingDoc.eventId), { status: 'rejected' });
                } else if (pendingDoc?.eventId) {
                    await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'events', pendingDoc.eventId), { status: 'rejected' });
                }
                await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'pending_events', pendingEventId), { status: 'rejected' });
            };

            const bulkUpdatePendingEvents = async (ids, nextStatus) => {
                if (!ids.length) return;
                const batch = writeBatch(db);
                ids.forEach(pid => {
                    const req = pendingEventRequests.find(item => item.id === pid);
                    batch.update(doc(db, 'artifacts', appId, 'users', user.uid, 'pending_events', pid), { status: nextStatus });
                    if (req?.eventId) {
                        if (req.recipientCalendarId) {
                            batch.update(doc(db, 'artifacts', appId, 'calendars', req.recipientCalendarId, 'events', req.eventId), { status: nextStatus });
                        } else {
                            batch.update(doc(db, 'artifacts', appId, 'users', user.uid, 'events', req.eventId), { status: nextStatus });
                        }
                    }
                });
                batch.commit();
            };
            
            const updateParticipantStatus = async (eventId, userId, newStatus) => {
                const eventInState = events.find(ev => ev.id === eventId) || null;
                const targetCalendarId = eventInState?.calendarId || (activeCalendarId && activeCalendarId !== 'all' ? activeCalendarId : null);
                const eventRef = targetCalendarId
                    ? doc(db, 'artifacts', appId, 'calendars', targetCalendarId, 'events', eventId)
                    : doc(db, 'artifacts', appId, 'users', user.uid, 'events', eventId);
                const eventDoc = await getDoc(eventRef);
                if (!eventDoc.exists()) return;
                
                const eventData = eventDoc.data();
                const participants = eventData.participants || [];
                
                // Check if user exists in participants list
                const userExists = participants.some(p => p.userId === userId);
                if (!userExists) {
                    console.warn('User not found in participants list:', userId);
                    return;
                }
                
                const updatedParticipants = participants.map(p => 
                    p.userId === userId ? { ...p, status: newStatus } : p
                );
                const statusUpdate = { participants: updatedParticipants };
                if (userId === user.uid) {
                    statusUpdate.status = newStatus === 'accepted'
                        ? 'approved'
                        : newStatus === 'declined'
                            ? 'rejected'
                            : 'pending';
                }
                
                await updateDoc(eventRef, statusUpdate);
                if (eventData.sourceCalendarId && eventData.sourceCalendarId !== targetCalendarId) {
                    await updateDoc(doc(db, 'artifacts', appId, 'calendars', eventData.sourceCalendarId, 'events', eventId), statusUpdate);
                }
                if (userId === user.uid) {
                    const pendingMatch = pendingEventRequests.find(req => req.eventId === eventId);
                    if (pendingMatch) {
                        await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'pending_events', pendingMatch.id), { status: statusUpdate.status });
                    }
                }
            };

            const assignShift = async (dateStr, sId) => {
                if (!activeCalendarId || activeCalendarId === 'all') {
                    alert(t('selectCalendarForShift'));
                    return;
                }
                if (sId) {
                    await setDoc(doc(db, 'artifacts', appId, 'calendars', activeCalendarId, 'schedule', dateStr), { shiftId: sId });
                } else {
                    await deleteDoc(doc(db, 'artifacts', appId, 'calendars', activeCalendarId, 'schedule', dateStr));
                }
            };
            const clearShift = async (dateStr) => await assignShift(dateStr, null);
            // FIX: fehlende Funktionen, damit "Einstellungen" nicht abst√ºrzt
            const saveShiftConfig = async (shift) => {
                if (!user || !shift) return;
                const sid = shift.id || crypto.randomUUID();
                if (!activeCalendarId || activeCalendarId === 'all') {
                    alert(t('selectCalendarForShift'));
                    return;
                }
                await setDoc(doc(db, 'artifacts', appId, 'calendars', activeCalendarId, 'shifts', sid), {
                    name: shift.name || 'Schicht',
                    start: shift.start || '06:00',
                    end: shift.end || '14:00',
                    color: shift.color || '#3b82f6'
                }, { merge: true });
            };

            const deleteShift = async (sid) => {
                if (!user || !sid) return;
                if (sid === 'off') return alert(t('shiftDeleteLocked'));
                try {
                    await deleteDoc(doc(db, 'artifacts', appId, 'calendars', activeCalendarId, 'shifts', sid));
                } catch (e) {
                    console.error(e);
                    alert(t('shiftDeleteError'));
                }
            };

            // Calendar Management Functions
            const createCalendar = async (calendarData) => {
                if (!user) return;
                try {
                    const calendarId = generateCalendarId();
                    
                    // Initialize members and roles
                    const members = [user.uid];
                    const roles = { [user.uid]: 'owner' };
                    
                    // Add selected friends to members
                    if (calendarData.selectedFriends && Array.isArray(calendarData.selectedFriends)) {
                        calendarData.selectedFriends.forEach(friendId => {
                            if (!members.includes(friendId)) {
                                members.push(friendId);
                                roles[friendId] = 'viewer'; // Default role for shared friends
                            }
                        });
                    }
                    
                    const newCalendar = {
                        name: calendarData.name || 'Neuer Kalender',
                        description: calendarData.description || '',
                        color: calendarData.color || '#3B82F6',
                        ownerId: user.uid,
                        members: members,
                        roles: roles,
                        isPublic: false,
                        publicToken: null,
                        subscriptionToken: null,
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    };
                    
                    await setDoc(doc(db, 'artifacts', appId, 'calendars', calendarId), newCalendar);
                    setCalendars(prev => [...prev, { id: calendarId, ...newCalendar }]);
                    setActiveCalendarId(calendarId);
                    return calendarId;
                } catch (e) {
                    console.error("createCalendar error", e);
                    alert(t('calendarCreateError'));
                    return null;
                }
            };
            
            const updateCalendar = async (calendarId, updates) => {
                if (!user) return;
                try {
                    await updateDoc(doc(db, 'artifacts', appId, 'calendars', calendarId), {
                        ...updates,
                        updatedAt: serverTimestamp()
                    });
                    setCalendars(prev => prev.map(c => c.id === calendarId ? { ...c, ...updates } : c));
                } catch (e) {
                    console.error("updateCalendar error", e);
                    alert(t('calendarUpdateError'));
                }
            };
            
            const shareCalendarWithUser = async (calendarId, friendId, role = 'viewer') => {
                if (!user) return;
                try {
                    const calendar = calendars.find(c => c.id === calendarId);
                    if (!calendar) return alert(t('calendarNotFound'));
                    if (calendar.ownerId !== user.uid) return alert(t('onlyOwnerCanShare'));
                    
                    // Add friend to calendar members and roles
                    const updatedMembers = [...(calendar.members || [])];
                    if (!updatedMembers.includes(friendId)) {
                        updatedMembers.push(friendId);
                    }
                    
                    const updatedRoles = { ...(calendar.roles || {}) };
                    updatedRoles[friendId] = role;
                    
                    await updateDoc(doc(db, 'artifacts', appId, 'calendars', calendarId), {
                        members: updatedMembers,
                        roles: updatedRoles,
                        updatedAt: serverTimestamp()
                    });
                    
                    setCalendars(prev => prev.map(c => 
                        c.id === calendarId ? { ...c, members: updatedMembers, roles: updatedRoles } : c
                    ));
                } catch (e) {
                    console.error("shareCalendarWithUser error", e);
                    alert(t('calendarShareError'));
                }
            };
            
            const shareCalendar = async (calendarId, userEmail, role = 'viewer') => {
                if (!user) return;
                try {
                    const calendar = calendars.find(c => c.id === calendarId);
                    if (!calendar) return alert(t('calendarNotFound'));
                    
                    // In a real app, you'd look up the user by email
                    // For now, we'll share by public link
                    alert(t('sharingRequiresEmailLookup'));
                } catch (e) {
                    console.error("shareCalendar error", e);
                    alert(t('calendarShareError'));
                }
            };
            
            const makeCalendarPublic = async (calendarId, isPublic) => {
                if (!user) return;
                try {
                    const calendar = calendars.find(c => c.id === calendarId);
                    if (!calendar) return alert(t('calendarNotFound'));
                    if (calendar.ownerId !== user.uid) return alert(t('onlyOwnerCanChangeSettings'));
                    
                    const publicToken = isPublic ? (calendar.publicToken || generateSecureToken()) : null;
                    const subscriptionToken = isPublic ? (calendar.subscriptionToken || generateSecureToken()) : null;
                    
                    await updateDoc(doc(db, 'artifacts', appId, 'calendars', calendarId), {
                        isPublic,
                        publicToken,
                        subscriptionToken,
                        updatedAt: serverTimestamp()
                    });
                    
                    setCalendars(prev => prev.map(c => 
                        c.id === calendarId ? { ...c, isPublic, publicToken, subscriptionToken } : c
                    ));
                } catch (e) {
                    console.error("makeCalendarPublic error", e);
                    alert(t('calendarVisibilityError'));
                }
            };

            // Task Management Functions
            const addTask = async (taskData) => {
                if (!user) return;
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'users', user.uid, 'tasks'), {
                        title: taskData.title || '',
                        description: taskData.description || '',
                        dueDate: taskData.dueDate || null,
                        completed: false,
                        priority: taskData.priority || 'normal',
                        category: taskData.category || 'personal',
                        linkedEventId: taskData.linkedEventId || null,
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    });
                } catch (e) {
                    console.error("addTask error", e);
                    alert(t('taskError'));
                }
            };

            const updateTask = async (taskId, updates) => {
                if (!user) return;
                try {
                    await updateDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'tasks', taskId), {
                        ...updates,
                        updatedAt: serverTimestamp()
                    });
                } catch (e) {
                    console.error("updateTask error", e);
                    alert(t('taskError'));
                }
            };

            const deleteTask = async (taskId) => {
                if (!user) return;
                try {
                    await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'tasks', taskId));
                } catch (e) {
                    console.error("deleteTask error", e);
                    alert(t('taskError'));
                }
            };

            const resolveHolidayCalendarId = () => {
                if (holidayPref?.calendarId) return holidayPref.calendarId;
                if (activeCalendarId && activeCalendarId !== 'all') return activeCalendarId;
                const lastCalendarId = safeStorageGet('timeroster_last_calendar');
                return calendars.find(c => c.id === lastCalendarId)?.id
                    || calendars.find(c => c.ownerId === user?.uid)?.id
                    || calendars[0]?.id
                    || null;
            };

            const syncHolidays = async () => {
                if (!user) return;
                if (!holidayPref?.countryCode) {
                    alert(t('holidaySelectCountryFirst'));
                    return;
                }
                const calendarId = resolveHolidayCalendarId();
                if (!calendarId) {
                    alert(t('selectCalendarForEvent'));
                    return;
                }
                setHolidaySyncing(true);
                const year = new Date().getFullYear();
                const regionCode = holidayPref.regionCode || '';
                const regionName = holidayPref.regionName || '';
                const sourceKey = getHolidaySourceKey(holidayPref.countryCode, regionCode);
                try {
                    const res = await fetch(`${HOLIDAY_API_BASE}/PublicHolidays/${year}/${holidayPref.countryCode}`);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const data = await res.json();
                    const regionFilter = regionCode ? [regionCode] : [];
                    const filtered = Array.isArray(data) ? data.filter(item => {
                        const regions = Array.isArray(item?.counties) ? item.counties : [];
                        if (!regionFilter.length) return true;
                        if (regions.length === 0) return true;
                        return regions.some(r => regionFilter.includes(r));
                    }) : [];
                    if (!filtered.length) {
                        alert(t('holidayNoHolidaysFound'));
                        setHolidaySyncing(false);
                        return;
                    }
                    const eventsRef = collection(db, 'artifacts', appId, 'calendars', calendarId, 'events');
                    let existing = [];
                    try {
                        const snapshot = await getDocs(query(eventsRef, where('source', '==', 'holiday-sync'), where('holidaySource', '==', sourceKey)));
                        existing = snapshot.docs;
                    } catch (err) {
                        const snapshot = await getDocs(query(eventsRef, where('source', '==', 'holiday-sync')));
                        existing = snapshot.docs.filter(docSnap => docSnap.data()?.holidaySource === sourceKey);
                    }
                    const batch = writeBatch(db);
                    existing.forEach(docSnap => batch.delete(docSnap.ref));
                    const now = serverTimestamp();
                    filtered.forEach(item => {
                        const eventDate = item?.date;
                        if (!eventDate) return;
                        const eventId = buildHolidayEventId(calendarId, sourceKey, eventDate, item.localName || item.name);
                        batch.set(doc(eventsRef, eventId), {
                            title: item.localName || item.name || t('holiday'),
                            date: eventDate,
                            time: '00:00',
                            category: 'holiday',
                            repeat: 'none',
                            location: regionName || holidayPref.countryName || holidayPref.countryCode,
                            source: 'holiday-sync',
                            holidaySource: sourceKey,
                            holidayMeta: {
                                countryCode: holidayPref.countryCode,
                                countryName: holidayPref.countryName || holidayPref.countryCode,
                                regionCode,
                                regionName,
                                year
                            },
                            createdAt: now,
                            updatedAt: now,
                            calendarId
                        });
                    });
                    batch.commit();
                    const syncPayload = {
                        ts: Date.now(),
                        calendarId,
                        countryCode: holidayPref.countryCode,
                        countryName: holidayPref.countryName || holidayPref.countryCode,
                        regionCode,
                        regionName,
                        year
                    };
                    safeStorageSet(getHolidaySyncKey(user.uid), JSON.stringify(syncPayload));
                    setHolidayLastSync(syncPayload.ts);
                    setHolidayPref(prev => ({ ...prev, calendarId }));
                    alert(t('holidaySyncSuccess'));
                } catch (e) {
                    console.error("Holiday sync error", e);
                    alert(t('holidaySyncError'));
                } finally {
                    setHolidaySyncing(false);
                }
            };

            const toggleTaskComplete = async (taskId, completed) => {
                await updateTask(taskId, { completed: !completed });
            };

            // Task Time Tracking Functions
            const startTaskTimer = async (taskId) => {
                if (!user || !taskId) return;
                setActiveTaskTimers(prev => ({
                    ...prev,
                    [taskId]: { startTime: Date.now(), taskId }
                }));
            };

            const stopTaskTimer = async (taskId) => {
                if (!user || !taskId) return;
                const timer = activeTaskTimers[taskId];
                if (!timer) return;

                const duration = Math.floor((Date.now() - timer.startTime) / 1000); // in seconds
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'users', user.uid, 'taskTimeEntries'), {
                        taskId,
                        startTime: timer.startTime,
                        endTime: Date.now(),
                        duration,
                        date: formatDate(new Date()),
                        createdAt: serverTimestamp()
                    });
                    
                    setActiveTaskTimers(prev => {
                        const next = { ...prev };
                        delete next[taskId];
                        return next;
                    });
                } catch (e) {
                    console.error("stopTaskTimer error", e);
                }
            };

            const deleteTaskTimeEntry = async (entryId) => {
                if (!user) return;
                try {
                    await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'taskTimeEntries', entryId));
                } catch (e) {
                    console.error("deleteTaskTimeEntry error", e);
                }
            };

            
            const exportCalendarICS = () => {
                if (activeCalendarId === 'all') {
                    alert(t('selectCalendarForEvent'));
                    return;
                }
                if (!events || events.length === 0) {
                    alert(t('noEventsToExport'));
                    return;
                }
                
                const calendar = calendars.find(c => c.id === activeCalendarId);
                const calendarName = calendar ? calendar.name : t('calendarDefaultTitle');
                const icsContent = generateICS(events, calendarName);
                downloadICS(icsContent, `${calendarName.replace(/\s+/g, '_')}.ics`);
            };

            const calendarSelectorOptions = useMemo(() => {
                if (viewingUserId) return [];
                return [{ id: 'all', name: t('allCalendars') }, ...calendars];
            }, [calendars, viewingUserId, lang]);

            const handleCalendarSelect = (value) => {
                setActiveCalendarId(value);
                if (value === 'all') {
                    setSelectedEvent(null);
                }
            };

            useEffect(() => {
                if (activeCalendarId !== 'all' || viewingUserId) return;
                if (!calendars.length) {
                    setEvents([]);
                    setShifts(DEFAULT_SHIFTS);
                    setSchedule({});
                    return;
                }
                const allEvents = [];
                const shiftMap = {};
                const scheduleMap = {};
                calendars.forEach(cal => {
                    (calendarEvents[cal.id] || []).forEach(ev => allEvents.push({ ...ev, calendarId: cal.id }));
                    const shiftsForCalendar = calendarShifts[cal.id] || {};
                    const scheduleForCalendar = calendarSchedule[cal.id] || {};
                    Object.values(shiftsForCalendar).forEach(shift => {
                        if (shift?.id && !shiftMap[shift.id]) shiftMap[shift.id] = shift;
                    });
                    Object.entries(scheduleForCalendar).forEach(([dateStr, shiftId]) => {
                        if (!shiftId) return;
                        const existing = scheduleMap[dateStr];
                        const list = Array.isArray(existing) ? existing.slice() : (existing ? [existing] : []);
                        list.push({ shiftId, calendarId: cal.id });
                        scheduleMap[dateStr] = list;
                    });
                });
                const aggregatedShifts = Object.values(shiftMap);
                setEvents(allEvents);
                setShifts(aggregatedShifts.length ? aggregatedShifts : DEFAULT_SHIFTS);
                setSchedule(scheduleMap);
            }, [activeCalendarId, viewingUserId, calendars, calendarEvents, calendarShifts, calendarSchedule]);

            useEffect(() => {
                if (activeCalendarId === 'all') return;
                if (!activeCalendarId) return;
                setCalendarEvents({});
                setCalendarShifts({});
                setCalendarSchedule({});
            }, [activeCalendarId]);

            const monthEventItems = useMemo(() => {
                if (!events || events.length === 0) return [];
                const baseDate = calendarViewMode === 'month' ? selectedDate : new Date();
                const year = baseDate.getFullYear();
                const month = baseDate.getMonth();
                const start = new Date(year, month, 1);
                const end = new Date(year, month + 1, 0);
                const items = [];
                for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                    const dateStr = formatDate(d);
                    const dayEvents = getEventsForDate(dateStr, events);
                    dayEvents.forEach(ev => {
                        items.push({
                            ...ev,
                            _occDate: dateStr,
                            _key: `${ev.id || 'ev'}_${dateStr}`
                        });
                    });
                }
                items.sort((a,b) => (a._occDate + ' ' + (a.time||'')).localeCompare(b._occDate + ' ' + (b.time||'')));
                return items;
            }, [events, calendarViewMode, selectedDate]);

            const calendarEventListItems = useMemo(() => {
                if (!events || events.length === 0) return [];
                const baseDate = calendarViewMode === 'month' ? selectedDate : new Date();
                const start = new Date(baseDate);
                start.setHours(0, 0, 0, 0);
                const end = new Date(start);
                if (calendarEventListRange === 'day') end.setDate(end.getDate() + 1);
                else if (calendarEventListRange === 'week') end.setDate(end.getDate() + 7);
                else if (calendarEventListRange === 'month') end.setMonth(end.getMonth() + 1);
                else end.setFullYear(end.getFullYear() + 1);
                const items = [];
                for (let d = new Date(start); d < end; d.setDate(d.getDate() + 1)) {
                    const dateStr = formatDate(d);
                    const dayEvents = getEventsForDate(dateStr, events);
                    dayEvents.forEach(ev => {
                        const fallbackId = ev.id || `ev_${items.length}`;
                        items.push({
                            ...ev,
                            _occDate: dateStr,
                            _key: `${fallbackId}_${dateStr}_${calendarEventListRange}`
                        });
                    });
                }
                items.sort((a,b) => (a._occDate + ' ' + (a.time||'')).localeCompare(b._occDate + ' ' + (b.time||'')));
                return items;
            }, [events, calendarViewMode, selectedDate, calendarEventListRange]);
            
            const getPublicLink = (calendarId) => {
                const calendar = calendars.find(c => c.id === calendarId);
                if (!calendar || !calendar.publicToken) return null;
                const baseUrl = getHostedBaseUrl();
                const appPath = getHostedAppPath();
                return `${baseUrl}${appPath}?public=${calendar.publicToken}`;
            };
            
            const getSubscriptionLink = (calendarId) => {
                const calendar = calendars.find(c => c.id === calendarId);
                if (!calendar || !calendar.subscriptionToken) return null;
                const baseUrl = getHostedBaseUrl();
                const appPath = getHostedAppPath();
                const httpUrl = `${baseUrl}${appPath}?ics=${calendar.subscriptionToken}`;
                return httpUrl.replace('http://', 'webcal://').replace('https://', 'webcal://');
            };


            const isComic = theme === 'comic';
            const isAmoled = theme === 'amoled';
            const isMono = theme === 'mono';
            const isLight = theme === 'light';
            const isDark = theme === 'dark';
            const isVibrant = theme === 'vibrant';
            const isCustom = theme === 'custom';
            const themeClasses = (() => {
                if (isLight) {
                    return {
                        input: 'bg-slate-100 border-slate-300 text-slate-900 placeholder-slate-400',
                        select: 'bg-slate-100 border-slate-300 text-slate-900',
                        button: 'bg-blue-600 hover:bg-blue-700 text-white',
                        card: 'bg-white border border-slate-300 shadow-lg text-slate-900',
                        tabBar: 'bg-white border-t-4 border-blue-600',
                        header: 'bg-gradient-to-r from-blue-600 to-blue-700 border-b border-blue-800 text-white',
                        listItem: 'bg-slate-50 hover:bg-slate-100 border border-slate-200',
                        surfaceBtn: 'bg-slate-100 border border-slate-300',
                        calendarHeader: 'bg-gradient-to-r from-blue-600 to-blue-700 border-b border-blue-800 text-white',
                        calendarToolbar: 'bg-slate-100/80 border-b border-slate-200',
                        calendarWeek: 'bg-slate-50 border-b border-slate-200',
                        calendarCell: 'bg-white border border-slate-200',
                    };
                }
                if (isDark) {
                    return {
                        input: 'bg-black border-slate-800 text-white placeholder-slate-500',
                        select: 'bg-black border-slate-800 text-white',
                        button: 'bg-slate-700 hover:bg-slate-600 text-white',
                        card: 'bg-black border border-slate-700 shadow-xl text-white',
                        tabBar: 'bg-black border-t-4 border-blue-500/40',
                        header: 'bg-black border-b border-slate-700 text-white',
                        listItem: 'bg-black border border-slate-700',
                        surfaceBtn: 'bg-black border border-slate-800',
                        calendarHeader: 'bg-black border-b border-slate-700 text-white',
                        calendarToolbar: 'bg-black/80 border-b border-slate-700',
                        calendarWeek: 'bg-black border-b border-slate-700',
                        calendarCell: 'bg-black/80 border border-slate-700',
                    };
                }
                if (isComic) {
                    return {
                        input: 'bg-[#fdf6e3] border-[#8b5a2b] text-[#4a3b2a]',
                        select: 'bg-[#fdf6e3] border-[#8b5a2b] text-[#4a3b2a]',
                        button: 'bg-[#8b5a2b] text-[#f4e4bc] border-2 border-[#5c3a18]',
                        card: 'bg-[#e8d5a5] border-2 border-[#8b5a2b] shadow-lg text-[#4a3b2a]',
                        tabBar: 'bg-[#e8d5a5] border-t-4 border-[#5c3a18]',
                        header: 'bg-[#e8d5a5] border-b-4 border-[#5c3a18]',
                        listItem: 'bg-[#fdf6e3] border-2 border-[#d6c4a0]',
                        surfaceBtn: 'bg-[#e8d5a5] border border-[#8b5a2b]',
                        calendarHeader: 'bg-[#e8d5a5] border-b-4 border-[#5c3a18]',
                        calendarToolbar: 'bg-[#f4e4bc]/60 border-b-2 border-[#d6c4a0]',
                        calendarWeek: 'bg-[#e8d5a5] border-b-2 border-[#d6c4a0]',
                        calendarCell: 'bg-[#fdf6e3] border-2 border-[#d6c4a0]',
                    };
                }
                if (isAmoled) {
                    return {
                        input: 'bg-black border-slate-800 text-white placeholder-slate-500',
                        select: 'bg-black border-slate-800 text-white',
                        button: 'bg-blue-600 hover:bg-blue-700 text-white',
                        card: 'bg-black border border-slate-700 shadow-xl text-white',
                        tabBar: 'bg-black border-t-4 border-blue-500/40',
                        header: 'bg-black border-b border-slate-700',
                        listItem: 'bg-black border border-slate-700',
                        surfaceBtn: 'bg-black border border-slate-800',
                        calendarHeader: 'bg-black border-b border-slate-700',
                        calendarToolbar: 'bg-black/80 border-b border-slate-700',
                        calendarWeek: 'bg-black border-b border-slate-700',
                        calendarCell: 'bg-black/80 border border-slate-700',
                    };
                }
                if (isMono) {
                    return {
                        input: 'bg-black border-white/20 text-white placeholder-white/40',
                        select: 'bg-black border-white/20 text-white',
                        button: 'bg-black text-white border border-white/40 hover:bg-white/15',
                        card: 'bg-black border border-white/25 shadow-xl text-white',
                        tabBar: 'bg-black border-t-4 border-white/40',
                        header: 'bg-black border-b border-white/30',
                        listItem: 'bg-black border border-white/20',
                        surfaceBtn: 'bg-black border border-white/15',
                        calendarHeader: 'bg-black border-b border-white/30',
                        calendarToolbar: 'bg-black/80 border-b border-white/30',
                        calendarWeek: 'bg-black border-b border-white/30',
                        calendarCell: 'bg-black/80 border border-white/30',
                    };
                }
                if (isVibrant) {
                    return {
                        input: 'bg-white/20 border-white/40 text-white placeholder-white/60',
                        select: 'bg-white/20 border-white/40 text-white',
                        button: 'bg-white/30 hover:bg-white/40 text-white',
                        card: 'bg-white/20 border border-white/40 shadow-xl text-white',
                        tabBar: 'bg-white/15 border-t-4 border-white/40',
                        header: 'bg-white/15 border-b border-white/40 text-white',
                        listItem: 'bg-white/15 hover:bg-white/25 border border-white/30',
                        surfaceBtn: 'bg-white/20 border border-white/30',
                        calendarHeader: 'bg-white/15 border-b border-white/40 text-white',
                        calendarToolbar: 'bg-white/15 border-b border-white/40',
                        calendarWeek: 'bg-white/15 border-b border-white/40',
                        calendarCell: 'bg-white/15 border border-white/30',
                    };
                }
                if (isCustom) {
                    return {
                        input: 'custom-input',
                        select: 'custom-input',
                        button: 'custom-button',
                        card: 'custom-card',
                        tabBar: 'custom-card',
                        header: 'custom-header',
                        listItem: 'custom-card',
                        surfaceBtn: 'custom-card',
                        calendarHeader: 'custom-header',
                        calendarToolbar: 'custom-card',
                        calendarWeek: 'custom-card',
                        calendarCell: 'custom-card',
                    };
                }
                return {
                    input: 'bg-slate-100 border-slate-300 text-slate-900 placeholder-slate-400',
                    select: 'bg-slate-100 border-slate-300 text-slate-900',
                    button: 'bg-blue-600 hover:bg-blue-700 text-white',
                    card: 'bg-white border border-slate-300 shadow-lg text-slate-900',
                    tabBar: 'bg-white border-t-4 border-blue-600',
                    header: 'bg-gradient-to-r from-blue-600 to-blue-700 border-b border-blue-800 text-white',
                    listItem: 'bg-slate-50 hover:bg-slate-100 border border-slate-200',
                    surfaceBtn: 'bg-slate-100 border border-slate-300',
                    calendarHeader: 'bg-gradient-to-r from-blue-600 to-blue-700 border-b border-blue-800 text-white',
                    calendarToolbar: 'bg-slate-100/80 border-b border-slate-200',
                    calendarWeek: 'bg-slate-50 border-b border-slate-200',
                    calendarCell: 'bg-white border border-slate-200',
                };
            })();

            const refreshWeather = async ({ force = false, prefOverride = null } = {}) => {
                if (!navigator.onLine) {
                    setWeatherError(t('weatherErrorOffline'));
                    return;
                }
                setWeatherError('');
                setWeatherLoading(true);
                try {
                    if (!force) {
                        const cachedRaw = safeStorageGet(WEATHER_CACHE_KEY);
                        if (cachedRaw) {
                            const cached = JSON.parse(cachedRaw);
                            if (cached?.ts && (Date.now() - cached.ts) < WEATHER_CACHE_TTL_MS && cached?.weather) {
                                setWeather(cached.weather);
                                setWeatherLocation(cached.location || cached.weatherLocation || '');
                                setWeatherLoading(false);
                                return;
                            }
                        }
                    }

                    const pref = prefOverride || weatherPref || { mode: "geo", manual: null };

                    let coords = null;
                    if (pref.mode === "manual" && pref.manual?.lat && pref.manual?.lon) {
                        coords = { lat: pref.manual.lat, lon: pref.manual.lon, label: pref.manual.label || t('manualLabel') };
                    } else {
                        coords = await new Promise((resolve) => {
                            if (!navigator.geolocation) return resolve(DEFAULT_WEATHER_COORDS);
                            navigator.geolocation.getCurrentPosition(
                                (p) => resolve({ lat: p.coords.latitude, lon: p.coords.longitude, label: t('autoLabel') }),
                                () => resolve({ ...DEFAULT_WEATHER_COORDS, label: getWeatherFallbackLabel() }),
                                { enableHighAccuracy: false, timeout: 6000, maximumAge: WEATHER_CACHE_TTL_MS }
                            );
                        });
                    }
                    const url = buildWeatherUrl(coords.lat, coords.lon);
                    const res = await fetch(url);
                    if (!res.ok) throw new Error("HTTP " + res.status);
                    const data = await res.json();

                    const cur = data?.current || {};
                    const payload = {
                        temperature: cur.temperature_2m,
                        wind: cur.wind_speed_10m,
                        code: cur.weather_code,
                        time: cur.time,
                        lat: coords.lat,
                        lon: coords.lon
                    };

                    setWeather(payload);
                    setWeatherLocation(coords.label || "");

                    safeStorageSet(WEATHER_CACHE_KEY, JSON.stringify({
                        ts: Date.now(),
                        location: coords.label || "",
                        weather: payload
                    }));
                } catch (e) {
                    console.error("Weather Error", e);
                    setWeatherError(t('weatherErrorUnavailable'));
                } finally {
                    setWeatherLoading(false);
                }
            };

            // Fetch 7-day weather forecast
            const fetch7DayForecast = async () => {
                setForecastLoading(true);
                try {
                    const coords = weather && weather.lat && weather.lon 
                        ? { lat: weather.lat, lon: weather.lon } 
                        : { ...DEFAULT_WEATHER_COORDS, label: getWeatherFallbackLabel() };
                    
                    const params = new URLSearchParams({
                        latitude: String(coords.lat),
                        longitude: String(coords.lon),
                        daily: "temperature_2m_max,temperature_2m_min,weather_code,precipitation_sum,wind_speed_10m_max",
                        wind_speed_unit: "kmh",
                        temperature_unit: "celsius",
                        timezone: "Europe/Zurich"
                    });
                    const url = `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
                    
                    const res = await fetch(url);
                    if (!res.ok) throw new Error("HTTP " + res.status);
                    const data = await res.json();
                    
                    setForecastData(data.daily);
                    setShowWeatherForecast(true);
                } catch (e) {
                    console.error("Forecast Error", e);
                    setWeatherError(t('forecastErrorUnavailable'));
                } finally {
                    setForecastLoading(false);
                }
            };

            // Handle secret messaging trigger with premium gate
            const handleSecretMessagesTrigger = (options = {}) => {
                try {
                    if (options && options.initialOpen) {
                        setSecretInitialOpen(options.initialOpen);
                    }
                } catch (e) {}
                if (secretPremiumUnlocked && !options.forceCodePrompt) {
                    setShowSecret(true);
                } else {
                    setShowPremiumGate(true);
                }
            };

            // Load weather once after login (and keep cached)
            useEffect(() => {
                if (!user) return;
                refreshWeather({ force: false });
                // eslint-disable-next-line react-hooks/exhaustive-deps
            }, [user?.uid]);
            
            // Load saved weather preference (per user) from localStorage
            useEffect(() => {
                if (!user) return;
                try {
                    const raw = safeStorageGet(getWeatherPrefKey(user.uid));
                    if (raw) setWeatherPref(JSON.parse(raw));
                } catch (e) { /* ignore */ }
            }, [user?.uid]);

            const saveWeatherPreference = (pref) => {
                if (!user) return;
                setWeatherPref(pref);
                safeStorageSet(getWeatherPrefKey(user.uid), JSON.stringify(pref));
                refreshWeather({ force: true, prefOverride: pref });
            };




            
        const appShellClass = theme === 'light'
            ? 'bg-slate-50 text-slate-900'
            : theme === 'dark'
                ? 'bg-black text-white'
                : theme === 'vibrant'
                    ? 'bg-gradient-to-br from-pink-500 via-purple-500 to-orange-400 text-white'
                    : theme === 'custom'
                        ? 'custom-theme'
                        : isComic
                            ? 'bg-[#f4e4bc] text-[#4a3b2a]'
                            : isAmoled
                                ? 'bg-black text-white'
                                : isMono
                                ? 'bg-white text-slate-900'
                                        : 'bg-slate-50 text-slate-900';
            const dashboardLabel = t('dashboard');
            const showUnreadIndicator = unreadMessageCount > 0
                && dailyQuote.categoryKey === NOTIFICATION_INDICATOR_CATEGORY_KEY
                && (!lastUnreadUpdate || isSameDay(new Date(lastUnreadUpdate), new Date()));
            const dashboardLabelWithAlert = showUnreadIndicator && dashboardLabel.startsWith('√ú')
                ? <span><span className="text-red-500">√ú</span>{dashboardLabel.slice(1)}</span>
                : dashboardLabel;
            const acceptedFriendsCount = useMemo(
                () => friends.filter(f => f.status === 'accepted').length,
                [friends]
            );
            const headerTitle = viewingUserId
                ? t('viewing')
                : (view === 'dashboard' ? dashboardLabelWithAlert : (view === 'messages' ? 'Message' : t(view)));
            if (!authChecked) return <div className="flex items-center justify-center min-h-screen bg-slate-100 text-slate-900"><div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div></div>;
            if (view === 'auth') return <AuthView setView={setView} />;

            return (
                <div
                    className={`min-h-screen transition-colors duration-500 ${appShellClass} ${currentFont}`}
                    style={{
                        fontSize: `${fontScale}em`,
                        ...(theme === 'custom'
                            ? {
                                '--custom-bg': customTheme.bg,
                                '--custom-accent': customTheme.accent,
                                '--custom-text': customTheme.text
                            }
                            : {})
                    }}
                >
                    {!showSecret && (
                        <div className={`sticky top-0 z-40 p-4 flex justify-between items-center ${themeClasses.header}`}>
                            <h1 className="text-xl font-bold">{headerTitle}</h1>
                            <button onClick={() => setView('settings')} className="p-2 rounded-lg hover:bg-white/5 active:scale-95" title={t('openSettingsTitle')}><Settings size={20}/></button>
                        </div>
                    )}

                    {/* Global Error Banner */}
                    {uiError && <div className="bg-red-600 text-white p-2 text-center text-xs font-bold">{uiError}</div>}

                    {viewingUserId && !showSecret && <div className="bg-orange-500 text-white p-2 text-center text-xs font-bold flex justify-between items-center px-4"><span>{t('viewing')}: {viewingFriendName || 'Freund'}</span><button onClick={() => setViewingUserId(null)} className="underline">{t('backToMe')}</button></div>}

                    {showSecret && <SecretMsnMessages user={user} initialOpen={secretInitialOpen} onClose={() => { setShowSecret(false); setSecretInitialOpen(null); }} queuePushNotification={queuePushNotification} notificationPrefs={notificationPrefs} saveNotificationPrefs={saveNotificationPrefs} />}

                    {!showSecret && (
                    <main className="pb-24 h-[calc(100vh-60px)] overflow-y-auto">
                        {view === 'dashboard' && (
                            <div className="p-4 space-y-6">
                                <div className={`p-6 rounded-2xl ${themeClasses.card}`}>
                                    
                                    <div className="flex items-start justify-between gap-3">
                                        <div className="min-w-0">
                                            <div className={`text-xs uppercase font-bold ${showUnreadIndicator ? 'blink-red-notification' : 'opacity-60'}`}>
                                                {dailyQuote.category}
                                                {showUnreadIndicator && (
                                                    <span className="ml-2 inline-flex items-center justify-center w-5 h-5 text-[10px] font-bold text-white bg-red-600 rounded-full">
                                                        {unreadMessageCount > 9 ? '9+' : unreadMessageCount}
                                                    </span>
                                                )}
                                            </div>
                                            <h2 className="text-xl font-bold leading-snug mt-1">{dailyQuote.text}</h2>
                                            <div className="text-xs opacity-60 mt-1">{dailyQuote.origin}</div>
                                        </div>
                                    </div>

                                    <div className="mt-4 flex items-center gap-2">
                                        <Briefcase size={16} className="opacity-70"/>
                                        <span>
                                            {(() => {
                                                const todayShift = schedule[formatDate(new Date())];
                                                const shiftItems = Array.isArray(todayShift) ? todayShift : (todayShift ? [todayShift] : []);
                                                if (shiftItems.length === 0) return "Frei";
                                                if (shiftItems.length > 1) return `${shiftItems.length} Schichten`;
                                                const first = shiftItems[0];
                                                const shiftId = typeof first === 'string' ? first : first?.shiftId;
                                                return shifts.find(s=>s.id===shiftId)?.name || "Frei";
                                            })()}
                                        </span>
                                    </div>
                                    <div className="mt-4 p-3 rounded-xl bg-black/10 border border-white/5 flex items-center justify-between gap-3">
                                        <div 
                                            className="flex items-center gap-3 min-w-0 cursor-pointer hover:opacity-80 transition-opacity"
                                            onClick={() => weather && fetch7DayForecast()}
                                            title={t('forecastTitle')}
                                        >
                                            <div className="text-2xl">
                                                {weatherLoading ? "‚è≥" : (weather ? getWeatherMeta(weather.code).icon : "üå°Ô∏è")}
                                            </div>
                                            <div className="min-w-0">
                                                <div className="font-bold truncate">
                                                    {weather ? `${Math.round(weather.temperature)}¬∞C ¬∑ ${getWeatherMeta(weather.code).label}` : (weatherError ? weatherError : "Wetter wird geladen‚Ä¶")}
                                                </div>
                                                <div className="text-xs opacity-70 truncate">
                                                    {weather ? `${weatherLocation || "Standort"} ¬∑ Wind ${Math.round(weather.wind || 0)} km/h` : "Open-Meteo"}
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div className="shrink-0 flex gap-2">
                                            <button
                                                onClick={() => setShowWeatherSettings(true)}
                                                className="px-3 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-xs font-bold"
                                                title={t('selectLocationTitle')}
                                            >
                                                Ort
                                            </button>
                                            <button
                                                onClick={() => refreshWeather({ force: true })}
                                                className="px-3 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-xs font-bold"
                                                title={t('refreshWeatherTitle')}
                                            >
                                                Aktualisieren
                                            </button>
                                        </div>

                                    </div>

                                </div>
                                <button onClick={() => { setSelectedDate(new Date()); setShowEventModal(true); }} className={`w-full p-4 rounded-xl flex items-center justify-center gap-2 ${themeClasses.surfaceBtn}`}><Plus/> <span>{viewingUserId ? t('proposeEventForFriend') : t('newEvent')}</span></button>
                                {pendingEventRequests.length > 0 && (
                                    <div className={`p-4 rounded-xl ${themeClasses.card} border-2 border-orange-500`}>
                                        <details>
                                            <summary className="font-bold mb-3 flex items-center gap-2 text-orange-400 cursor-pointer">
                                                <AlertCircle size={18}/> {t('requestDropdown')} ({pendingEventRequests.length})
                                            </summary>
                                            <div className="space-y-3">
                                                {pendingEventRequests.map(req => (
                                                    <label key={req.id} className={`p-3 rounded-lg flex items-start gap-2 ${isComic?'bg-[#fdf6e3]':'bg-black/20'}`}>
                                                        <input type="checkbox" className="mt-1" value={req.id} onChange={(e) => {
                                                            setPendingEventRequests(prev => prev.map(item => item.id === req.id ? { ...item, selected: e.target.checked } : item));
                                                        }} />
                                                        <div className="flex-1">
                                                            <div className="flex items-start justify-between gap-3 mb-2">
                                                                <div className="flex items-center gap-2 min-w-0">
                                                                    <div className="text-2xl">{CATEGORIES.find(c=>c.id===req.category)?.icon}</div>
                                                                    <div className="min-w-0">
                                                                        <div className="font-bold truncate">{req.title || t(req.category)}</div>
                                                                        <div className="text-xs opacity-70">von {req.fromUserName}</div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            <div className="text-xs opacity-70">{req.date} ¬∑ {req.time}</div>
                                                        </div>
                                                    </label>
                                                ))}
                                                <div className="flex gap-2 pt-2">
                                                    <button
                                                        onClick={() => {
                                                            const ids = pendingEventRequests.filter(r => r.selected).map(r => r.id);
                                                            ids.forEach(id => approvePendingEvent(id));
                                                        }}
                                                        className="flex-1 bg-green-600 text-white p-2 rounded text-xs font-bold"
                                                    >
                                                        {t('acceptSelected')}
                                                    </button>
                                                    <button
                                                        onClick={() => {
                                                            const ids = pendingEventRequests.filter(r => r.selected).map(r => r.id);
                                                            bulkUpdatePendingEvents(ids, 'rejected');
                                                        }}
                                                        className="flex-1 bg-red-500/20 text-red-400 p-2 rounded text-xs font-bold"
                                                    >
                                                        {t('declineSelected')}
                                                    </button>
                                                </div>
                                            </div>
                                        </details>
                                    </div>
                                )}

                                <div className="space-y-3 pb-6">
                                    <div className="flex items-center justify-between">
                                        <h3 className="font-bold">{t('upcoming')}</h3>
                                        <div className="flex items-center gap-1 text-[11px] bg-white/5 border border-white/10 rounded-lg p-1">
                                            <button onClick={() => setUpcomingRange('week')} className={`px-2 py-1 rounded-md ${upcomingRange==='week' ? 'bg-white/10 font-bold' : 'opacity-70 hover:opacity-100'}`}>{t('rangeWeek')}</button>
                                            <button onClick={() => setUpcomingRange('month')} className={`px-2 py-1 rounded-md ${upcomingRange==='month' ? 'bg-white/10 font-bold' : 'opacity-70 hover:opacity-100'}`}>{t('rangeMonth')}</button>
                                            <button onClick={() => setUpcomingRange('year')} className={`px-2 py-1 rounded-md ${upcomingRange==='year' ? 'bg-white/10 font-bold' : 'opacity-70 hover:opacity-100'}`}>{t('rangeYear')}</button>
                                        </div>
                                    </div>

                                    {upcomingItems.length === 0 && <p className="opacity-50 text-center py-4">{t('noUpcoming')}</p>}

                                    {upcomingItems.map(ev => (
                                        <div key={ev._key} onClick={() => setSelectedEvent(ev)} className={`p-4 rounded-xl flex items-center gap-4 cursor-pointer hover:opacity-80 ${isComic?'bg-[#fdf6e3] border-b-2 border-[#d6c4a0]':themeClasses.listItem}`}>
                                            <div className="text-2xl">{CATEGORIES.find(c=>c.id===ev.category)?.icon}</div>
                                            <div className="min-w-0">
                                                <div className="flex items-center justify-between gap-3">
                                                    <div className="font-bold truncate">{t(ev.category)}</div>
                                                    <div className="text-xs opacity-60 whitespace-nowrap">{ev._occDate}{ev.time ? ` ¬∑ ${ev.time}` : ''}</div>
                                                </div>
                                                <div className="text-sm opacity-70 truncate">{ev.title}</div>
                                                <div className="text-[11px] opacity-60 mt-1">{t('countdownLabel')}: {formatCountdownLabel(ev._occDate, ev.time)}</div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                            {view === 'calendar' && !showSearch && (
                                <div className="h-full flex flex-col">
                                    <div className={`flex items-center justify-between px-4 py-2 gap-2 ${themeClasses.calendarHeader}`}>
                                        <div className="flex items-center gap-2">
                                            <div className="flex gap-1 bg-black/20 rounded-lg p-1">
                                                <button onClick={() => setCalendarViewMode('day')} className={`px-3 py-1 rounded text-xs font-bold transition-all ${calendarViewMode === 'day' ? 'bg-blue-600 text-white' : 'opacity-60'}`}>{t('viewDay')}</button>
                                                <button onClick={() => setCalendarViewMode('week')} className={`px-3 py-1 rounded text-xs font-bold transition-all ${calendarViewMode === 'week' ? 'bg-blue-600 text-white' : 'opacity-60'}`}>{t('viewWeek')}</button>
                                                <button onClick={() => setCalendarViewMode('month')} className={`px-3 py-1 rounded text-xs font-bold transition-all ${calendarViewMode === 'month' ? 'bg-blue-600 text-white' : 'opacity-60'}`}>{t('viewMonth')}</button>
                                            </div>
                                            {!viewingUserId && calendarSelectorOptions.length > 0 && (
                                                <div className="flex items-center gap-2">
                                                    <select 
                                                        value={activeCalendarId || ''}
                                                        onChange={(e) => handleCalendarSelect(e.target.value)}
                                                        className={`px-3 py-1.5 rounded-lg text-xs font-bold ${themeClasses.input}`}
                                                    >
                                                        {calendarSelectorOptions.map(cal => (
                                                            <option key={cal.id} value={cal.id}>
                                                                {cal.name}
                                                            </option>
                                                        ))}
                                                    </select>
                                                    {activeCalendarId === 'all' && (
                                                        <span className="text-xs opacity-70 whitespace-nowrap">{t('allCalendars')}</span>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <button onClick={() => setShowAvailabilityOverview(true)} className="p-2 rounded-lg bg-green-600/20 text-green-400" title={t('availabilityOverview')}>
                                                <Users size={18}/>
                                            </button>
                                            <button onClick={() => setShowSearch(true)} className="p-2 rounded-lg bg-blue-600/20 text-blue-400">
                                                <Search size={18}/>
                                            </button>
                                        </div>
                                    </div>
                                {calendarViewMode === 'month' && <CalendarView events={events} shifts={shifts} schedule={schedule} currentUserId={user?.uid || null} assignShift={assignShift} onDateClick={(date, event) => { setSelectedDate(date); if (event) setSelectedEvent(event); }} onDateLongPress={(date) => { setSelectedDate(date); setShowDayOptions(true); }} onSecretTrigger={handleSecretMessagesTrigger} viewingFriend={!!viewingUserId} viewingFriendName={viewingFriendName} themeClasses={themeClasses} isComic={isComic} secretPremiumUnlocked={secretPremiumUnlocked} forecastData={forecastData} disableShiftInteractions={activeCalendarId === 'all'} />}
                                {calendarViewMode === 'week' && <WeekView events={events} selectedDate={selectedDate} onDateClick={(date, event) => { setSelectedDate(date); if (event) setSelectedEvent(event); else setShowDayOptions(true); }} themeClasses={themeClasses} isComic={isComic} forecastData={forecastData}/>}
                                {calendarViewMode === 'day' && <DayView events={events} selectedDate={selectedDate} onDateClick={(date, event) => { setSelectedDate(date); if (event) setSelectedEvent(event); }} onEventUpdate={async (event, updates) => { await updateEvent({ ...event, ...updates }); }} themeClasses={themeClasses} isComic={isComic}/>}
                                <div className={`mx-4 mt-2 rounded-xl border border-white/10 bg-black/20 p-3 ${themeClasses.listItem}`}>
                                    <div className="flex items-center justify-between gap-2">
                                        <label className="text-xs font-bold opacity-70" htmlFor="calendar-event-filter">{t('eventsListLabel')}</label>
                                        <select
                                            id="calendar-event-filter"
                                            value={calendarEventListRange}
                                            onChange={(e) => setCalendarEventListRange(e.target.value)}
                                            className={`px-2 py-1 rounded-lg text-xs font-bold ${themeClasses.select}`}
                                        >
                                            <option value="day">{t('rangeDay')}</option>
                                            <option value="week">{t('rangeWeek')}</option>
                                            <option value="month">{t('rangeMonth')}</option>
                                            <option value="year">{t('rangeYear')}</option>
                                        </select>
                                    </div>
                                    <div className="mt-1 text-[10px] uppercase tracking-wide opacity-60">
                                        {t('rangeDay')} ¬∑ {t('rangeWeek')} ¬∑ {t('rangeMonth')} ¬∑ {t('rangeYear')}
                                    </div>
                                    <div className="mt-3 space-y-2 max-h-48 overflow-y-auto">
                                        {calendarEventListItems.length === 0 && (
                                            <div className="text-xs opacity-60">{t('noEventsInRange')}</div>
                                        )}
                                        {calendarEventListItems.map(ev => {
                                            const cat = CATEGORIES.find(c => c.id === ev.category);
                                            return (
                                                <button
                                                    key={ev._key}
                                                    onClick={() => setSelectedEvent(ev)}
                                                    className={`w-full text-left p-2 rounded-lg flex items-center gap-2 ${isComic ? 'bg-[#fdf6e3]' : themeClasses.listItem}`}
                                                >
                                                    <span className="text-lg">{cat?.icon}</span>
                                                    <div className="flex-1 min-w-0">
                                                        <div className="flex items-center justify-between gap-2">
                                                            <span className="font-bold text-xs truncate">{ev.title}</span>
                                                            <span className="text-[10px] opacity-60 whitespace-nowrap">{ev._occDate}{ev.time ? ` ¬∑ ${ev.time}` : ''}</span>
                                                        </div>
                                                        {activeCalendarId === 'all' && ev.calendarId && (
                                                            <div className="text-[10px] opacity-50 truncate">
                                                                {(calendars.find(c => c.id === ev.calendarId)?.name) || ''}
                                                            </div>
                                                        )}
                                                    </div>
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                                {calendarViewMode === 'month' && (
                                    <details className="mx-4 mb-6 rounded-xl border border-white/10 bg-black/20 overflow-hidden">
                                        <summary className="cursor-pointer px-4 py-3 font-bold text-sm">{t('monthEvents')}</summary>
                                        <div className="px-4 pb-4 space-y-2">
                                            {monthEventItems.length === 0 && (
                                                <div className="text-xs opacity-60">{t('noMonthEvents')}</div>
                                            )}
                                            {monthEventItems.map(ev => {
                                                const cat = CATEGORIES.find(c => c.id === ev.category);
                                                return (
                                                    <button
                                                        key={ev._key}
                                                        onClick={() => setSelectedEvent(ev)}
                                                        className={`w-full text-left p-3 rounded-lg flex items-center gap-3 ${isComic ? 'bg-[#fdf6e3]' : themeClasses.listItem}`}
                                                    >
                                                        <span className="text-xl">{cat?.icon}</span>
                                                        <div className="flex-1 min-w-0">
                                                            <div className="flex items-center justify-between gap-2">
                                                                <span className="font-bold text-sm truncate">{ev.title}</span>
                                                                <span className="text-[10px] opacity-60 whitespace-nowrap">{ev._occDate}{ev.time ? ` ¬∑ ${ev.time}` : ''}</span>
                                                            </div>
                                                            {activeCalendarId === 'all' && ev.calendarId && (
                                                                <div className="text-[10px] opacity-50 truncate">
                                                                    {(calendars.find(c => c.id === ev.calendarId)?.name) || ''}
                                                                </div>
                                                            )}
                                                        </div>
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </details>
                                )}
                                {pendingEventRequests.length > 0 && (
                                    <details className="mx-4 mb-6 rounded-xl border border-white/10 bg-black/20 overflow-hidden">
                                        <summary className="cursor-pointer px-4 py-3 font-bold text-sm text-orange-400">{t('requestDropdown')} ({pendingEventRequests.length})</summary>
                                        <div className="px-4 pb-4 space-y-3">
                                            {pendingEventRequests.map(req => (
                                                <label key={req.id} className={`p-3 rounded-lg flex items-start gap-2 ${isComic?'bg-[#fdf6e3]':'bg-black/20'}`}>
                                                    <input type="checkbox" className="mt-1" value={req.id} onChange={(e) => {
                                                        setPendingEventRequests(prev => prev.map(item => item.id === req.id ? { ...item, selected: e.target.checked } : item));
                                                    }} />
                                                    <div className="flex-1">
                                                        <div className="flex items-start justify-between gap-3 mb-2">
                                                            <div className="flex items-center gap-2 min-w-0">
                                                                <div className="text-2xl">{CATEGORIES.find(c=>c.id===req.category)?.icon}</div>
                                                                <div className="min-w-0">
                                                                    <div className="font-bold truncate">{req.title || t(req.category)}</div>
                                                                    <div className="text-xs opacity-70">von {req.fromUserName}</div>
                                                                </div>
                                                            </div>
                                                        </div>
                                                        <div className="text-xs opacity-70">{req.date} ¬∑ {req.time}</div>
                                                    </div>
                                                </label>
                                            ))}
                                            <div className="flex gap-2 pt-2">
                                                <button
                                                    onClick={() => {
                                                        const ids = pendingEventRequests.filter(r => r.selected).map(r => r.id);
                                                        ids.forEach(id => approvePendingEvent(id));
                                                    }}
                                                    className="flex-1 bg-green-600 text-white p-2 rounded text-xs font-bold"
                                                >
                                                    {t('acceptSelected')}
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        const ids = pendingEventRequests.filter(r => r.selected).map(r => r.id);
                                                        bulkUpdatePendingEvents(ids, 'rejected');
                                                    }}
                                                    className="flex-1 bg-red-500/20 text-red-400 p-2 rounded text-xs font-bold"
                                                >
                                                    {t('declineSelected')}
                                                </button>
                                            </div>
                                        </div>
                                    </details>
                                )}
                            </div>
                        )}

                        {view === 'calendar' && showSearch && (
                            <div className="h-full flex flex-col pb-32">
                                <div className={`p-4 ${themeClasses.calendarHeader}`}>
                                    <div className="flex gap-2 items-center mb-4">
                                        <button onClick={() => { setShowSearch(false); setSearchQuery(''); }} className="p-2"><ArrowLeft /></button>
                                        <input
                                            type="text"
                                            value={searchQuery}
                                            onChange={(e) => setSearchQuery(e.target.value)}
                                            placeholder={t('searchPlaceholder')}
                                            className={`flex-1 p-3 rounded-lg outline-none ${themeClasses.input}`}
                                            autoFocus
                                        />
                                    </div>
                                    <div className="text-sm opacity-70">
                                        {searchResults.length > 0 ? `${searchResults.length} ${t('searchResults')}` : t('noResults')}
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto px-4 space-y-2">
                                    {searchResults.map((ev) => {
                                        const cat = CATEGORIES.find(c => c.id === ev.category);
                                        return (
                                            <div key={ev._key} 
                                                onClick={() => { setSelectedEvent(ev); setShowSearch(false); }}
                                                className={`p-4 rounded-xl cursor-pointer ${isComic ? 'bg-[#f4e4bc] border border-[#8b5a2b] text-[#4a3b2a]' : 'bg-slate-800'}`}>
                                                <div className="flex items-center gap-3">
                                                    <span className="text-2xl">{cat?.icon}</span>
                                                    <div className="flex-1">
                                                        <div className="font-bold">{ev.title}</div>
                                                        <div className="text-sm opacity-70 flex items-center gap-2">
                                                            <Clock size={14}/> {ev._occDate} um {ev.time}
                                                        </div>
                                                        {ev.location && <div className="text-xs opacity-60 flex items-center gap-1 mt-1"><MapPin size={12}/> {ev.location}</div>}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        {view === 'tasks' && (
                            <div className="h-full overflow-y-auto px-4 py-6 space-y-4">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-2xl font-bold flex items-center gap-2">
                                        <ListChecks size={24}/> {t('taskManager')}
                                    </h2>
                                    <button 
                                        onClick={() => setShowStatistics(true)}
                                        className="p-2 rounded-lg bg-purple-500/20 text-purple-400"
                                        title={t('statistics')}
                                    >
                                        <PieChart size={18}/>
                                    </button>
                                </div>
                                
                                {/* Add Task Form */}
                                <div className={`p-4 rounded-xl ${themeClasses.card}`}>
                                    <h3 className="text-sm font-bold opacity-70 mb-3">{t('addTask')}</h3>
                                    <div className="space-y-2">
                                        <input 
                                            type="text" 
                                            placeholder={t('taskTitle')}
                                            value={selectedTask?.title || ''}
                                            onChange={(e) => setSelectedTask(prev => ({ ...(prev || {}), title: e.target.value }))}
                                            className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}
                                        />
                                        <textarea 
                                            placeholder={t('taskDescription')}
                                            value={selectedTask?.description || ''}
                                            onChange={(e) => setSelectedTask(prev => ({ ...(prev || {}), description: e.target.value }))}
                                            className={`w-full p-3 rounded-lg outline-none ${themeClasses.input}`}
                                            rows="3"
                                        />
                                        <div className="grid grid-cols-2 gap-2">
                                            <input 
                                                type="date"
                                                value={selectedTask?.dueDate || ''}
                                                onChange={(e) => setSelectedTask(prev => ({ ...(prev || {}), dueDate: e.target.value }))}
                                                className={`p-2 rounded-lg outline-none ${themeClasses.input}`}
                                            />
                                            <select 
                                                value={selectedTask?.priority || 'normal'}
                                                onChange={(e) => setSelectedTask(prev => ({ ...(prev || {}), priority: e.target.value }))}
                                                className={`p-2 rounded-lg outline-none ${themeClasses.select}`}
                                            >
                                                <option value="high">{t('priorityHigh')}</option>
                                                <option value="normal">{t('priorityNormal')}</option>
                                                <option value="low">{t('priorityLow')}</option>
                                            </select>
                                        </div>
                                        <button 
                                            onClick={() => {
                                                if (!selectedTask?.title?.trim()) {
                                                    alert(t('pleaseEnterTitle'));
                                                    return;
                                                }
                                                if (selectedTask.id) {
                                                    updateTask(selectedTask.id, selectedTask);
                                                } else {
                                                    addTask(selectedTask);
                                                }
                                                setSelectedTask(null);
                                            }}
                                            className={`w-full p-3 rounded-lg font-bold ${themeClasses.button}`}
                                        >
                                            {selectedTask?.id ? t('save') : t('addTask')}
                                        </button>
                                        {selectedTask?.id && (
                                            <button 
                                                onClick={() => setSelectedTask(null)}
                                                className={`w-full p-2 rounded-lg border font-bold text-sm ${themeClasses.surfaceBtn}`}
                                            >
                                                {t('cancel')}
                                            </button>
                                        )}
                                    </div>
                                </div>
                                
                                {/* Task Lists */}
                                {(() => {
                                    const now = new Date();
                                    now.setHours(0, 0, 0, 0);
                                    const today = formatDate(now);
                                    
                                    const overdue = tasks.filter(t => !t.completed && t.dueDate && t.dueDate < today);
                                    const todayTasks = tasks.filter(t => !t.completed && t.dueDate === today);
                                    const upcoming = tasks.filter(t => !t.completed && t.dueDate && t.dueDate > today);
                                    const noDueDate = tasks.filter(t => !t.completed && !t.dueDate);
                                    const completed = tasks.filter(t => t.completed);
                                    
            const TaskCard = ({ task }) => {
                const priorityColors = {
                    high: 'border-l-4 border-red-500',
                    normal: 'border-l-4 border-blue-500',
                    low: 'border-l-4 border-gray-500'
                };
                const taskTime = getTaskTimeStatus(task.id, taskTimeEntries);
                const taskEntries = taskTime.entries;
                const taskTimeLabel = taskTime.label;
                const taskShortDate = task.dueDate || (task.updatedAt?.toDate ? formatDate(task.updatedAt.toDate()) : '');
                
                return (
                    <div className={`p-3 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'} ${priorityColors[task.priority || 'normal']}`}>
                        <div className="flex items-start gap-3">
                            <input 
                                type="checkbox"
                                                        checked={task.completed || false}
                                                        onChange={() => toggleTaskComplete(task.id, task.completed)}
                                                        className="mt-1"
                                                    />
                            <div className="flex-1 min-w-0">
                                <div className="font-bold text-sm truncate">{task.title}</div>
                                {task.description && <div className="text-xs opacity-70 mt-1">{task.description}</div>}
                                {task.dueDate && (
                                        <div className="text-xs opacity-60 mt-1 flex items-center gap-1">
                                            <Clock size={12}/>
                                            {task.dueDate}
                                        </div>
                                    )}
                                    {!task.dueDate && taskShortDate && (
                                        <div className="text-xs opacity-60 mt-1 flex items-center gap-1">
                                            <Clock size={12}/>
                                            {taskShortDate}
                                        </div>
                                    )}
                                {(taskEntries.length > 0 || activeTaskTimers[task.id]) && (
                                    <div className="text-xs opacity-60 mt-1 flex items-center gap-1">
                                        <Clock size={12}/>
                                        {t('timeTracked')}: {taskTimeLabel}
                                    </div>
                                )}
                                <div className="mt-2">
                                    {activeTaskTimers[task.id] ? (
                                        <button
                                            onClick={() => stopTaskTimer(task.id)}
                                            className="w-full p-2 rounded-lg bg-red-500/20 text-red-400 font-bold flex items-center justify-center gap-2 hover:bg-red-500/30 text-xs"
                                        >
                                            <Pause size={14}/> {t('stopTimer')}
                                        </button>
                                    ) : (
                                        <button
                                            onClick={() => startTaskTimer(task.id)}
                                            className="w-full p-2 rounded-lg bg-green-500/20 text-green-400 font-bold flex items-center justify-center gap-2 hover:bg-green-500/30 text-xs"
                                        >
                                            <Timer size={14}/> {t('startTimer')}
                                        </button>
                                    )}
                                    {activeTaskTimers[task.id] && (
                                        <div className="mt-1 text-center text-xs opacity-70">
                                            <span className="animate-pulse">‚óè </span>{t('timerRunning')}
                                        </div>
                                    )}
                                </div>
                                {taskEntries.length > 0 ? (
                                    <div className="mt-2 space-y-2">
                                        <div className="text-[10px] font-bold opacity-70">{t('timeEntries')}</div>
                                        {taskEntries.map(entry => {
                                            const hours = Math.floor(entry.duration / 3600);
                                            const minutes = Math.floor((entry.duration % 3600) / 60);
                                            const timeStr = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
                                            const dateStr = entry.startTime ? new Date(entry.startTime).toLocaleDateString('de-DE', { 
                                                day: '2-digit', 
                                                month: '2-digit',
                                                hour: '2-digit',
                                                minute: '2-digit'
                                            }) : '';
                                            
                                            return (
                                                <div key={entry.id} className={`flex items-center justify-between p-2 rounded-lg ${isComic ? 'bg-[#fdf6e3]' : 'bg-black/20'}`}>
                                                    <div className="flex items-center gap-2">
                                                        <Clock size={12} className="opacity-60"/>
                                                        <span className="text-xs">{timeStr}</span>
                                                        <span className="text-[10px] opacity-60">{dateStr}</span>
                                                    </div>
                                                    <button
                                                        onClick={() => deleteTaskTimeEntry(entry.id)}
                                                        className="text-red-400 hover:text-red-300 p-1"
                                                        title={t('delete')}
                                                    >
                                                        <Trash2 size={12}/>
                                                    </button>
                                                </div>
                                            );
                                        })}
                                        
                                        <div className="p-2 rounded-lg bg-blue-500/10 flex items-center justify-between">
                                            <span className="text-[10px] font-bold">{t('totalTime')}:</span>
                                            <span className="text-[10px] font-bold">{taskTimeLabel}</span>
                                        </div>
                                    </div>
                                ) : (
                                    <div className="text-[10px] opacity-60 text-center py-1">{t('noTimeEntries')}</div>
                                )}
                            </div>
                            <div className="flex gap-1">
                                <button 
                                    onClick={() => setSelectedTask(task)}
                                    className="p-1 text-blue-400 hover:text-blue-300"
                                                        >
                                                            <Pencil size={14}/>
                                                        </button>
                                                        <button 
                                                            onClick={() => {
                                                                if (confirm(t('confirmDelete'))) {
                                                                    deleteTask(task.id);
                                                                }
                                                            }}
                                                            className="p-1 text-red-400 hover:text-red-300"
                                                        >
                                                            <Trash2 size={14}/>
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    };
                                    
                                    return (
                                        <>
                                            {overdue.length > 0 && (
                                                <div>
                                                    <h3 className="text-sm font-bold text-red-400 mb-2 flex items-center gap-2">
                                                        <AlertCircle size={16}/> {t('overdueTasks')} ({overdue.length})
                                                    </h3>
                                                    <div className="space-y-2">
                                                        {overdue.map(task => <TaskCard key={task.id} task={task}/>)}
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {todayTasks.length > 0 && (
                                                <div>
                                                    <h3 className="text-sm font-bold text-orange-400 mb-2">{t('todayTasks')} ({todayTasks.length})</h3>
                                                    <div className="space-y-2">
                                                        {todayTasks.map(task => <TaskCard key={task.id} task={task}/>)}
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {upcoming.length > 0 && (
                                                <div>
                                                    <h3 className="text-sm font-bold text-blue-400 mb-2">{t('upcomingTasks')} ({upcoming.length})</h3>
                                                    <div className="space-y-2">
                                                        {upcoming.map(task => <TaskCard key={task.id} task={task}/>)}
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {noDueDate.length > 0 && (
                                                <div>
                                                    <h3 className="text-sm font-bold opacity-70 mb-2">{t('noDueDateTasks')} ({noDueDate.length})</h3>
                                                    <div className="space-y-2">
                                                        {noDueDate.map(task => <TaskCard key={task.id} task={task}/>)}
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {completed.length > 0 && (
                                                <details className="mt-4">
                                                    <summary className="text-sm font-bold text-green-400 mb-2 cursor-pointer">
                                                        {t('completedTasks')} ({completed.length})
                                                    </summary>
                                                    <div className="space-y-2 mt-2">
                                                        {completed.map(task => <TaskCard key={task.id} task={task}/>)}
                                                    </div>
                                                </details>
                                            )}
                                            
                                            {tasks.length === 0 && (
                                                <div className="text-center py-12 opacity-60">
                                                    <ListChecks size={48} className="mx-auto mb-3 opacity-40"/>
                                                    <div>{t('noTasks')}</div>
                                                </div>
                                            )}
                                        </>
                                    );
                                })()}
                            </div>
                        )}

                    {view === 'friends' && <FriendsView user={user} themeClasses={themeClasses} isComic={isComic} currentShareCode={shareCode} currentUserName={((displayName||'').trim()||getUserName(user))} onSelectFriend={(fid) => { setViewingUserId(fid); setView('calendar'); }}/>} 
                    {view === 'messages' && (
                        <MessagesView
                            user={user}
                            themeClasses={themeClasses}
                            calendars={calendars}
                            activeCalendarId={activeCalendarId}
                            friends={friends}
                            onOpenChat={(friendId, friendName) => {
                                handleSecretMessagesTrigger({ initialOpen: { friendId, friendName } });
                            }}
                        />
                    )}

                    {view === 'settings' && <SettingsView onRegisterFcm={async () => await registerFcmToken()} theme={theme} setTheme={setTheme} lang={lang} setLang={(nextLang) => { setLang(nextLang); setCurrentLang(nextLang); setSettingsEditorLang(nextLang); }} fontScale={fontScale} setFontScale={setFontScale} currentFont={currentFont} setCurrentFont={setCurrentFont} shifts={shifts} saveShiftConfig={saveShiftConfig} deleteShift={deleteShift} signOut={signOut} auth={auth} themeClasses={themeClasses} user={user} shareCode={shareCode} displayName={displayName} setDisplayName={setDisplayName} onSaveDisplayName={saveDisplayName} onOpenVisualEditor={() => setShowVisualSettingsEditor(true)} onOpenFriends={() => setView('friends')} settingsEditorLang={settingsEditorLang} setSettingsEditorLang={setSettingsEditorLang} openCustomThemeWizard={() => setShowCustomThemeWizard(true)} onApplyAiDesign={(prompt) => applyAiDesign({ prompt, setTheme, setCustomTheme, setCurrentFont, setFontScale })} onOpenCalendarManager={() => setShowCalendarManager(true)} onOpenCalendarSettings={(calendar) => { setSelectedCalendarForSettings(calendar); setShowCalendarSettings(true); }} onExportCalendarICS={exportCalendarICS} calendars={calendars} friends={friends} activeCalendarId={activeCalendarId} setActiveCalendarId={setActiveCalendarId} updateCalendar={updateCalendar} shareCalendarWithUser={shareCalendarWithUser} holidayCountries={holidayCountries} holidayCountriesLoading={holidayCountriesLoading} holidayCountriesError={holidayCountriesError} holidayPref={holidayPref} setHolidayPref={setHolidayPref} holidaySyncing={holidaySyncing} holidayLastSync={holidayLastSync} onSyncHolidays={syncHolidays} holidayFilter={holidayFilter} setHolidayFilter={setHolidayFilter} notificationPrefs={notificationPrefs} saveNotificationPrefs={saveNotificationPrefs} notificationsSupported={notificationsSupported} fcmToken={fcmToken} requestNotificationPermission={requestNotificationPermission} pwaInstallPrompt={pwaInstallPrompt} isPwaInstalled={isPwaInstalled} installPwa={installPwa} />}
                    </main>
                    )}

                    {/* In-App Toast Notifications */}
                    <div className="fixed top-4 right-4 z-[200] flex flex-col gap-2 max-w-sm pointer-events-none">
                        {toastQueue.map((toast) => (
                            <div key={toast.id} className="pointer-events-auto bg-slate-900/95 backdrop-blur-xl text-white rounded-2xl p-3.5 shadow-2xl border border-white/10 flex items-start gap-3" style={{animation: 'msg-slide-in 0.3s cubic-bezier(0.22, 1, 0.36, 1) forwards'}}>
                                <div className="w-8 h-8 rounded-xl bg-blue-600 flex items-center justify-center flex-shrink-0 mt-0.5">
                                    <Bell size={14}/>
                                </div>
                                <div className="flex-1 min-w-0">
                                    <div className="text-sm font-semibold truncate">{toast.title}</div>
                                    <div className="text-xs text-gray-400 truncate mt-0.5">{toast.body}</div>
                                </div>
                                <button onClick={() => setToastQueue(prev => prev.filter(t => t.id !== toast.id))} className="text-gray-500 hover:text-white p-1 flex-shrink-0">
                                    <X size={12}/>
                                </button>
                            </div>
                        ))}
                    </div>

                    {!showSecret && (
                        <nav className={`fixed bottom-0 w-full pb-safe pt-2 px-6 flex justify-between items-center z-50 ${themeClasses.tabBar}`}>
                            {[{id:'dashboard',icon:<Home/>,l:dashboardLabelWithAlert},{id:'calendar',icon:<Calendar/>,l:t('calendar')},{id:'tasks',icon:<ListChecks/>,l:t('taskManager')},{id:'messages',icon:<MessageCircle/>,l:'Message'},{id:'settings',icon:<Settings/>,l:t('settings')}].map(i => (
                                <button key={i.id} onClick={() => setView(i.id)} className={`flex flex-col items-center p-2 rounded-lg ${view===i.id?(isComic?'text-[#8b5a2b] font-bold scale-110':'text-blue-400'):'opacity-60'}`}>{i.icon}<span className="text-[10px] mt-1">{i.l}</span></button>
                            ))}
                        </nav>
                    )}

                    <EventModal show={showEventModal} onClose={()=>setShowEventModal(false)} onSave={addEvent} selectedDate={selectedDate} themeClasses={themeClasses} isComic={isComic} user={user} viewingFriendId={viewingUserId} viewingFriendName={viewingFriendName} currentUserName={((displayName||'').trim()||getUserName(user))}/>
                    <AvailabilityOverviewModal show={showAvailabilityOverview} onClose={()=>setShowAvailabilityOverview(false)} selectedDate={selectedDate} themeClasses={themeClasses} isComic={isComic} user={user} friends={friends.filter(f => f.status === 'accepted')} allEvents={events}/>
                    <DayOptionsModal show={showDayOptions} onClose={()=>setShowDayOptions(false)} onAssignShift={assignShift} onClearShift={clearShift} onCreateEvent={()=>{setShowEventModal(true);}} selectedDate={selectedDate} shifts={shifts} themeClasses={themeClasses} isComic={isComic} viewingFriend={!!viewingUserId} disableShiftInteractions={activeCalendarId === 'all'}/>
                    <EventDetailModal event={selectedEvent} onClose={()=>setSelectedEvent(null)} onSave={updateEvent} onDelete={deleteEvent} themeClasses={themeClasses} isComic={isComic} user={user} onUpdateParticipantStatus={updateParticipantStatus} taskTimeEntries={taskTimeEntries} activeTaskTimers={activeTaskTimers} startTaskTimer={startTaskTimer} stopTaskTimer={stopTaskTimer} deleteTaskTimeEntry={deleteTaskTimeEntry}/>
                    <StatisticsModal show={showStatistics} onClose={()=>setShowStatistics(false)} events={events} tasks={tasks} taskTimeEntries={taskTimeEntries} themeClasses={themeClasses} isComic={isComic}/>

                    <WeatherLocationModal
                        show={showWeatherSettings}
                        onClose={() => setShowWeatherSettings(false)}
                        currentPref={weatherPref}
                        onSave={(pref) => { saveWeatherPreference(pref); setShowWeatherSettings(false); }}
                    />
                    
                    <WeatherForecastModal
                        show={showWeatherForecast}
                        onClose={() => setShowWeatherForecast(false)}
                        forecastData={forecastData}
                        weatherLocation={weatherLocation}
                    />
                    
                    <PremiumGateModal
                        show={showPremiumGate}
                        onClose={() => setShowPremiumGate(false)}
                        onUnlock={() => setSecretPremiumUnlocked(true)}
                    />
                    
                    <CalendarManagerModal
                        show={showCalendarManager}
                        onClose={() => setShowCalendarManager(false)}
                        calendars={calendars}
                        createCalendar={createCalendar}
                        themeClasses={themeClasses}
                        currentUserId={user?.uid}
                        friends={friends}
                    />
                    
                    <CalendarSettingsModal
                        show={showCalendarSettings}
                        onClose={() => setShowCalendarSettings(false)}
                        calendar={selectedCalendarForSettings}
                        makePublic={makeCalendarPublic}
                        getPublicLink={getPublicLink}
                        getSubscriptionLink={getSubscriptionLink}
                        updateCalendar={updateCalendar}
                        themeClasses={themeClasses}
                        friends={friends}
                        shareCalendarWithUser={shareCalendarWithUser}
                        currentUserId={user?.uid}
                    />

                    <VisualSettingsModal
                        show={showVisualSettingsEditor}
                        onClose={() => setShowVisualSettingsEditor(false)}
                        theme={theme}
                        setTheme={setTheme}
                        currentFont={currentFont}
                        setCurrentFont={setCurrentFont}
                        fontScale={fontScale}
                        setFontScale={setFontScale}
                        settingsEditorLang={settingsEditorLang}
                        setSettingsEditorLang={setSettingsEditorLang}
                        showMigrationNotice={showSettingsMigrationNotice}
                        customTheme={customTheme}
                    />

                    <CustomThemeWizard
                        show={showCustomThemeWizard}
                        onClose={() => setShowCustomThemeWizard(false)}
                        customTheme={customTheme}
                        setCustomTheme={setCustomTheme}
                    />

                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<TimeRosterApp />);
    </script>
</body>
</html>
