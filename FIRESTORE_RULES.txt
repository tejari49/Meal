rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() {
      return request.auth != null;
    }

    function isSelf(uid) {
      return signedIn() && request.auth.uid == uid;
    }

    // ---- App (timeroster-app) ----
    match /artifacts/{appId} {
      // (Optional) root doc read; not required by app
      allow read: if true;

      // Calendars
      match /calendars/{calendarId} {
        allow read: if signedIn() && (request.auth.uid in resource.data.members || resource.data.ownerId == request.auth.uid);
        allow create: if signedIn() && request.resource.data.ownerId == request.auth.uid && (request.auth.uid in request.resource.data.members);
        allow update, delete: if signedIn() && (resource.data.ownerId == request.auth.uid || (resource.data.admins != null && request.auth.uid in resource.data.admins));

        match /events/{eventId} {
          allow read, create, update, delete: if signedIn() && (request.auth.uid in get(/databases/$(database)/documents/artifacts/$(appId)/calendars/$(calendarId)).data.members);
        }
      }

      // User private area
      match /users/{uid} {
        // base user doc only for owner
        allow read, write: if isSelf(uid);

        // Public-ish secret profile (needed for presence + public keys)
        match /secret_msn_profile/{docId} {
          allow read: if signedIn();
          allow write: if isSelf(uid);
        }

        // FCM tokens
        match /fcm_tokens/{tokenId} {
          allow read, write: if isSelf(uid);
        }

        // Pending calendar invites
        match /pending_events/{id} {
          allow read, write: if isSelf(uid);
        }

        // Friends / events / tasks
        match /friends/{id} {
          // Allow user to write ONLY their own friend-link doc inside another user's friends subcollection
          // (docId == auth.uid). This enables friend requests/accept without broad access.
          allow read, write: if isSelf(uid) || (signedIn() && request.auth.uid == id);
        }
        match /events/{id} { allow read, write: if isSelf(uid); }
        match /tasks/{id} { allow read, write: if isSelf(uid); }

        // Secret contacts
        match /secret_contacts/{id} {
          allow read, write: if isSelf(uid);
        }

        // Catch-all for other user subcollections
        match /{subCollection}/{docId} {
          allow read, write: if isSelf(uid);
        }
      }

      

// Public friend codes (doc id = code) - used by app UI "friend code"
match /public_profiles/{code} {
  allow read: if signedIn();
  allow create, update: if signedIn() && request.resource.data.userId == request.auth.uid;
  allow delete: if false;
}

// Secret share codes (doc id = code)
      match /secret_public_codes/{code} {
        allow read: if signedIn();
        allow create, update: if signedIn() && request.resource.data.userId == request.auth.uid;
        allow delete: if false;
      }

      // Secret friend requests
      match /secret_requests/{reqId} {
        allow read: if signedIn() && (resource.data.to == request.auth.uid || resource.data.from == request.auth.uid);
        allow create: if signedIn() && request.resource.data.from == request.auth.uid;
        // Recipient accepts (status update). Sender may update only their own request meta.
        allow update: if signedIn() && ((resource.data.to == request.auth.uid) || (resource.data.from == request.auth.uid));
        allow delete: if false; // Cloud Function cleans up accepted requests
      }

      // Secret 1:1 chats (chatId = uid_uid sorted)
      match /secret_chats/{chatId} {
        allow read, write: if signedIn() && chatId.matches('.*' + request.auth.uid + '.*');
        match /msgs/{msgId} {
          allow read, write: if signedIn() && chatId.matches('.*' + request.auth.uid + '.*');
        }
      }

      // Secret groups
      match /secret_groups/{groupId} {
        allow read: if signedIn() && (request.auth.uid in resource.data.members);
        allow create: if signedIn() && (request.auth.uid in request.resource.data.members);
        allow update, delete: if signedIn() && resource.data.createdBy == request.auth.uid;

        match /msgs/{msgId} {
          allow read, create, update, delete: if signedIn() && (request.auth.uid in get(/databases/$(database)/documents/artifacts/$(appId)/secret_groups/$(groupId)).data.members);
        }
      }

      // Notification queue (client creates; Cloud Function sends)
      match /notification_queue/{id} {
        allow create: if signedIn() && request.resource.data.data.senderId == request.auth.uid;
        allow read, update, delete: if false;
      }
    }
  }
}
